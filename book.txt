

	Directed trees
	Directed forests
  Directed acyclic graphs
  Directed graphs
	Directed multigraphs

	Undirected lists
	Undirected trees
	Undirected forests
  Undirected acyclic graphs
  Undirected graphs
  Undirected multigraphs


	Arbitrary size integers
		d = sum of d_base^k * base^k, for k = 0, 1, 2, ...
		TODO

	Rational numbers
		The rational numbers are defined as the set of all possible fractions. That is, one integer divided by another, where the denominator cannot be zero.
		In mathematical set notation,
			Q = { a / b, where a is an integer and b is an integer not equal to zero }

	Fixed point

	Floating point
		IEEE754 standard
		TODO

		Kahan summation

	Sequences / Strings
		Subsequence / substring
		Views
			External length
			Internal length
		Contains
		Count
		Find
			Forward
			Reverse
		Replace

		Concatenate
		  template<typename T> void concatenate(const span<const span<T>> spans, vector<T>& result) {
		    size_t cResult = 0;
		    for (const auto& s : spans)
		      cResult += s.size();
	      result.resize(cResult);
	      auto r = begin(result);
	      for (const auto& s : spans) {
	        for (const auto& e : s) {
	          *r = e;
	          ++r;
	        }
	      }
	      PRECONDITION(r == end(result));
		  }

		Zipper merge
			Given two sorted sequences, merge them into one sorted sequence.

			template<typename T> void zipperMerge(const span<T> A, const span<T> B, vector<T>& result) {
			  result.resize(A.size() + B.size());
			  auto a = begin(A);
			  const auto a1 = end(A);
			  auto b = begin(B);
			  const auto b1 = end(B);
			  auto r = begin(result);
			  while (a != a1 && b != b1) {
			    if (*a <= *b) {
			      *r = *a;
		        ++r;
			      ++a;
			    }
			    else {
			      *r = *b;
		        ++r;
			      ++b;
			    }
			  }
			  while (a != a1) {
		      *r = *a;
	        ++r;
		      ++a;
			  }
			  while (b != b1) {
		      *r = *b;
	        ++r;
		      ++b;
			  }
			  PRECONDITION(a == a1);
			  PRECONDITION(b == b1);
			  PRECONDITION(r == end(result));
			}

	Intervals
		()
		[]
		(]
		[)
		  template<typename T> struct IntervalEE { T p0, p1; };
		  template<typename T> struct IntervalII { T p0, p1; };
		  template<typename T> struct IntervalEI { T p0, p1; };
		  template<typename T> struct IntervalIE { T p0, p1; };
		Discrete vs continuous
		Tiling

		Overlap
		  template<typename T> __forceinline bool overlaps(const IntervalII<T>& A, const IntervalII<T>& B) {
		    // Assume A.p0 <= A.p1, and the same for B.
		    // There's no overlap when A.p1 < B.p0 (A entirely left of B), or A.p0 > B.p1 (A entirely right of B).
		    // Negation gives us the final equation.
		    return !(A.p1 < B.p0 or A.p0 > B.p1);
		  }
		  template<typename T> bool intervalsSortedByStart(const span<const IntervalII<T>> intervals) {
		    const size_t cIntervals = intervals.size();
		    for (size_t i = 1; i < cIntervals; ++i) {
		      if (intervals[i-1].p0 > intervals[i].p0) {
		        return false;
		      }
		    }
		    return true;
		  }
		  template<typename T> vector<IntervalII<T>> sortIntervalsByStart(const span<const IntervalII<T>> intervals) {
	      vector<IntervalII<T>> intervalsS(begin(intervals), end(intervals));
	      sort(begin(intervalsS), end(intervalsS), [](const IntervalII<T>& A, const IntervalII<T>& B) {
	        return A.p0 < B.p0;
	      });
	      return intervalsS;
      }
		  
		  template<typename T> bool anyOverlap(const span<const IntervalII<T>> intervals) {
		    // If the intervals list is sorted by interval start, we can compare neighbors instead of doing full all-pairs comparison.
		    auto anyOverlapSorted = [](const span<const IntervalII<T>> intervalsSorted) {
		      const size_t cIntervals = intervals.size();
  		    for (size_t i = 1; i < cIntervals; ++i) {
  		      if (intervalsSorted[i-1].p1 >= intervalsSorted[i].p0) {
  		        return true;
		        }
		      }
		      return false;
		    };
		    if (intervalsSortedByStart(intervals)) {
		      return anyOverlapSorted(intervals);
		    }
		    else {
		      return anyOverlapSorted(sortIntervalsByStart(intervals));
		    }
		  }
		  template<typename T> bool allOverlap(const span<const IntervalII<T>> intervals) {
		    if (!intervals.empty()) {
		      const auto& A = intervals[0];
		      const size_t cIntervals = intervals.size();
		      for (size_t i = 1; i < cIntervals; ++i) {
		        const auto& B = intervals[i];
		        if (!overlaps(A, B))
		          return false;
		      }
		    }
	      return true;
		  }

		Intersect
	  Union
	  Difference
	  Symmetric difference
		Contains
			Given a point and an interval, return if the point is inside the interval.
			Given a point and a set of intervals, return if the point is inside any interval.
		Covering
			Given a set of points and a set of intervals, return if all points are inside any interval.
		Merging
			Given a set of intervals, merge them if adjacent/overlapping.
			  template<typename T> __forceinline bool adjacent(const IntervalII<T>& A, const IntervalII<T>& B) {
			    return A.p1 + 1 == B.p0 or B.p1 + 1 == A.p0;
			  }
			  template<typename T> __forceinline bool adjacentOrOverlap(const IntervalII<T>& A, const IntervalII<T>& B) {
			    return adjacent(A, B) or overlaps(A, B);
		    }
		    template<typename T> void merge(const span<const IntervalII<T>> intervals, vector<IntervalII<T>>& result) {
		      result.clear();
		      if (intervalsSortedByStart(intervals)) {
		        
		      }
		      else {
		      }
		    }
		    
			Given two lists of sorted, non-adjacent/overlapping intervals, merge them into one list.
