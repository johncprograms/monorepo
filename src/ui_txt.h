// Copyright (c) John A. Carlos Jr., all rights reserved.

struct
scrollpos_t
{
  content_ptr_t y; // pos at line start.
  f64 frac; // fractional line offset, in units of lines. TODO: consider kahan64_t, since we do lots of accumulation
};


Enumc( seltype_t )
{
  none,
  s,
  m,
};


// if you change this struct, be sure to change: CsUndoFromTxt, ApplyCsUndo, cs_undo_absolute_t
// this also must match the set of things in __TxtConcurrentPtrs, so that our txt undo/redo restores all
// content ptrs to valid things.
struct
cs_undo_t
{
  content_ptr_t c;
  content_ptr_t s;
  idx_t c_inline;
  bool overwrite;
  seltype_t seltype;
  scrollpos_t scroll_target;
  scrollpos_t scroll_start;
  content_ptr_t scroll_end;
};

Inl bool
Equal( cs_undo_t& a, cs_undo_t& b )
{
  bool r = 1;
  r = r  &&  Equal( a.c, b.c );
  r = r  &&  Equal( a.s, b.s );
  r = r  &&  ( a.c_inline == b.c_inline );
  r = r  &&  ( a.overwrite == b.overwrite );
  r = r  &&  ( a.seltype == b.seltype );
  r = r  &&  Equal( a.scroll_target.y, b.scroll_target.y );
  r = r  &&  ( ABS( a.scroll_target.frac - b.scroll_target.frac ) < 0.2 );
  r = r  &&  Equal( a.scroll_start.y, b.scroll_start.y );
  r = r  &&  ( ABS( a.scroll_start.frac - b.scroll_start.frac ) < 0.2 );
  r = r  &&  Equal( a.scroll_end, b.scroll_end );
  return r;
}

struct
cs_undo_absolute_t
{
  idx_t c;
  idx_t s;
  idx_t c_inline;
  bool overwrite;
  seltype_t seltype;
  idx_t scroll_target_y;
  f64   scroll_target_frac;
  idx_t scroll_start_y;
  f64   scroll_start_frac;
  idx_t scroll_end;
};

Inl bool
Equal( cs_undo_absolute_t& a, cs_undo_absolute_t& b )
{
  bool r = 1;
  r = r  &&  ( a.c == b.c );
  r = r  &&  ( a.s == b.s );
  r = r  &&  ( a.c_inline == b.c_inline );
  r = r  &&  ( a.overwrite == b.overwrite );
  r = r  &&  ( a.seltype == b.seltype );
  r = r  &&  ( a.scroll_target_y == b.scroll_target_y );
  r = r  &&  ( ABS( a.scroll_target_frac - b.scroll_target_frac ) < 0.2 );
  r = r  &&  ( a.scroll_start_y == b.scroll_start_y );
  r = r  &&  ( ABS( a.scroll_start_frac - b.scroll_start_frac ) < 0.2 );
  r = r  &&  ( a.scroll_end == b.scroll_end );
  return r;
}



struct
txt_dblclick_t
{
  bool first_made;
  idx_t first_cursor;
  u64 first_clock;
};

struct
linerect_t
{
  vec2<f32> p0;
  vec2<f32> p1;
  content_ptr_t line_start;
};


struct
txt_t
{
  fsobj_t filename;
  buf_t buf;
  content_ptr_t c; // cursor position.
  content_ptr_t s; // select anchor.
  idx_t c_inline; // stored so cursor / select u,d will try to stay on same ch.
  bool overwrite;
  seltype_t seltype;
  scrollpos_t scroll_start; // this is the line-start of the FIRST line of the CURRENT scroll view.
  scrollpos_t scroll_target; // this is the line-start of the CENTER line of the TARGET scroll view.
  content_ptr_t scroll_end; // this is the line-start of the LAST line of the CURRENT scroll view.
  kahan64_t scroll_vel;
  f32 scroll_x;
  u16 window_n_lines;
  array_t<cs_undo_t> undos_txtcs; // used in CmdTxtUndo/Redo. stores cursel state prior to each change.
  array_t<cs_undo_t> redos_txtcs; // no need to update as concurrents, since these are locked into txt undo, which always restores previous diff state.
  array_t<cs_undo_absolute_t> undos; // used in CmdCsUndo/Redo. stores cursel state prior to each change.
  array_t<cs_undo_absolute_t> redos; // we get away with not updating these as concurrents, since they're absolute indices.
  txt_dblclick_t dblclick;
  fontlayout_t layout; // created on every EditRender call. sent to Glw for rendering. used by EditControlMouse for screen -> cursel mapping.
  array_t<linerect_t> linerects; // generated by rendering, used by mouse code to map to a line position.
  bool insert_spaces_for_tabs;
  u8 spaces_per_tab;
  bool text_grabbed;
  bool scroll_grabbed;
};

// all of the content_ptr_t's that must be updated as part of forward editing operations.
// must also match the set of things in cs_undo_t
#define __TxtConcurrentPtrs( txt ) \
  &( txt ).c, \
  &( txt ).s, \
  &( txt ).scroll_start.y, \
  &( txt ).scroll_target.y, \
  &( txt ).scroll_end \




#define __TxtCmd( name )   void ( name )( txt_t& txt, idx_t misc = 0, idx_t misc2 = 0 )
#define __TxtCmdDef( name )   void ( name )( txt_t& txt, idx_t misc, idx_t misc2 )
typedef __TxtCmdDef( *pfn_txtcmd_t );








// =================================================================================
// FIRST / LAST CALLS
//

void
Init( txt_t& txt )
{
  txt.filename.mem[0] = 0;
  txt.filename.len = 0;
  Init( txt.buf );
  txt.c = {};
  txt.s = {};
  txt.c_inline = 0;
  txt.overwrite = 0;
  txt.seltype = seltype_t::none;
  txt.scroll_start = {};
  txt.scroll_target = {};
  txt.scroll_end = {};
  txt.scroll_vel = {};
  txt.scroll_x = 0;
  txt.window_n_lines = 0;
  Alloc( txt.undos_txtcs, 16 );
  Alloc( txt.redos_txtcs, 16 );
  Alloc( txt.undos, 16 );
  Alloc( txt.redos, 16 );
  txt.dblclick.first_made = 0;
  txt.dblclick.first_cursor = 0;
  txt.dblclick.first_clock = 0;
  FontInit( txt.layout );
  Alloc( txt.linerects, 16 );
  txt.text_grabbed = 0;
  txt.scroll_grabbed = 0;
}

void
Kill( txt_t& txt )
{
  txt.filename.mem[0] = 0;
  txt.filename.len = 0;
  Kill( txt.buf );
  Free( txt.undos_txtcs );
  Free( txt.redos_txtcs );
  Free( txt.undos );
  Free( txt.redos );
  txt.dblclick.first_made = 0;
  txt.dblclick.first_cursor = 0;
  txt.dblclick.first_clock = 0;
  FontKill( txt.layout );
  Free( txt.linerects );
  txt.text_grabbed = 0;
  txt.scroll_grabbed = 0;
}


void
TxtLoadEmpty( txt_t& txt )
{
  txt.filename.mem[0] = 0;
  txt.filename.len = 0;
  BufLoadEmpty( txt.buf );

  txt.spaces_per_tab = GetPropFromDb( u8, u8_spaces_per_tab );
  txt.insert_spaces_for_tabs = GetPropFromDb( bool, bool_insert_spaces_for_tabs );
}

void
TxtLoad( txt_t& txt, file_t& file )
{
  ProfFunc();
  Memmove( txt.filename.mem, ML( file.obj ) );
  txt.filename.len = file.obj.len;

  BufLoad( txt.buf, file );

  auto default_spaces_per_tab = GetPropFromDb( u8, u8_spaces_per_tab );
  auto default_insert_spaces_for_tabs = GetPropFromDb( bool, bool_insert_spaces_for_tabs );

  // analyze leading spaces and tabs to figure out what settings to use for this file.

  static const idx_t c_lines = 200;
  array_t<vec2<idx_t>> spacetabs;
  Alloc( spacetabs, c_lines );

#if 0
  idx_t pos = 0;
  auto lines = c_lines;
  while( lines ) {
    auto bol = pos;
    auto len = CursorSkipSpacetabR( txt.buf, bol ) - bol;
    if( len ) {
      lines -= 1;
      auto tmp = AllocContents( txt.buf, bol, len );
      auto spacetab = AddBack( spacetabs );
      *spacetab = _vec2<idx_t>( 0, 0 );
      For( i, 0, len ) {
        if( tmp.mem[i] == ' ' ) {
          spacetab->x += 1;
        } elif( tmp.mem[i] == '\t' ) {
          spacetab->y += 1;
        } else {
          UnreachableCrash();
        }
      }
      Free( tmp );
    }
    auto nextline = CursorLineD( txt.buf, pos, 0, 0 );
    if( nextline == pos ) {
      break;
    }
    pos = nextline;
  }
#endif

  auto uniform_pos = GetBOF( txt.buf );
  For( i, 0, c_lines ) {
    auto bol = CursorStopAtNewlineL( txt.buf, uniform_pos, 0 );
    idx_t len;
    auto bol_space = CursorSkipSpacetabR( txt.buf, bol, &len );
    if( len ) {
      auto tmp = AllocContents( txt.buf, bol, len );
      auto spacetab = AddBack( spacetabs );
      *spacetab = _vec2<idx_t>( 0, 0 );
      For( j, 0, len ) {
        if( tmp.mem[j] == ' ' ) {
          spacetab->x += 1;
        } elif( tmp.mem[j] == '\t' ) {
          spacetab->y += 1;
        } else {
          UnreachableCrash();
        }
      }
      Free( tmp );
    }

    uniform_pos = CursorCharR(
      txt.buf,
      uniform_pos,
      Round_idx_from_f32( Cast( f32, txt.buf.content_len ) / c_lines ),
      0
      );
  }

  bool enough_samples = ( spacetabs.len >= 4 );
  idx_t linecount_mixed = 0;
  idx_t linecount_allspaces = 0;
  idx_t linecount_alltabs = 0;
  ForLen( i, spacetabs ) {
    auto spacetab = spacetabs.mem + i;
    if( spacetab->x  &&  spacetab->y ) {
      linecount_mixed += 1;
    } elif( spacetab->x ) {
      linecount_allspaces += 1;
    } elif( spacetab->y ) {
      linecount_alltabs += 1;
      // remove the alltab line.
      *spacetab = spacetabs.mem[ spacetabs.len - 1 ];
      spacetabs.len -= 1;
      i -= 1;
    }
  }
  if( !enough_samples ) {
    txt.insert_spaces_for_tabs = default_insert_spaces_for_tabs;
    txt.spaces_per_tab = default_spaces_per_tab;
  } elif( c_lines * linecount_allspaces <= 5 * linecount_alltabs ) {
    txt.insert_spaces_for_tabs = 0;
    txt.spaces_per_tab = default_spaces_per_tab;
  } elif( 10 * linecount_mixed >= c_lines ) {
    txt.insert_spaces_for_tabs = default_insert_spaces_for_tabs;
    txt.spaces_per_tab = default_spaces_per_tab;
  } else {
    txt.insert_spaces_for_tabs = 1;
    // compute a fuzzy greatest-common-denominator for { spacetabs->x }
    f32 scores[16]; // 16 spaces_per_tab should be enough for anyone.
    f32 score_max = 0;
    ReverseFor( i, 1, _countof( scores ) ) { // exclude 1 spaces_per_tab, since that would always score highest.
      scores[i] = 0;
      auto rec_spaces_per_tab = 1.0f / Cast( f32, i + 1 );
      ForLen( j, spacetabs ) {
        auto spacetab = spacetabs.mem + j;
        auto divtest = Cast( f32, spacetab->x ) * rec_spaces_per_tab;
        scores[i] += Pow32( Frac32( divtest ), rec_spaces_per_tab );
      }
      score_max = MAX( score_max, scores[i] );
    }
    AssertWarn( score_max > 0 );
    For( i, 1, _countof( scores ) ) {
      scores[i] /= score_max;
    }
    bool found = 0;
    constant auto score_threshold = 0.15f;
    ReverseFor( i, 1, _countof( scores ) ) {
      if( scores[i] <= score_threshold ) {
        txt.spaces_per_tab = Cast( u8, i + 1 );
        found = 1;
        break;
      }
    }
    if( !found ) {
      txt.spaces_per_tab = default_spaces_per_tab;
    }
  }

  Free( spacetabs );
}

void
TxtSave( txt_t& txt, file_t& file )
{
  BufSave( txt.buf, file );
}

#define TxtLen( txt ) \
  ( ( txt ).buf.content_len )


// =================================================================================
// CURSOR / SELECT NAVIGATION
//

Inl idx_t
GetInline( txt_t& txt, content_ptr_t pos )
{
  idx_t pos_inline;
  CursorStopAtNewlineL( txt.buf, pos, &pos_inline );
  return pos_inline;
}



Inl void
ResetCInline( txt_t& txt )
{
  txt.c_inline = GetInline( txt, txt.c );
}



Inl void
CsUndoAbsoluteFromTxt( txt_t& txt, cs_undo_absolute_t* undo )
{
  auto bof = GetBOF( txt.buf );

  undo->c = CountCharsBetween( txt.buf, bof, txt.c );
  undo->s = CountCharsBetween( txt.buf, bof, txt.s );
  undo->c_inline = txt.c_inline;
  undo->overwrite = txt.overwrite;
  undo->seltype = txt.seltype;
  undo->scroll_target_y    = CountCharsBetween( txt.buf, bof, txt.scroll_target.y );
  undo->scroll_target_frac = txt.scroll_target.frac;
  undo->scroll_start_y    = CountCharsBetween( txt.buf, bof, txt.scroll_start.y );
  undo->scroll_start_frac = txt.scroll_start.frac;
  undo->scroll_end = CountCharsBetween( txt.buf, bof, txt.scroll_end );
}

Inl void
ApplyCsUndoAbsolute( txt_t& txt, cs_undo_absolute_t& undo )
{
  auto bof = GetBOF( txt.buf );
  auto eof = GetEOF( txt.buf );

  txt.c = Min( CursorCharR( txt.buf, bof, undo.c, 0 ), eof );
  txt.s = Min( CursorCharR( txt.buf, bof, undo.s, 0 ), eof );
  txt.c_inline = undo.c_inline;
  txt.overwrite = undo.overwrite;
  txt.seltype = undo.seltype;
  txt.scroll_target.frac = undo.scroll_target_frac;
  txt.scroll_target.y = Min( CursorCharR( txt.buf, bof, undo.scroll_target_y, 0 ), eof );
  txt.scroll_start.frac = undo.scroll_start_frac;
  txt.scroll_start.y = Min( CursorCharR( txt.buf, bof, undo.scroll_start_y, 0 ), eof );
  txt.scroll_end = Min( CursorCharR( txt.buf, bof, undo.scroll_end, 0 ), eof );
}

Inl void
CsUndoFromTxt( txt_t& txt, cs_undo_t* undo )
{
  undo->c = txt.c;
  undo->s = txt.s;
  undo->c_inline = txt.c_inline;
  undo->overwrite = txt.overwrite;
  undo->seltype = txt.seltype;
  undo->scroll_target = txt.scroll_target;
  undo->scroll_start = txt.scroll_start;
  undo->scroll_end = txt.scroll_end;
}

Inl void
ApplyCsUndo( txt_t& txt, cs_undo_t& undo )
{
  auto eof = GetEOF( txt.buf );

  txt.c = Min( undo.c, eof );
  txt.s = Min( undo.s, eof );
  txt.c_inline = undo.c_inline;
  txt.overwrite = undo.overwrite;
  txt.seltype = undo.seltype;
  txt.scroll_target.frac = undo.scroll_target.frac;
  txt.scroll_target.y = Min( undo.scroll_target.y, eof );
  txt.scroll_start.frac = undo.scroll_start.frac;
  txt.scroll_start.y = Min( undo.scroll_start.y, eof );
  txt.scroll_end = Min( undo.scroll_end, eof );
}



Inl bool
SelectIsZero( txt_t& txt )
{
  return ( txt.seltype != seltype_t::s )  |  Equal( txt.c, txt.s );
}



__TxtCmd( CmdScrollD )
{
  AssertCrash( !misc2 );

  auto delta_nlines = misc;
  txt.scroll_target.y = CursorLineD( txt.buf, txt.scroll_target.y, 0, delta_nlines, 0, 0 );
}

__TxtCmd( CmdScrollU )
{
  AssertCrash( !misc2 );

  auto delta_nlines = misc;
  txt.scroll_target.y = CursorLineU( txt.buf, txt.scroll_target.y, 0, delta_nlines, 0, 0 );
}



Inl void
MakeCursorVisible( txt_t& txt )
{
  auto make_cursor_visible_radius = GetPropFromDb( f32, f32_make_cursor_visible_radius );

  auto c_ln_start = CursorStopAtNewlineL( txt.buf, txt.c, 0 );

#if USE_SIMPLE_SCROLLING
  auto top = txt.scroll_start.y;
  auto bot = CursorLineD( txt.buf, top, 0, MAX( txt.window_n_lines, 1 ) - 1, 0, 0 );
  if( Less( c_ln_start, top ) ) {
    txt.scroll_start.y = c_ln_start;
    txt.scroll_start.frac = 0;
  } elif( LEqual( bot, c_ln_start ) ) {
    auto delta = CountLinesBetween( txt.buf, bot, c_ln_start );
    txt.scroll_start.y = CursorLineD( txt.buf, txt.scroll_start.y, 0, delta + 1, 0, 0 );
    txt.scroll_start.frac = 0;
  } else {
    // no scrolling action, c already on screen.
  }
#else
  // always center on the cursor:
//  txt.scroll_target.y = c_ln_start;
//  txt.scroll_target.frac = 0;

  // We may have deleted from scroll_start to EOF, so we need to reset scroll_start so it's in-bounds.
  auto eof = GetEOF( txt.buf );
  if( Greater( txt.scroll_start.y, eof ) ) {
    txt.scroll_start.y = CursorStopAtNewlineL( txt.buf, eof, 0 );
    txt.scroll_start.frac = 0;
  }

  // We may have changed text around scroll_start, so we need to reset scroll_start to be BOL.
  txt.scroll_start.y = CursorStopAtNewlineL( txt.buf, txt.scroll_start.y, 0 );

  auto nlines = Cast( idx_t, txt.scroll_start.frac + 0.5 * txt.window_n_lines );
  auto scroll_half = CursorLineD( txt.buf, txt.scroll_start.y, 0, nlines, 0, 0 );

  idx_t half_scrollwin = Cast( idx_t, make_cursor_visible_radius * txt.window_n_lines );
  auto yl = CursorLineU( txt.buf, scroll_half, 0, half_scrollwin, 0, 0 );
  auto yr = CursorLineD( txt.buf, scroll_half, 0, half_scrollwin, 0, 0 );

  if( Less( c_ln_start, yl ) ) {
    idx_t delta_y = CountLinesBetween( txt.buf, c_ln_start, yl );
    scroll_half = CursorLineU( txt.buf, scroll_half, 0, delta_y, 0, 0 );
  } elif( Greater( c_ln_start, yr ) ) {
    idx_t delta_y = CountLinesBetween( txt.buf, yr, c_ln_start );
    scroll_half = CursorLineD( txt.buf, scroll_half, 0, delta_y, 0, 0 );
  }
  txt.scroll_target.y = scroll_half;
  txt.scroll_target.frac = 0;
#endif
}



Inl void
GetSelect( txt_t& txt, content_ptr_t* sl, content_ptr_t* sr )
{
  *sl = Min( txt.c, txt.s );
  *sr = Max( txt.c, txt.s );
}



Inl string_t
AllocSelection( txt_t& txt )
{
  AssertCrash( txt.seltype == seltype_t::s );
  content_ptr_t sl, sr;
  GetSelect( txt, &sl, &sr );
  return AllocContents( txt.buf, sl, sr );
}



struct
multisel_t
{
  content_ptr_t c_ln_start;
  content_ptr_t s_ln_start;
  idx_t c_inline; // always-in-bounds inline pos.
  idx_t s_inline; // always-in-bounds inline pos.
  content_ptr_t top_ln_start; // line start at multiselection top edge.
  content_ptr_t bot_ln_start; // line start at multiselection bot edge.
  idx_t left_inline; // inline pos of multiselection l edge.
  idx_t rght_inline; // inline pos of multiselection r edge.
};

#define __MultiselConcurrentPtrs( txt ) \
  &( ms ).c_ln_start, \
  &( ms ).s_ln_start, \
  &( ms ).top_ln_start, \
  &( ms ).bot_ln_start \



Inl void
GetMultiselect( txt_t& txt, multisel_t& ms )
{
  ms.c_ln_start = CursorStopAtNewlineL( txt.buf, txt.c, &ms.c_inline );
  ms.s_ln_start = CursorStopAtNewlineL( txt.buf, txt.s, &ms.s_inline );

  ms.top_ln_start = Min( ms.c_ln_start, ms.s_ln_start );
  ms.bot_ln_start = Max( ms.c_ln_start, ms.s_ln_start );

  // virtual c_inline if the txt.c_inline is past the end of txt.c's current line.
  idx_t c_inline = MAX( ms.c_inline, txt.c_inline );

  ms.left_inline = MIN( c_inline, ms.s_inline );
  ms.rght_inline = MAX( c_inline, ms.s_inline );
}



Inl void
AnchorSelect( txt_t& txt, content_ptr_t cursor )
{
  txt.s = cursor;
  txt.seltype = seltype_t::s;
}



Inl void
AddCsUndo( txt_t& txt )
{
  // invalidate previous future.
  // if this function is called, then something's changed, and it doesn't
  //  make sense to step forward in the UndoStack. so we clear the stack
  //  past the current time.
  txt.redos.len = 0;

  // dump current state onto the UndoStack.
  cs_undo_absolute_t state;
  CsUndoAbsoluteFromTxt( txt, &state );

  bool add = 1;
  if( txt.undos.len ) {
    auto last = txt.undos.mem + txt.undos.len - 1;
    add = !Equal( state, *last );
  }
  if( add ) {
    *AddBack( txt.undos ) = state;
  }
}



__TxtCmd( CmdCsUndo )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  if( !txt.undos.len ) {
    return;
  }

  cs_undo_absolute_t state;
  CsUndoAbsoluteFromTxt( txt, &state );
  *AddBack( txt.redos ) = state;

  cs_undo_absolute_t undo = txt.undos.mem[txt.undos.len - 1];
  RemBack( txt.undos );
  ApplyCsUndoAbsolute( txt, undo );
}

__TxtCmd( CmdCsRedo )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  if( !txt.redos.len ) {
    return;
  }

  cs_undo_absolute_t state;
  CsUndoAbsoluteFromTxt( txt, &state );
  *AddBack( txt.undos ) = state;

  cs_undo_absolute_t redo = txt.redos.mem[txt.redos.len - 1];
  RemBack( txt.redos );
  ApplyCsUndoAbsolute( txt, redo );
}



__TxtCmd( CmdToggleInsertMode )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  txt.overwrite = !txt.overwrite;
}



__TxtCmd( CmdCursorL )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      txt.c = CursorSkipCharNewlineL( txt.buf, txt.c, 0 );
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectSelectL( txt_t& txt )
{
  idx_t c_inline = GetInline( txt, txt.c );
  auto c_move = CursorCharInlineL( txt.buf, txt.c, 1, 0 );
  if( Equal( txt.c, c_move )  ||  c_inline != txt.c_inline ) {
    if( txt.c_inline ) {
      txt.c_inline -= 1;
    }
  } else {
    txt.c = c_move;
    ResetCInline( txt );
  }
}

Inl void
SelectSelectL( txt_t& txt )
{
  txt.c = CursorSkipCharNewlineL( txt.buf, txt.c, 0 );
  ResetCInline( txt );
}

__TxtCmd( CmdSelectL )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move = CursorSkipCharNewlineL( txt.buf, txt.c, 0 );
      if( !Equal( txt.c, c_move ) ) {
        AnchorSelect( txt, txt.c );
        txt.c = c_move;
        ResetCInline( txt );
      }
    } break;
    case seltype_t::s: {
      SelectSelectL( txt );
    } break;
    case seltype_t::m: {
      MultiselectSelectL( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      txt.c = CursorSkipCharNewlineR( txt.buf, txt.c, 0 );
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectSelectR( txt_t& txt )
{
  idx_t c_inline = GetInline( txt, txt.c );
  auto c_move = CursorCharInlineR( txt.buf, txt.c, 1, 0 );
  if( Equal( txt.c, c_move )  ||  c_inline != txt.c_inline ) {
    txt.c_inline += 1;
  } else {
    txt.c = c_move;
    ResetCInline( txt );
  }
}

Inl void
SelectSelectR( txt_t& txt )
{
  txt.c = CursorSkipCharNewlineR( txt.buf, txt.c, 0 );
  ResetCInline( txt );
}

__TxtCmd( CmdSelectR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move = CursorSkipCharNewlineR( txt.buf, txt.c, 0 );
      if( !Equal( txt.c, c_move ) ) {
        AnchorSelect( txt, txt.c );
        txt.c = c_move;
        ResetCInline( txt );
      }
    } break;
    case seltype_t::s: {
      SelectSelectR( txt );
    } break;
    case seltype_t::m: {
      MultiselectSelectR( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorU )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      txt.c = CursorLineU( txt.buf, txt.c, txt.c_inline, 1, 0, 0 );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdSelectU )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move = CursorLineU( txt.buf, txt.c, txt.c_inline, 1, 0, 0 );
      if( !Equal( txt.c, c_move ) ) {
        AnchorSelect( txt, txt.c );
        txt.c = c_move;
      }
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.c = CursorLineU( txt.buf, txt.c, txt.c_inline, 1, 0, 0 );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorD )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      txt.c = CursorLineD( txt.buf, txt.c, txt.c_inline, 1, 0, 0 );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdSelectD )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move = CursorLineD( txt.buf, txt.c, txt.c_inline, 1, 0, 0 );
      if( !Equal( txt.c, c_move ) ) {
        AnchorSelect( txt, txt.c );
        txt.c = c_move;
      }
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.c = CursorLineD( txt.buf, txt.c, txt.c_inline, 1, 0, 0 );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdSelectWordAtCursor )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      txt.c = CursorStopAtNonWordCharR( txt.buf, txt.c, 0 );
      txt.s = CursorStopAtNonWordCharL( txt.buf, txt.c, 0 );
      txt.seltype = seltype_t::s;
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      // TODO: implement
      ImplementCrash();
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorHome )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      txt.c = CursorHome( txt.buf, txt.c, 0 );
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectSelectHome( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );

  auto c_ln_start = Less( txt.s, txt.c )  ?  ms.bot_ln_start  :  ms.top_ln_start;
  txt.c = c_ln_start;
  txt.c_inline = 0;
}

Inl void
SelectSelectHome( txt_t& txt )
{
  txt.c = CursorHome( txt.buf, txt.c, 0 );
  ResetCInline( txt );
}

__TxtCmd( CmdSelectHome )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move = CursorHome( txt.buf, txt.c, 0 );
      if( !Equal( txt.c, c_move ) ) {
        AnchorSelect( txt, txt.c );
        txt.c = c_move;
        ResetCInline( txt );
      }
    } break;
    case seltype_t::s: {
      SelectSelectHome( txt );
    } break;
    case seltype_t::m: {
      MultiselectSelectHome( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorEnd )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      txt.c = CursorEnd( txt.buf, txt.c, 0 );
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectSelectEnd( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );

  // walk each line of ms, and find the max c_inline across all lines.
  idx_t max_inline = 0;

  idx_t count = 0;
  auto ln_start = ms.bot_ln_start;
  Forever {
    idx_t lnlen;
    auto ln_end = CursorStopAtNewlineR( txt.buf, ln_start, &lnlen );
    max_inline = MAX( max_inline, lnlen );

    if( Greater( ln_start, ms.top_ln_start ) ) {
      ln_start = CursorLineU( txt.buf, ln_start, 0, 1, 0, 0 );
      count += 1;
    } else {
      AssertCrash( Equal( ln_start, ms.top_ln_start ) );
      break;
    }
  }

  // set txt.c to line end, and txt.c_inline to the max c_inline found.
  txt.c = CursorStopAtNewlineR( txt.buf, txt.c, 0 );
  txt.c_inline = max_inline;
}

Inl void
SelectSelectEnd( txt_t& txt )
{
  txt.c = CursorEnd( txt.buf, txt.c, 0 );
  ResetCInline( txt );
}

__TxtCmd( CmdSelectEnd )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move = CursorEnd( txt.buf, txt.c, 0 );
      if( !Equal( txt.c, c_move ) ) {
        AnchorSelect( txt, txt.c );
        txt.c = c_move;
        ResetCInline( txt );
      }
    } break;
    case seltype_t::s: {
      SelectSelectEnd( txt );
    } break;
    case seltype_t::m: {
      MultiselectSelectEnd( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorFileL )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      txt.c = GetBOF( txt.buf );
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}

__TxtCmd( CmdCursorFileR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      txt.c = GetEOF( txt.buf );
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorGotoline )
{
  AssertCrash( !misc2 );

  ProfFunc();

  // PERF: very slow for big files!
  // a linecache of some kind would dramatically speed this up.

  auto nlines = misc;
  AddCsUndo( txt );
  txt.seltype = seltype_t::none;
  txt.c = CursorLineD( txt.buf, GetBOF( txt.buf ), 0, nlines, 0, 0 );
  MakeCursorVisible( txt );
}



__TxtCmd( CmdSetSelection )
{
  AssertCrash( misc );
  AssertCrash( misc2 );

  auto posl = *Cast( content_ptr_t*, misc );
  auto posr = *Cast( content_ptr_t*, misc2 );

  auto c = Max( posl, posr );
  auto s = Min( posl, posr );
  AddCsUndo( txt );
  txt.seltype = seltype_t::s;
  txt.c = Min( c, GetEOF( txt.buf ) );
  txt.s = Min( s, GetEOF( txt.buf ) );
  MakeCursorVisible( txt );
}


__TxtCmd( CmdCursorJumpD )
{
  AssertCrash( !misc2 );

  auto nlines = misc;
  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      txt.c = CursorLineD( txt.buf, txt.c, txt.c_inline, nlines, 0, 0 );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdSelectJumpD )
{
  AssertCrash( !misc2 );

  auto nlines = misc;
  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move = CursorLineD( txt.buf, txt.c, txt.c_inline, nlines, 0, 0 );
      if( !Equal( txt.c, c_move ) ) {
        AnchorSelect( txt, txt.c );
        txt.c = c_move;
      }
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.c = CursorLineD( txt.buf, txt.c, txt.c_inline, nlines, 0, 0 );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorJumpU )
{
  AssertCrash( !misc2 );

  auto nlines = misc;
  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      txt.c = CursorLineU( txt.buf, txt.c, txt.c_inline, nlines, 0, 0 );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdSelectJumpU )
{
  AssertCrash( !misc2 );

  auto nlines = misc;
  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move = CursorLineU( txt.buf, txt.c, txt.c_inline, nlines, 0, 0 );
      if( !Equal( txt.c, c_move ) ) {
        AnchorSelect( txt, txt.c );
        txt.c = c_move;
      }
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.c = CursorLineU( txt.buf, txt.c, txt.c_inline, nlines, 0, 0 );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorSkipL )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      txt.c = CursorSkipWordSpacetabNewlineL( txt.buf, txt.c, 0 );
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdSelectSkipL )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move = CursorSkipWordSpacetabNewlineL( txt.buf, txt.c, 0 );
      if( !Equal( txt.c, c_move ) ) {
        AnchorSelect( txt, txt.c );
        txt.c = c_move;
        ResetCInline( txt );
      }
    } break;
    case seltype_t::s: {
      txt.c = CursorSkipWordSpacetabNewlineL( txt.buf, txt.c, 0 );
      ResetCInline( txt );
    } break;
    case seltype_t::m: {
      MultiselectSelectL( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorSkipR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      txt.c = CursorSkipWordSpacetabNewlineR( txt.buf, txt.c, 0 );
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdSelectSkipR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move = CursorSkipWordSpacetabNewlineR( txt.buf, txt.c, 0 );
      if( !Equal( txt.c, c_move ) ) {
        AnchorSelect( txt, txt.c );
        txt.c = c_move;
        ResetCInline( txt );
      }
    } break;
    case seltype_t::s: {
      txt.c = CursorSkipWordSpacetabNewlineR( txt.buf, txt.c, 0 );
      ResetCInline( txt );
    } break;
    case seltype_t::m: {
      MultiselectSelectR( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdSelectAll )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  txt.c = GetBOF( txt.buf );
  txt.s = GetEOF( txt.buf );
  ResetCInline( txt );
  txt.seltype = seltype_t::s;
}



__TxtCmd( CmdCursorMakePresent )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  txt.c = txt.scroll_start.y;
  auto nlines = txt.window_n_lines / 2;
  txt.c = CursorLineD( txt.buf, txt.c, txt.c_inline, nlines, 0, 0 );
  ResetCInline( txt );
}



__TxtCmd( CmdMultiCursorU )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      ResetCInline( txt ); // we don't want standard c_inline behavior for this Line move.
      txt.s = txt.c;
      txt.seltype = seltype_t::m;
    } break;
    case seltype_t::s: {
      ResetCInline( txt ); // we don't want standard c_inline behavior for this Line move.
      txt.seltype = seltype_t::m;
    } break;
    case seltype_t::m: {
    } break;
    default: UnreachableCrash();
  }
  txt.c = CursorLineU( txt.buf, txt.c, txt.c_inline, 1, 0, 0 );

  // TODO: should we turn single-line multiselects into standard selects?
  //   definitely not for when we have txt.c_inline > eol.

  MakeCursorVisible( txt );
}

__TxtCmd( CmdMultiCursorD )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      ResetCInline( txt ); // we don't want standard c_inline behavior for this Line move.
      txt.s = txt.c;
      txt.seltype = seltype_t::m;
    } break;
    case seltype_t::s: {
      ResetCInline( txt ); // we don't want standard c_inline behavior for this Line move.
      txt.seltype = seltype_t::m;
    } break;
    case seltype_t::m: {
    } break;
    default: UnreachableCrash();
  }
  txt.c = CursorLineD( txt.buf, txt.c, txt.c_inline, 1, 0, 0 );

  // TODO: should we turn single-line multiselects into standard selects?
  //   definitely not for when we have txt.c_inline > eol.

  MakeCursorVisible( txt );
}





// =================================================================================
// CONTENT EDITING
//

__TxtCmd( CmdWipeHistory )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  txt.undos.len = 0;
  txt.redos.len = 0;
  txt.undos_txtcs.len = 0;
  txt.redos_txtcs.len = 0;
  WipeHistories( txt.buf );
}

Inl void
AddTxtUndo( txt_t& txt )
{
  // let buf_t add an internal checkpt so it can unwind enough times.
  UndoCheckpt( txt.buf );

  // invalidate previous futures.
  txt.redos_txtcs.len = 0;

  cs_undo_t state;
  CsUndoFromTxt( txt, &state );
  *AddBack( txt.undos_txtcs ) = state;
}


Inl void
MultiselectDelete( txt_t& txt, multisel_t& ms )
{
  AssertCrash( ms.left_inline != ms.rght_inline );

  auto ln_start = ms.bot_ln_start;
  Forever {
    // the selection range on the given line ln_start.
    auto ml = CursorCharInlineR( txt.buf, ln_start, ms.left_inline, 0 );
    auto mr = CursorCharInlineR( txt.buf, ln_start, ms.rght_inline, 0 );

    content_ptr_t* concurrents[] = {
      &ln_start,
      __MultiselConcurrentPtrs( ms ),
      __TxtConcurrentPtrs( txt )
    };
    Delete( txt.buf, ml, mr, AL( concurrents ) );

    if( Greater( ln_start, ms.top_ln_start ) ) {
      ln_start = CursorLineU( txt.buf, ln_start, 0, 1, 0, 0 );
    } else {
      AssertCrash( Equal( ln_start, ms.top_ln_start ) );
      break;
    }
  }

  txt.c_inline = ms.left_inline;
}


Inl void
SelectDelete( txt_t& txt )
{
  content_ptr_t sl, sr;
  GetSelect( txt, &sl, &sr );

  content_ptr_t* concurrents[] = {
    __TxtConcurrentPtrs( txt )
  };
  Delete( txt.buf, sl, sr, AL( concurrents ) );

  txt.seltype = seltype_t::none;
  ResetCInline( txt );
}



Inl void
AddChar( txt_t& txt, u8 c )
{
  content_ptr_t* concurrents[] = {
    __TxtConcurrentPtrs( txt )
  };
  if( txt.overwrite ) {
    auto ln_end = CursorStopAtNewlineR( txt.buf, txt.c, 0 );
    if( !Equal( txt.c, ln_end ) ) {
      auto repl_start = txt.c;
      auto repl_end = CursorCharR( txt.buf, txt.c, 1, 0 );
      Replace( txt.buf, repl_start, repl_end, &c, 1, AL( concurrents ) );
    } else {
      Insert( txt.buf, txt.c, &c, 1, AL( concurrents ) );
    }
  } else {
    Insert( txt.buf, txt.c, &c, 1, AL( concurrents ) );
  }
  ResetCInline( txt );
}

Inl void
SelectAddString( txt_t& txt, u8* str, idx_t str_len )
{
  if( txt.overwrite ) {
    SelectDelete( txt );
  } else {
    SelectDelete( txt );
    if( str_len ) {
      content_ptr_t* concurrents[] = {
        __TxtConcurrentPtrs( txt )
      };
      Insert( txt.buf, txt.c, str, str_len, AL( concurrents ) );
      ResetCInline( txt );
    }
  }
}

Inl void
MultiselectAddString( txt_t& txt, u8* str, idx_t str_len )
{
  multisel_t ms;
  GetMultiselect( txt, ms );

  if( txt.overwrite ) {
    if( ms.left_inline != ms.rght_inline ) {
      MultiselectDelete( txt, ms );
      return;

    } else {
      ms.rght_inline += str_len;
      MultiselectDelete( txt, ms );
      // txt.c/c_inline has probably changed, so ms.left_inline/rght_inline will be different!
      // so, re-get the ms so MultiselectAddChar can work!
      GetMultiselect( txt, ms );
    }
  } else {
    if( ms.left_inline != ms.rght_inline ) {
      MultiselectDelete( txt, ms );
      // txt.c/c_inline has probably changed, so ms.left_inline/rght_inline will be different!
      // so, re-get the ms so MultiselectAddChar can work!
      GetMultiselect( txt, ms );
    }

    AssertCrash( ms.left_inline == ms.rght_inline );
  }

  if( !str_len ) {
    return;
  }

  auto ln_start = ms.bot_ln_start;
  Forever {
    auto ln_end = CursorStopAtNewlineR( txt.buf, ln_start, 0 );

    idx_t ninline;
    auto pos = CursorCharInlineR( txt.buf, ln_start, ms.left_inline, &ninline );
    content_ptr_t* concurrents[] = {
      &pos,
      &ln_start,
      &ln_end,
      __MultiselConcurrentPtrs( ms ),
      __TxtConcurrentPtrs( txt )
    };
    if( ninline < ms.left_inline ) {
      auto nspaces = ms.left_inline - ninline;
      while( nspaces-- ) {
        Insert(
          txt.buf,
          ln_end,
          Str( " " ),
          1,
          AL( concurrents )
          );
      }
    }
    AssertCrash( LEqual( pos, ln_end ) );

    Insert( txt.buf, pos, str, str_len, AL( concurrents ) );

    if( Greater( ln_start, ms.top_ln_start ) ) {
      ln_start = CursorLineU( txt.buf, ln_start, 0, 1, 0, 0 );
    } else {
      AssertCrash( Equal( ln_start, ms.top_ln_start ) );
      break;
    }
  }

  ResetCInline( txt );
}

// TODO: replace AddChar with this?
Inl void
AddString( txt_t& txt, u8* str, idx_t str_len )
{
  if( !str_len ) {
    return;
  }

  content_ptr_t* concurrents[] = {
    __TxtConcurrentPtrs( txt )
  };
  if( txt.overwrite ) {
    idx_t nmoved;
    auto ln_end = CursorStopAtNewlineR( txt.buf, txt.c, &nmoved );
    auto nreplace = MIN( str_len, nmoved );
    auto ninsert = str_len - nreplace;
    auto repl_start = txt.c;
    auto repl_end = CursorCharR( txt.buf, txt.c, nreplace, 0 );
    Replace( txt.buf, repl_start, repl_end, str, nreplace, AL( concurrents ) );
    Insert( txt.buf, txt.c, str + nreplace, ninsert, AL( concurrents ) );
  } else {
    Insert( txt.buf, txt.c, str, str_len, AL( concurrents ) );
  }
  ResetCInline( txt );
}


__TxtCmd( CmdAddChar )
{
  AssertCrash( !misc2 );

  auto c = Cast( u8, misc );
  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      AddChar( txt, c );
    } break;
    case seltype_t::s: {
      SelectAddString( txt, &c, 1 );
    } break;
    case seltype_t::m: {
      MultiselectAddString( txt, &c, 1 );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}

__TxtCmd( CmdAddAlpha )
{
  auto c = Cast( u8, misc );
  auto caps = ( misc2 != 0 );
  c = caps ? CsToUpper( c ) : CsToLower( c );
  CmdAddChar( txt, c );
}



__TxtCmd( CmdAddString )
{
  auto str = Cast( u8*, misc );
  auto str_len = Cast( idx_t, misc2 );
  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      AddString( txt, str, str_len );
    } break;
    case seltype_t::s: {
      SelectAddString( txt, str, str_len );
    } break;
    case seltype_t::m: {
      MultiselectAddString( txt, str, str_len );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectTabR( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );

  auto ln_start = ms.bot_ln_start;
  Forever {
    content_ptr_t* concurrents[] = {
      &ln_start,
      __MultiselConcurrentPtrs( ms ),
      __TxtConcurrentPtrs( txt )
    };
    if( txt.insert_spaces_for_tabs ) {
      auto nspaces = txt.spaces_per_tab;
      while( nspaces-- ) {
        Insert( txt.buf, ln_start, Str( " " ), 1, AL( concurrents ) );
      }
    } else {
      Insert( txt.buf, ln_start, Str( "\t" ), 1, AL( concurrents ) );
    }

    if( Greater( ln_start, ms.top_ln_start ) ) {
      ln_start = CursorLineU( txt.buf, ln_start, 0, 1, 0, 0 );
    } else {
      AssertCrash( Equal( ln_start, ms.top_ln_start ) );
      break;
    }
  }

  idx_t ninc = ( txt.insert_spaces_for_tabs )  ?  txt.spaces_per_tab  :  1;
  txt.c_inline += ninc;
}

Inl void
TabR( txt_t& txt )
{
  content_ptr_t* concurrents[] = {
    __TxtConcurrentPtrs( txt )
  };
  if( txt.insert_spaces_for_tabs ) {
    Fori( u8, i, 0, txt.spaces_per_tab ) {
      Insert( txt.buf, txt.c, Str( " " ), 1, AL( concurrents ) );
    }
  } else {
    Insert( txt.buf, txt.c, Str( "\t" ), 1, AL( concurrents ) );
  }
  ResetCInline( txt );
}

__TxtCmd( CmdTabR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      TabR( txt );
    } break;
    case seltype_t::s: // defer to multiselect implementation. this works because c, s are the same across sel, multisel!
    case seltype_t::m: {
      MultiselectTabR( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl bool
IsAllSpaces( buf_t& buf, content_ptr_t start, content_ptr_t end )
{
  auto tmp = AllocContents( buf, start, end ); // PERF: unnecessary copying.
  For( i, 0, tmp.len ) {
    if( tmp.mem[i] != ' ' ) {
      return 0;
    }
  }
  Free( tmp );
  return 1;
}

Inl bool
EveryNonEmptyMultiselLineIsLeadingAllSpaces( txt_t& txt, multisel_t& ms )
{
  auto ln_start = ms.bot_ln_start;
  Forever {
    auto spaces_end = CursorCharInlineR( txt.buf, ln_start, txt.spaces_per_tab, 0 );
    bool all_spaces = IsAllSpaces( txt.buf, ln_start, spaces_end );
    if( !all_spaces ) {
      return 0;
    }

    if( Greater( ln_start, ms.top_ln_start ) ) {
      ln_start = CursorLineU( txt.buf, ln_start, 0, 1, 0, 0 );
    } else {
      AssertCrash( Equal( ln_start, ms.top_ln_start ) );
      break;
    }
  }
  return 1;
}

Inl bool
EveryNonEmptyMultiselLineIsLeadingOneTab( txt_t& txt, multisel_t& ms )
{
  auto ln_start = ms.bot_ln_start;
  Forever {
    auto ln_end = CursorStopAtNewlineR( txt.buf, ln_start, 0 );

    if( Less( ln_start, ln_end ) ) {
      u8 c;
      Contents( txt.buf, ln_start, &c, 1 );
      if( c != '\t' ) {
        return 0;
      }
    }

    if( Greater( ln_start, ms.top_ln_start ) ) {
      ln_start = CursorLineU( txt.buf, ln_start, 0, 1, 0, 0 );
    } else {
      AssertCrash( Equal( ln_start, ms.top_ln_start ) );
      break;
    }
  }
  return 1;
}

Inl void
MultiselectTabL( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );

  // TODO: implement mixed tabs/spaces.
  bool all_spaces = EveryNonEmptyMultiselLineIsLeadingAllSpaces( txt, ms );
  bool all_tab = EveryNonEmptyMultiselLineIsLeadingOneTab( txt, ms );

  if( all_spaces  ||  all_tab ) {
    auto ln_start = ms.bot_ln_start;
    Forever {
      content_ptr_t* concurrents[] = {
        &ln_start,
        __MultiselConcurrentPtrs( ms ),
        __TxtConcurrentPtrs( txt )
      };

      if( all_spaces ) {
        auto del_start = ln_start;
        auto del_end = CursorCharInlineR( txt.buf, ln_start, txt.spaces_per_tab, 0 );
        Delete( txt.buf, del_start, del_end, AL( concurrents ) );
      } elif( all_tab ) {
        auto del_start = ln_start;
        auto del_end = CursorCharInlineR( txt.buf, ln_start, 1, 0 );
        Delete( txt.buf, del_start, del_end, AL( concurrents ) );
      }

      if( Greater( ln_start, ms.top_ln_start ) ) {
        ln_start = CursorLineU( txt.buf, ln_start, 0, 1, 0, 0 );
      } else {
        AssertCrash( Equal( ln_start, ms.top_ln_start ) );
        break;
      }
    }
  }

  if( all_spaces ) {
    idx_t ninc = txt.spaces_per_tab;
    txt.c_inline = ( txt.c_inline < ninc )  ?  0  :  ( txt.c_inline - ninc );

  } elif( all_tab ) {
    idx_t ninc = 1;
    txt.c_inline = ( txt.c_inline < ninc )  ?  0  :  ( txt.c_inline - ninc );
  }
}

Inl void
TabL( txt_t& txt )
{
  if( !TxtLen( txt ) ) {
    return;
  }

  auto ln_start = CursorStopAtNewlineL( txt.buf, txt.c, 0 );

  content_ptr_t* concurrents[] = {
    &ln_start,
    __TxtConcurrentPtrs( txt )
  };

  u8 first;
  Contents( txt.buf, ln_start, &first, 1 );
  if( first == '\t' ) {
    auto del_start = ln_start;
    auto del_end = CursorCharR( txt.buf, del_start, 1, 0 );
    Delete( txt.buf, del_start, del_end, AL( concurrents ) );
  } elif( first == ' ' ) {
    auto spaces_start = ln_start;
    auto spaces_end = CursorCharR( txt.buf, spaces_start, txt.spaces_per_tab, 0 );
    bool all_spaces = IsAllSpaces( txt.buf, spaces_start, spaces_end );
    if( all_spaces ) {
      Delete( txt.buf, spaces_start, spaces_end, AL( concurrents ) );
    }
  }
  // if first wasn't space or tab, then no-op.
}

__TxtCmd( CmdTabL )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      TabL( txt );
    } break;
    case seltype_t::s: // defer to multiselect implementation. this works because c, s are the same across sel, multisel!
    case seltype_t::m: {
      MultiselectTabL( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



#define __TCountMultiselFn( name ) \
  content_ptr_t \
  ( name )( \
    buf_t& buf, \
    content_ptr_t pos, \
    idx_t* nchars_moved \
    ) \

typedef __TCountMultiselFn( *pfn_tcountmultisel_t );

Templ Inl bool
GetTCountAcrossAllNonEmptyMultiselLines( txt_t& txt, multisel_t& ms, idx_t* nchars, T fn )
{
  bool min_valid = 0;
  idx_t min_nchars = 0;

  auto ln_start = ms.bot_ln_start;
  Forever {
    // the selection range on the given line ln_start.
    idx_t ninline;
    auto ml = CursorCharInlineR( txt.buf, ln_start, ms.left_inline, &ninline );
    idx_t ln_len;
    auto ln_end = CursorStopAtNewlineR( txt.buf, ln_start, &ln_len );
    // skip lines that aren't long enough to reach ms.left_inline
    if( ln_len  &&  ninline == ms.left_inline ) {
      idx_t nmoved;
      fn( txt.buf, ml, &nmoved );
      if( !min_valid ) {
        min_valid = 1;
        min_nchars = nmoved;
      } else {
        min_nchars = MIN( min_nchars, nmoved );
        if( !min_nchars ) {
          return 0;
        }
      }
    }

    if( Greater( ln_start, ms.top_ln_start ) ) {
      ln_start = CursorLineU( txt.buf, ln_start, 0, 1, 0, 0 );
    } else {
      AssertCrash( Equal( ln_start, ms.top_ln_start ) );
      break;
    }
  }

  *nchars = min_nchars;
  return 1;
}

Inl bool
GetNumSpacetabsAcrossAllNonEmptyMultiselLinesL( txt_t& txt, multisel_t& ms, idx_t* nchars )
{
  return GetTCountAcrossAllNonEmptyMultiselLines<pfn_tcountmultisel_t>( txt, ms, nchars, CursorSkipSpacetabL );
}

Inl bool
GetNumSpacetabsAcrossAllNonEmptyMultiselLinesR( txt_t& txt, multisel_t& ms, idx_t* nchars )
{
  return GetTCountAcrossAllNonEmptyMultiselLines<pfn_tcountmultisel_t>( txt, ms, nchars, CursorSkipSpacetabR );
}

Inl bool
GetNumWordCharsAcrossAllNonEmptyMultiselLinesL( txt_t& txt, multisel_t& ms, idx_t* nchars )
{
  return GetTCountAcrossAllNonEmptyMultiselLines<pfn_tcountmultisel_t>( txt, ms, nchars, CursorStopAtNonWordCharL );
}

Inl bool
GetNumWordCharsAcrossAllNonEmptyMultiselLinesR( txt_t& txt, multisel_t& ms, idx_t* nchars )
{
  return GetTCountAcrossAllNonEmptyMultiselLines<pfn_tcountmultisel_t>( txt, ms, nchars, CursorStopAtNonWordCharR );
}

Inl void
MultiselectRemChL( txt_t& txt, multisel_t& ms, idx_t len )
{
  AssertCrash( ms.left_inline == ms.rght_inline );
  if( !ms.left_inline ) {
    return;
  }

  auto ln_start = ms.bot_ln_start;
  Forever {
    // the selection range on the given line ln_start.
    idx_t ninline;
    auto ml = CursorCharInlineR( txt.buf, ln_start, ms.left_inline, &ninline );
    // skip lines that aren't long enough to reach ms.left_inline
    if( ninline == ms.left_inline ) {
      content_ptr_t* concurrents[] = {
        &ln_start,
        __MultiselConcurrentPtrs( ms ),
        __TxtConcurrentPtrs( txt )
      };
      auto del_start = CursorCharInlineL( txt.buf, ml, len, 0 );
      auto del_end = ml;
      Delete( txt.buf, del_start, del_end, AL( concurrents ) );
    }

    if( Greater( ln_start, ms.top_ln_start ) ) {
      ln_start = CursorLineU( txt.buf, ln_start, 0, 1, 0, 0 );
    } else {
      AssertCrash( Equal( ln_start, ms.top_ln_start ) );
      break;
    }
  }

  AssertCrash( len <= txt.c_inline );
  txt.c_inline -= len;
}

Inl void
MultiselectRemWordL( txt_t& txt, multisel_t& ms )
{
  AssertCrash( ms.left_inline == ms.rght_inline );
  if( !ms.left_inline ) {
    return;
  }

  idx_t nwordchars;
  auto all_wordchars = GetNumWordCharsAcrossAllNonEmptyMultiselLinesL( txt, ms, &nwordchars );
  idx_t nspacetabs;
  auto all_spacetabs = GetNumSpacetabsAcrossAllNonEmptyMultiselLinesL( txt, ms, &nspacetabs );

  idx_t nrem;
  if( all_wordchars ) {
    nrem = nwordchars;
  } elif( all_spacetabs ) {
    nrem = nspacetabs;
  } else {
    nrem = 1;
  }
  MultiselectRemChL( txt, ms, nrem );
}

__TxtCmd( CmdRemChL )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      content_ptr_t* concurrents[] = {
        __TxtConcurrentPtrs( txt )
      };
      auto prev = CursorSkipCharNewlineL( txt.buf, txt.c, 0 );
      Delete( txt.buf, prev, txt.c, AL( concurrents ) );
      ResetCInline( txt );
    } break;
    case seltype_t::s: {
      SelectDelete( txt );
    } break;
    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      if( ms.left_inline != ms.rght_inline ) {
        MultiselectDelete( txt, ms );
      } else {
        MultiselectRemChL( txt, ms, 1 );
      }
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectRemChR( txt_t& txt, multisel_t& ms, idx_t len )
{
  AssertCrash( ms.left_inline == ms.rght_inline );

  auto ln_start = ms.bot_ln_start;
  Forever {
    // the selection range on the given line ln_start.
    idx_t ninline;
    auto ml = CursorCharInlineR( txt.buf, ln_start, ms.left_inline, &ninline );
    // skip lines that aren't long enough to reach ms.left_inline
    if( ninline == ms.left_inline ) {
      content_ptr_t* concurrents[] = {
        &ln_start,
        __MultiselConcurrentPtrs( ms ),
        __TxtConcurrentPtrs( txt )
      };
      auto del_start = ml;
      auto del_end = CursorCharInlineR( txt.buf, del_start, len, 0 );
      Delete( txt.buf, del_start, del_end, AL( concurrents ) );
    }

    if( Greater( ln_start, ms.top_ln_start ) ) {
      ln_start = CursorLineU( txt.buf, ln_start, 0, 1, 0, 0 );
    } else {
      AssertCrash( Equal( ln_start, ms.top_ln_start ) );
      break;
    }
  }
}

Inl void
MultiselectRemWordR( txt_t& txt, multisel_t& ms )
{
  AssertCrash( ms.left_inline == ms.rght_inline );

  idx_t nwordchars;
  auto all_wordchars = GetNumWordCharsAcrossAllNonEmptyMultiselLinesR( txt, ms, &nwordchars );
  idx_t nspacetabs;
  auto all_spacetabs = GetNumSpacetabsAcrossAllNonEmptyMultiselLinesR( txt, ms, &nspacetabs );

  idx_t nrem;
  if( all_wordchars ) {
    nrem = nwordchars;
  } elif( all_spacetabs ) {
    nrem = nspacetabs;
  } else {
    nrem = 1;
  }
  MultiselectRemChR( txt, ms, nrem );
}

__TxtCmd( CmdRemChR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      content_ptr_t* concurrents[] = {
        __TxtConcurrentPtrs( txt )
      };
      auto next = CursorSkipCharNewlineR( txt.buf, txt.c, 0 );
      Delete( txt.buf, txt.c, next, AL( concurrents ) );
    } break;
    case seltype_t::s: {
      SelectDelete( txt );
    } break;
    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      if( ms.left_inline != ms.rght_inline ) {
        MultiselectDelete( txt, ms );
      } else {
        MultiselectRemChR( txt, ms, 1 );
      }
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdRemWordL )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      content_ptr_t* concurrents[] = {
        __TxtConcurrentPtrs( txt )
      };
      auto prev = CursorSkipWordSpacetabNewlineL( txt.buf, txt.c, 0 );
      Delete( txt.buf, prev, txt.c, AL( concurrents ) );
      ResetCInline( txt );
    } break;
    case seltype_t::s: {
      SelectDelete( txt );
    } break;
    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      if( ms.left_inline != ms.rght_inline ) {
        MultiselectDelete( txt, ms );
      } else {
        MultiselectRemWordL( txt, ms );
      }
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdRemWordR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      content_ptr_t* concurrents[] = {
        __TxtConcurrentPtrs( txt )
      };
      auto next = CursorSkipWordSpacetabNewlineR( txt.buf, txt.c, 0 );
      Delete( txt.buf, txt.c, next, AL( concurrents ) );
    } break;
    case seltype_t::s: {
      SelectDelete( txt );
    } break;
    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      if( ms.left_inline != ms.rght_inline ) {
        MultiselectDelete( txt, ms );
      } else {
        MultiselectRemWordR( txt, ms );
      }
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectRemLineR( txt_t& txt, multisel_t& ms )
{
  AssertCrash( ms.left_inline == ms.rght_inline );

  auto ln_start = ms.bot_ln_start;
  Forever {
    // the selection range on the given line ln_start.
    idx_t ninline;
    auto ml = CursorCharInlineR( txt.buf, ln_start, ms.left_inline, &ninline );
    // skip lines that aren't long enough to reach ms.left_inline
    if( ninline == ms.left_inline ) {
      content_ptr_t* concurrents[] = {
        &ln_start,
        __MultiselConcurrentPtrs( ms ),
        __TxtConcurrentPtrs( txt )
      };
      auto del_start = ml;
      auto del_end = CursorStopAtNewlineR( txt.buf, del_start, 0 );
      Delete( txt.buf, del_start, del_end, AL( concurrents ) );
    }

    if( Greater( ln_start, ms.top_ln_start ) ) {
      ln_start = CursorLineU( txt.buf, ln_start, 0, 1, 0, 0 );
    } else {
      AssertCrash( Equal( ln_start, ms.top_ln_start ) );
      break;
    }
  }
}

__TxtCmd( CmdRemLineR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      content_ptr_t* concurrents[] = {
        __TxtConcurrentPtrs( txt )
      };
      auto next = CursorStopAtNewlineR( txt.buf, txt.c, 0 );
      Delete( txt.buf, txt.c, next, AL( concurrents ) );
    } break;
    case seltype_t::s: {
      SelectDelete( txt );
    } break;
    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      if( ms.left_inline != ms.rght_inline ) {
        MultiselectDelete( txt, ms );
      } else {
        MultiselectRemLineR( txt, ms );
      }
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdAddLn )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto ln_start = CursorStopAtNewlineL( txt.buf, txt.c, 0 );
      content_ptr_t* concurrents[] = {
        &ln_start,
        __TxtConcurrentPtrs( txt )
      };
      Insert(
        txt.buf,
        txt.c,
        Str( "\r\n" ),
        2,
        AL( concurrents )
        );
      // ln_indent is an end-ptr, so we have to determine its position AFTER the insert.
      // this is so we only copy the leading spacetabs, and not the newly-added newline.
      auto ln_indent = CursorSkipSpacetabR( txt.buf, ln_start, 0 );
      Copy(
        txt.buf,
        ln_start,
        ln_indent,
        txt.c,
        AL( concurrents )
        );
      ResetCInline( txt );
    } break;
    case seltype_t::s: {
      SelectDelete( txt );
    } break;
    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      if( ms.left_inline != ms.rght_inline ) {
        MultiselectDelete( txt, ms );
      }
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectRemLn( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );

  auto ln_start = ms.bot_ln_start;
  Forever {
    auto ln_end = CursorStopAtNewlineR( txt.buf, ln_start, 0 );

    content_ptr_t* concurrents[] = {
      &ln_start,
      &ln_end,
      __MultiselConcurrentPtrs( ms ),
      __TxtConcurrentPtrs( txt )
    };
    auto y_next_start = CursorSingleNewlineR( txt.buf, ln_end, 0 );
    Delete( txt.buf, ln_start, y_next_start, AL( concurrents ) );

    if( Greater( ln_start, ms.top_ln_start ) ) {
      ln_start = CursorLineU( txt.buf, ln_start, 0, 1, 0, 0 );
    } else {
      AssertCrash( Equal( ln_start, ms.top_ln_start ) );
      break;
    }
  }

  txt.seltype = seltype_t::none;

  idx_t yl_len;
  auto yl_end = CursorStopAtNewlineR( txt.buf, ms.top_ln_start, &yl_len );
  if( ms.left_inline <= yl_len ) {
    txt.c = CursorCharR( txt.buf, ms.top_ln_start, ms.c_inline, 0 );
  } else {
    txt.c = yl_end;
  }

  txt.c_inline = ms.left_inline;
}

Inl void
RemLn( txt_t& txt )
{
  auto ln0_start = CursorStopAtNewlineL( txt.buf, txt.c, 0 );

  {
    content_ptr_t* concurrents[] = {
      &ln0_start,
      __TxtConcurrentPtrs( txt )
    };
    auto ln0_end = CursorStopAtNewlineR( txt.buf, txt.c, 0 );
    auto ln1_start = CursorSingleNewlineR( txt.buf, ln0_end, 0 );
    Delete( txt.buf, ln0_start, ln1_start, AL( concurrents ) );
  }

  idx_t ln0_len;
  auto ln0_end = CursorStopAtNewlineR( txt.buf, ln0_start, &ln0_len );
  if( txt.c_inline <= ln0_len ) {
    txt.c = CursorCharR( txt.buf, ln0_start, txt.c_inline, 0 );
  } else {
    txt.c = ln0_end;
  }
}

__TxtCmd( CmdRemLn )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      RemLn( txt );
    } break;
    case seltype_t::s: // defer to multiselect implementation. this works because c, s are the same across sel, multisel!
    case seltype_t::m: {
      MultiselectRemLn( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectCommentElseUncomment( txt_t& txt, bool comment )
{
  multisel_t ms;
  GetMultiselect( txt, ms );

  auto ln_start = ms.bot_ln_start;
  Forever {
    content_ptr_t* concurrents[] = {
      &ln_start,
      __MultiselConcurrentPtrs( ms ),
      __TxtConcurrentPtrs( txt )
    };
    if( comment ) {
      Insert( txt.buf, ln_start, Str( "//" ), 2, AL( concurrents ) );
    } else {
      auto del_start = ln_start;
      auto del_end = CursorCharInlineR( txt.buf, del_start, 2, 0 );
      Delete( txt.buf, del_start, del_end, AL( concurrents ) );
    }

    if( Greater( ln_start, ms.top_ln_start ) ) {
      ln_start = CursorLineU( txt.buf, ln_start, 0, 1, 0, 0 );
    } else {
      AssertCrash( Equal( ln_start, ms.top_ln_start ) );
      break;
    }
  }

  ResetCInline( txt );
}

Inl void
Comment( txt_t& txt )
{
  content_ptr_t* concurrents[] = {
    __TxtConcurrentPtrs( txt )
  };
  auto ln_start = CursorStopAtNewlineL( txt.buf, txt.c, 0 );
  Insert( txt.buf, ln_start, Str( "//" ), 2, AL( concurrents ) );
  txt.c_inline += 2;
}

__TxtCmd( CmdComment )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      Comment( txt );
    } break;
    case seltype_t::s: // defer to multiselect implementation. this works because c, s are the same across sel, multisel!
    case seltype_t::m: {
      MultiselectCommentElseUncomment( txt, 1 );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl bool
MultiselectIsAllCommentLines( txt_t& txt, multisel_t& ms )
{
  auto ln_start = ms.bot_ln_start;
  Forever {
    auto slash_start = ln_start;
    auto slash_end = CursorCharR( txt.buf, ln_start, 2, 0 );
    u8 tmp[2];
    auto tmp_len = Contents( txt.buf, slash_start, slash_end, AL( tmp ) );
    bool is_comment = MemEqual( tmp, tmp_len, "//", 2 );
    if( !is_comment ) {
      return 0;
    }

    if( Greater( ln_start, ms.top_ln_start ) ) {
      ln_start = CursorLineU( txt.buf, ln_start, 0, 1, 0, 0 );
    } else {
      AssertCrash( Equal( ln_start, ms.top_ln_start ) );
      break;
    }
  }

  return 1;
}


Inl void
MultiselectUncomment( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );
  bool all_comments = MultiselectIsAllCommentLines( txt, ms );
  if( all_comments ) {
    MultiselectCommentElseUncomment( txt, 0 );
  }
}

Inl void
Uncomment( txt_t& txt )
{
  auto ln_start = CursorStopAtNewlineL( txt.buf, txt.c, 0 );
  auto ln_end = CursorStopAtNewlineR( txt.buf, txt.c, 0 );
  auto slash_end = CursorCharR( txt.buf, ln_start, 2, 0 );
  auto tmp = AllocContents( txt.buf, ln_start, slash_end );
  content_ptr_t* concurrents[] = {
    &ln_start,
    &ln_end,
    &slash_end,
    __TxtConcurrentPtrs( txt )
  };
  bool is_comment = MemEqual( ML( tmp ), "//", 2 );
  if( is_comment ) {
    auto del_start = ln_start;
    auto del_end = slash_end;
    Delete( txt.buf, del_start, del_end, AL( concurrents ) );
    txt.c_inline = MAX( txt.c_inline, 2 ) - 2;
  }
  Free( tmp );
}

__TxtCmd( CmdUncomment )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      Uncomment( txt );
    } break;
    case seltype_t::s: // defer to multiselect implementation. this works because c, s are the same across sel, multisel!
    case seltype_t::m: {
      MultiselectUncomment( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}


Inl void
MultiselectToggleComment( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );

  bool all_comments = MultiselectIsAllCommentLines( txt, ms );
  MultiselectCommentElseUncomment( txt, !all_comments );
}

Inl void
ToggleComment( txt_t& txt )
{
  auto ln_start = CursorStopAtNewlineL( txt.buf, txt.c, 0 );
  auto ln_end = CursorStopAtNewlineR( txt.buf, txt.c, 0 );
  auto slash_end = CursorCharR( txt.buf, ln_start, 2, 0 );
  auto tmp = AllocContents( txt.buf, ln_start, slash_end );
  content_ptr_t* concurrents[] = {
    &ln_start,
    &ln_end,
    &slash_end,
    __TxtConcurrentPtrs( txt )
  };
  bool is_comment = MemEqual( ML( tmp ), "//", 2 );
  if( is_comment ) {
    auto del_start = ln_start;
    auto del_end = slash_end;
    Delete( txt.buf, del_start, del_end, AL( concurrents ) );
    txt.c_inline = MAX( txt.c_inline, 2 ) - 2;
  } else {
    Insert( txt.buf, ln_start, Str( "//" ), 2, AL( concurrents ) );
    txt.c_inline += 2;
  }
  Free( tmp );
}

__TxtCmd( CmdToggleComment )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      ToggleComment( txt );
    } break;
    case seltype_t::s: // defer to multiselect implementation. this works because c, s are the same across sel, multisel!
    case seltype_t::m: {
      MultiselectToggleComment( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
CommentSelection( txt_t& txt )
{
  content_ptr_t sl, sr;
  GetSelect( txt, &sl, &sr );
  content_ptr_t* concurrents[] = {
    &sl,
    &sr,
    __TxtConcurrentPtrs( txt )
  };
  Insert( txt.buf, sr, Str( "*/" ), 2, AL( concurrents ) );
  Insert( txt.buf, sl, Str( "/*" ), 2, AL( concurrents ) );
  ResetCInline( txt );
}

__TxtCmd( CmdCommentSelection )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none:
    case seltype_t::m: {
    } break;
    case seltype_t::s: {
      CommentSelection( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
UncommentSelection( txt_t& txt )
{
  content_ptr_t sl, sr;
  GetSelect( txt, &sl, &sr );

  // TODO: allow selecting just the thing inside the comment
  // TODO: allow whitespace inside the comment ?

  auto open_start = sl;
  auto open_end = CursorCharR( txt.buf, sl, 2, 0 );

  auto close_start = CursorCharL( txt.buf, sr, 2, 0 );
  auto close_end = sr;

  auto open = AllocContents( txt.buf, open_start, open_end );
  auto close = AllocContents( txt.buf, close_start, close_end );

  auto is_comment =
    MemEqual( ML( open ), Str( "/*" ), 2 )  &&
    MemEqual( ML( close ), Str( "*/" ), 2 );
  if( is_comment ) {
    content_ptr_t* concurrents[] = {
      &open_start,
      &open_end,
      &close_start,
      &close_end,
      __TxtConcurrentPtrs( txt )
    };
    Delete( txt.buf, close_start, close_end, AL( concurrents ) );
    Delete( txt.buf, open_start, open_end, AL( concurrents ) );
    ResetCInline( txt );
  }

  Free( open );
  Free( close );
}

__TxtCmd( CmdUncommentSelection )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none:
    case seltype_t::m: {
    } break;
    case seltype_t::s: {
      UncommentSelection( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}


#define USE_SWAP_FOR_PERMUTELINES 0 // TODO: need some more testing+validation of buf retvals from Copy, Move, Swap.


Inl void
MultiselectPermuteU( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );

  idx_t c_ln_len;
  CursorStopAtNewlineR( txt.buf, ms.c_ln_start, &c_ln_len );
  idx_t s_ln_len;
  CursorStopAtNewlineR( txt.buf, ms.s_ln_start, &s_ln_len );

  auto c_before_s = LEqual( txt.c, txt.s );

  auto r1_start = ms.top_ln_start;
  auto r1_end = CursorStopAtNewlineR( txt.buf, ms.bot_ln_start, 0 );
  auto r0_end = CursorSingleNewlineL( txt.buf, r1_start, 0 );
  auto r0_start = CursorStopAtNewlineL( txt.buf, r0_end, 0 );
  if( !Equal( r0_end, r1_start ) ) { // newline actually skipped
#if USE_SWAP_FOR_PERMUTELINES
    bool c_was_r0_end = Equal( txt.c, r0_end );
    bool c_was_r1_end = Equal( txt.c, r1_end );
    bool s_was_r0_end = Equal( txt.s, r0_end );
    bool s_was_r1_end = Equal( txt.s, r1_end );
    content_ptr_t moved_r0_end;
    content_ptr_t moved_r1_end;
    content_ptr_t* concurrents[] = {
      __MultiselConcurrentPtrs( ms ),
      __TxtConcurrentPtrs( txt )
    };
    Swap(
      txt.buf,
      r0_start,
      r0_end,
      r1_start,
      r1_end,
      &moved_r0_end,
      &moved_r1_end,
      AL( concurrents )
      );

    // i.e. it doesn't know that it's really a list-end pointer.
    // so, fix txt.c/s if we're in that case.
    // TODO: should we do this for all concurrents here; e.g. scroll_start, scroll_end?
    if( c_was_r0_end ) {
      txt.c = moved_r0_end;
    }
    if( c_was_r1_end ) {
      txt.c = moved_r1_end;
    }
    if( s_was_r0_end ) {
      txt.s = moved_r0_end;
    }
    if( s_was_r1_end ) {
      txt.s = moved_r1_end;
    }
#else // !USE_SWAP_FOR_PERMUTELINES
    auto r0_len = CountCharsBetween( txt.buf, r0_start, r0_end );
    content_ptr_t* concurrents[] = {
      &r0_start,
      &r0_end,
      &r1_start,
      &r1_end,
      __MultiselConcurrentPtrs( ms ),
      __TxtConcurrentPtrs( txt )
    };
    // r0 newline r1 => r0 r1 newline
    Move(
      txt.buf,
      r0_end, // src_start
      r1_start, // src_end
      r1_end, // dst
      AL( concurrents )
      );
    // r0 r1 newline => r1 newline r0
    Move(
      txt.buf,
      r0_start, // src_start
      CursorCharR( txt.buf, r0_start, r0_len, 0 ), // src_end
      r1_end, // dst
      AL( concurrents )
      );

    if( c_ln_len ) {
      txt.c = CursorCharR( txt.buf, ms.c_ln_start, ms.c_inline, 0 );
    } else {
      txt.c = c_before_s  ?  r1_start  :  r0_end;
    }
    if( s_ln_len ) {
      txt.s = CursorCharR( txt.buf, ms.s_ln_start, ms.s_inline, 0 );
    } else {
      txt.s = c_before_s  ?  r0_end  :  r1_start;
    }
#endif // !USE_SWAP_FOR_PERMUTELINES
  }
}

Inl void
PermuteU( txt_t& txt )
{
  idx_t c_inline;
  auto r1_start = CursorStopAtNewlineL( txt.buf, txt.c, &c_inline );
  auto r1_end = CursorStopAtNewlineR( txt.buf, txt.c, 0 );
  auto r0_end = CursorSingleNewlineL( txt.buf, r1_start, 0 );
  auto r0_start = CursorStopAtNewlineL( txt.buf, r0_end, 0 );
  if( !Equal( r0_end, r1_start ) ) { // newline actually skipped
#if USE_SWAP_FOR_PERMUTELINES
    bool c_was_r0_end = Equal( txt.c, r0_end );
    bool c_was_r1_end = Equal( txt.c, r1_end );
    content_ptr_t moved_r0_end;
    content_ptr_t moved_r1_end;
    content_ptr_t* concurrents[] = {
      __TxtConcurrentPtrs( txt )
    };
    Swap(
      txt.buf,
      r0_start,
      r0_end,
      r1_start,
      r1_end,
      &moved_r0_end,
      &moved_r1_end,
      AL( concurrents )
      );

    // i.e. it doesn't know that it's really a list-end pointer.
    // so, fix txt.c if we're in that case.
    // TODO: should we do this for all concurrents here; e.g. scroll_start, scroll_end?
    if( c_was_r0_end ) {
      txt.c = moved_r0_end;
    }
    if( c_was_r1_end ) {
      txt.c = moved_r1_end;
    }
#else // !USE_SWAP_FOR_PERMUTELINES
    auto r0_len = CountCharsBetween( txt.buf, r0_start, r0_end );
    auto r1_len = CountCharsBetween( txt.buf, r1_start, r1_end );
    content_ptr_t* concurrents[] = {
      &r0_start,
      &r0_end,
      &r1_start,
      &r1_end,
      __TxtConcurrentPtrs( txt )
    };
    // r0 newline r1 => r0 r1 newline
    Move(
      txt.buf,
      r0_end, // src_start
      r1_start, // src_end
      r1_end, // dst
      AL( concurrents )
      );
    // r0 r1 newline => r1 newline r0
    Move(
      txt.buf,
      r0_start, // src_start
      CursorCharR( txt.buf, r0_start, r0_len, 0 ), // src_end
      r1_end, // dst
      AL( concurrents )
      );

    if( r1_len ) {
      txt.c = CursorCharR( txt.buf, r1_start, c_inline, 0 );
    } else {
      txt.c = r0_end;
    }
#endif // !USE_SWAP_FOR_PERMUTELINES
  }
}

__TxtCmd( CmdPermuteU )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      PermuteU( txt );
    } break;
    case seltype_t::s: // defer to multiselect implementation. this works because c, s are the same across sel, multisel!
    case seltype_t::m: {
      MultiselectPermuteU( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectPermuteD( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );

  idx_t c_ln_len;
  CursorStopAtNewlineR( txt.buf, ms.c_ln_start, &c_ln_len );
  idx_t s_ln_len;
  CursorStopAtNewlineR( txt.buf, ms.s_ln_start, &s_ln_len );

  auto c_before_s = LEqual( txt.c, txt.s );

  auto r0_start = ms.top_ln_start;
  auto r0_end = CursorStopAtNewlineR( txt.buf, ms.bot_ln_start, 0 );
  auto r1_start = CursorSingleNewlineR( txt.buf, r0_end, 0 );
  auto r1_end = CursorStopAtNewlineR( txt.buf, r1_start, 0 );
  if( !Equal( r0_end, r1_start ) ) { // newline actually skipped
#if USE_SWAP_FOR_PERMUTELINES
    bool c_was_r0_end = Equal( txt.c, r0_end );
    bool c_was_r1_end = Equal( txt.c, r1_end );
    bool s_was_r0_end = Equal( txt.s, r0_end );
    bool s_was_r1_end = Equal( txt.s, r1_end );
    content_ptr_t moved_r0_end;
    content_ptr_t moved_r1_end;
    content_ptr_t* concurrents[] = {
      __MultiselConcurrentPtrs( ms ),
      __TxtConcurrentPtrs( txt )
    };
    Swap(
      txt.buf,
      r0_start,
      r0_end,
      r1_start,
      r1_end,
      &moved_r0_end,
      &moved_r1_end,
      AL( concurrents )
      );

    // i.e. it doesn't know that it's really a list-end pointer.
    // so, fix txt.c/s if we're in that case.
    // TODO: should we do this for all concurrents here; e.g. scroll_start, scroll_end?
    if( c_was_r0_end ) {
      txt.c = moved_r0_end;
    }
    if( c_was_r1_end ) {
      txt.c = moved_r1_end;
    }
    if( s_was_r0_end ) {
      txt.s = moved_r0_end;
    }
    if( s_was_r1_end ) {
      txt.s = moved_r1_end;
    }
#else // !USE_SWAP_FOR_PERMUTELINES
    auto r0_len = CountCharsBetween( txt.buf, r0_start, r0_end );
    content_ptr_t* concurrents[] = {
      &r0_start,
      &r0_end,
      &r1_start,
      &r1_end,
      __MultiselConcurrentPtrs( ms ),
      __TxtConcurrentPtrs( txt )
    };
    // r0 newline r1 => r0 r1 newline
    Move(
      txt.buf,
      r0_end, // src_start
      r1_start, // src_end
      r1_end, // dst
      AL( concurrents )
      );
    // r0 r1 newline => r1 newline r0
    Move(
      txt.buf,
      r0_start, // src_start
      CursorCharR( txt.buf, r0_start, r0_len, 0 ), // src_end
      r1_end, // dst
      AL( concurrents )
      );

    if( c_ln_len ) {
      txt.c = CursorCharR( txt.buf, ms.c_ln_start, ms.c_inline, 0 );
    } else {
      txt.c = c_before_s  ?  r0_start  :  r1_end;
    }
    if( s_ln_len ) {
      txt.s = CursorCharR( txt.buf, ms.s_ln_start, ms.s_inline, 0 );
    } else {
      txt.s = c_before_s  ?  r1_end  :  r0_start;
    }
#endif // !USE_SWAP_FOR_PERMUTELINES
  }
}

Inl void
PermuteD( txt_t& txt )
{
  idx_t c_inline;
  auto r0_start = CursorStopAtNewlineL( txt.buf, txt.c, &c_inline );
  auto r0_end = CursorStopAtNewlineR( txt.buf, txt.c, 0 );
  auto r1_start = CursorSingleNewlineR( txt.buf, r0_end, 0 );
  auto r1_end = CursorStopAtNewlineR( txt.buf, r1_start, 0 );
  if( !Equal( r0_end, r1_start ) ) { // newline actually skipped
#if USE_SWAP_FOR_PERMUTELINES
    bool c_was_r0_end = Equal( txt.c, r0_end );
    bool c_was_r1_end = Equal( txt.c, r1_end );
    content_ptr_t moved_r0_end;
    content_ptr_t moved_r1_end;
    content_ptr_t* concurrents[] = {
      __TxtConcurrentPtrs( txt )
    };
    Swap(
      txt.buf,
      r0_start,
      r0_end,
      r1_start,
      r1_end,
      &moved_r0_end,
      &moved_r1_end,
      AL( concurrents )
      );

    // Swap doesn't move the r1_end, since it's actually pointing to content outside the swap.
    // i.e. it doesn't know that it's really a list-end pointer.
    // so, fix txt.c if we're in that case.
    // TODO: should we do this for all concurrents here; e.g. scroll_start, scroll_end?
    if( c_was_r0_end ) {
      txt.c = moved_r0_end;
    }
    if( c_was_r1_end ) {
      txt.c = moved_r1_end;
    }
#else // !USE_SWAP_FOR_PERMUTELINES
    auto r0_len = CountCharsBetween( txt.buf, r0_start, r0_end );
    content_ptr_t* concurrents[] = {
      &r0_start,
      &r0_end,
      &r1_start,
      &r1_end,
      __TxtConcurrentPtrs( txt )
    };
    // r0 newline r1 => r0 r1 newline
    Move(
      txt.buf,
      r0_end, // src_start
      r1_start, // src_end
      r1_end, // dst
      AL( concurrents )
      );
    // r0 r1 newline => r1 newline r0
    Move(
      txt.buf,
      r0_start, // src_start
      CursorCharR( txt.buf, r0_start, r0_len, 0 ), // src_end
      r1_end, // dst
      AL( concurrents )
      );

    if( r0_len ) {
      txt.c = CursorCharR( txt.buf, r0_start, c_inline, 0 );
    } else {
      txt.c = r1_end;
    }
#endif // !USE_SWAP_FOR_PERMUTELINES
  }
}

__TxtCmd( CmdPermuteD )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      PermuteD( txt );
    } break;
    case seltype_t::s: // defer to multiselect implementation. this works because c, s are the same across sel, multisel!
    case seltype_t::m: {
      MultiselectPermuteD( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdTxtUndo )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  if( !txt.undos_txtcs.len ) {
    return;
  }

  cs_undo_t state;
  CsUndoFromTxt( txt, &state );
  *AddBack( txt.redos_txtcs ) = state;

  // ApplyCsUndo depends on buf.content_len, so we need to update buf first!
  Undo( txt.buf );

  cs_undo_t undo = txt.undos_txtcs.mem[txt.undos_txtcs.len - 1];
  RemBack( txt.undos_txtcs );
  ApplyCsUndo( txt, undo );

  MakeCursorVisible( txt );
}

__TxtCmd( CmdTxtRedo )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  if( !txt.redos_txtcs.len ) {
    return;
  }

  cs_undo_t state;
  CsUndoFromTxt( txt, &state );
  *AddBack( txt.undos_txtcs ) = state;

  // ApplyCsUndo depends on buf.content_len, so we need to update buf first!
  Redo( txt.buf );

  cs_undo_t redo = txt.redos_txtcs.mem[txt.redos_txtcs.len - 1];
  RemBack( txt.redos_txtcs );
  ApplyCsUndo( txt, redo );

  MakeCursorVisible( txt );
}



// TODO: move to os interface.
Inl void
SendToClipboardText( u8* text, idx_t text_len )
{
  HGLOBAL win_mem = {};

  HWND hwnd = GetForegroundWindow();
  AssertWarn( hwnd );
  if( !hwnd ) {
    return;
  }

  idx_t retry = 0;
  while( retry < 10  &&  !OpenClipboard( hwnd ) ) {
    TimeSleep( 1 ); // block until we get the clipboard.
    retry += 1;
  }

  AssertWarn( EmptyClipboard() );

  // we have to go thru windows-specific allocator.
  win_mem = GlobalAlloc( GMEM_MOVEABLE, text_len + 1 );
  AssertWarn( win_mem );

  u8* tmp_mem = Cast( u8*, GlobalLock( win_mem ) );
  AssertWarn( tmp_mem );
  Memmove( tmp_mem, text, text_len );
  Memmove( tmp_mem + text_len, "", 1 ); // insert nul-terminator for CF_OEMTEXT prereq.
  GlobalUnlock( win_mem );

  HANDLE hclip = SetClipboardData( CF_OEMTEXT, win_mem );
  AssertWarn( hclip );

  AssertWarn( CloseClipboard() );

  // cannot be freed before CloseClipboard call.
  GlobalFree( win_mem );
}


#define USECLIPBOARDTXT( name )   void ( name )( u8* text, idx_t text_len, void* misc )
typedef USECLIPBOARDTXT( *pfn_useclipboardtxt_t );

// TODO: move to os interface.
Inl void
GetFromClipboardText( pfn_useclipboardtxt_t UseClipboardTxt, void* misc )
{
  HWND hwnd = GetForegroundWindow();
  AssertWarn( hwnd );
  if( !hwnd ) {
    return;
  }

  idx_t retry = 0;
  while( retry < 10  &&  !OpenClipboard( hwnd ) ) {
    TimeSleep( 1 ); // block until we get the clipboard.
    retry += 1;
  }

  // TODO: why can't we retrieve OEMTEXT?
  HANDLE clip = GetClipboardData( CF_TEXT );
  if( clip ) {
    u8* text = Cast( u8*, GlobalLock( clip ) );
    idx_t text_len = CsLen( text );
    UseClipboardTxt( text, text_len, misc );
    GlobalUnlock( clip );
  } else {
    UseClipboardTxt( 0, 0, misc );
  }

  AssertWarn( CloseClipboard() );
}

Inl
USECLIPBOARDTXT( UseClipboardTxtFillBuf )
{
  auto& buf = *Cast( buf_t*, misc );
  auto bof = GetBOF( buf );
  auto eof = GetEOF( buf );
  Delete( buf, bof, eof, 0, 0 );
  Insert( buf, bof, text, text_len, 0, 0 );
}

Inl void
GetFromClipboardText( buf_t* buf )
{
  GetFromClipboardText( UseClipboardTxtFillBuf, buf );
}



Inl void
MultiselectCopy( txt_t& txt, multisel_t& ms )
{
  AssertCrash( ms.left_inline != ms.rght_inline );

  array_t<u8> clip;
  Alloc( clip, 32768 ); // PERF: smarter allocation size

  auto ln_start = ms.bot_ln_start;
  Forever {
    // the selection range on the given line ln_start.
    idx_t ninline;
    auto ml = CursorCharInlineR( txt.buf, ln_start, ms.left_inline, &ninline );
    idx_t ninline_right;
    auto mr = CursorCharInlineR( txt.buf, ln_start, ms.rght_inline, &ninline_right );

    // TODO: os specific - windows. probably allow different options for what eol to send to clipboard.
    u8* eol = Str( "\r\n" );
    idx_t eol_len = 2;

    AssertCrash( ninline <= ninline_right );
    auto copy_len = ninline_right - ninline;
    if( copy_len ) {
      auto copy = AddBack( clip, copy_len );
      Contents( txt.buf, ml, copy, copy_len );
    }
    auto dst_eol = AddBack( clip, eol_len );
    Memmove( dst_eol, eol, eol_len );

    if( Greater( ln_start, ms.top_ln_start ) ) {
      ln_start = CursorLineU( txt.buf, ln_start, 0, 1, 0, 0 );
    } else {
      AssertCrash( Equal( ln_start, ms.top_ln_start ) );
      break;
    }
  }

  SendToClipboardText( ML( clip ) );

  Free( clip );
}

Inl void
SelectCopy( txt_t& txt )
{
  content_ptr_t sl, sr;
  GetSelect( txt, &sl, &sr );

  auto sel_len = CountCharsBetween( txt.buf, sl, sr );
  if( sel_len ) {

    array_t<u8> clip;
    Alloc( clip, sel_len );

    constant idx_t c_chunk_size = 65536;
    idx_t n0 = sel_len / c_chunk_size;
    idx_t n1 = sel_len % c_chunk_size;

    auto pos = sl;

    // TODO: don't use buf_t newlines; insert CRLF explicitly!

    // dump buf_t data within sl,sr into clip.
    while( n0-- ) {
      auto dst = AddBack( clip, c_chunk_size );
      pos = Contents( txt.buf, pos, dst, c_chunk_size );
    }
    auto dst = AddBack( clip, n1 );
    pos = Contents( txt.buf, pos, dst, n1 );

    SendToClipboardText( ML( clip ) );

    Free( clip );
  }
}

__TxtCmd( CmdCopy )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  switch( txt.seltype ) {
    case seltype_t::none: {
    } break;
    case seltype_t::s: {
      SelectCopy( txt );
    } break;
    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      if( ms.left_inline != ms.rght_inline ) {
        MultiselectCopy( txt, ms );
      }
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCut )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
    } break;
    case seltype_t::s: {
      SelectCopy( txt );
      SelectDelete( txt );
    } break;
    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      if( ms.left_inline != ms.rght_inline ) {
        MultiselectCopy( txt, ms );
        MultiselectDelete( txt, ms );
      }
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}


Inl void
MultiselectPaste( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );

  if( ms.left_inline != ms.rght_inline ) {
    MultiselectDelete( txt, ms );
    // txt.c/c_inline has probably changed, so ms.left_inline/rght_inline will be different!
    // so, re-get the ms so MultiselectAddChar can work!
    GetMultiselect( txt, ms );
  }

  AssertCrash( ms.left_inline == ms.rght_inline );

  buf_t to_paste;
  Init( to_paste );
  BufLoadEmpty( to_paste );
  GetFromClipboardText( &to_paste );

  idx_t lns_to_skip = 0;

  auto ln_start = ms.bot_ln_start;
  Forever {
    auto ln_end = CursorStopAtNewlineR( txt.buf, ln_start, 0 );

    auto paste_start = CursorLineD( to_paste, GetBOF( to_paste ), 0, lns_to_skip, 0, 0 );
    lns_to_skip += 1;

    auto paste_end = CursorStopAtNewlineR( to_paste, paste_start, 0 );
    auto paste_contents = AllocContents( to_paste, paste_start, paste_end );

    if( paste_contents.len ) {
      idx_t ninline;
      auto pos = CursorCharInlineR( txt.buf, ln_start, ms.left_inline, &ninline );
      AssertCrash( LEqual( ln_start, pos ) );
      content_ptr_t* concurrents[] = {
        &paste_start,
        &paste_end,
        &pos,
        &ln_start,
        &ln_end,
        __MultiselConcurrentPtrs( ms ),
        __TxtConcurrentPtrs( txt )
      };
      if( ninline < ms.left_inline ) {
        auto nspaces = ms.left_inline - ninline;
        while( nspaces-- ) {
          Insert(
            txt.buf,
            ln_end,
            Str( " " ),
            1,
            AL( concurrents )
            );
        }
      }
      AssertCrash( LEqual( pos, ln_end ) );

      Insert(
        txt.buf,
        pos,
        ML( paste_contents ),
        AL( concurrents )
        );
    }
    Free( paste_contents );

    if( Greater( ln_start, ms.top_ln_start ) ) {
      ln_start = CursorLineU( txt.buf, ln_start, 0, 1, 0, 0 );
    } else {
      AssertCrash( Equal( ln_start, ms.top_ln_start ) );
      break;
    }
  }

  auto ln0_start = GetBOF( to_paste );
  idx_t dx;
  auto ln0_end = CursorStopAtNewlineR( to_paste, ln0_start, &dx );
  Kill( to_paste );

  txt.c_inline += dx;
}

Inl
USECLIPBOARDTXT( UseClipboardTxtPaste )
{
  auto& txt = *Cast( txt_t*, misc );

  content_ptr_t* concurrents[] = {
    __TxtConcurrentPtrs( txt )
  };
  Insert( txt.buf, txt.c, text, text_len, AL( concurrents ) );
  ResetCInline( txt );
}

Inl void
Paste( txt_t& txt )
{
  GetFromClipboardText( UseClipboardTxtPaste, &txt );
}

__TxtCmd( CmdPaste )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      Paste( txt );
    } break;
    case seltype_t::s: {
      SelectDelete( txt );
      Paste( txt );
    } break;
    case seltype_t::m: {
      MultiselectPaste( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}


#if 0
__TxtCmd( CmdFindCursorWordR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      idx_t word_start = CursorStopAtNonWordCharL( txt.buf, txt.c );
      idx_t word_end = CursorStopAtNonWordCharR( txt.buf, txt.c );
      idx_t word_len = word_end - word_start;
      if( word_len ) {
        auto word = MemHeapAlloc( u8, word_len );
        Contents( txt.buf, word_start, word, word_len );
        idx_t new_c;
        bool found;
        FindFirstR( txt.buf, word_end, word, word_len, &new_c, &found, 1 );
        if( found ) {
          txt.c = new_c;
          ResetCInline( txt );
        }
        MemHeapFree( word );
      }
    } break;
    case seltype_t::s: {
      // TODO: find next selection match?
    } break;
    case seltype_t::m: {
      // TODO: do what?
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}

__TxtCmd( CmdFindCursorWordL )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      idx_t word_start = CursorStopAtNonWordCharL( txt.buf, txt.c );
      idx_t word_end = CursorStopAtNonWordCharR( txt.buf, txt.c );
      idx_t word_len = word_end - word_start;
      if( word_len ) {
        auto word = MemHeapAlloc( u8, word_len );
        Contents( txt.buf, word_start, word, word_len );
        idx_t new_c;
        bool found;
        FindFirstL( txt.buf, word_start, word, word_len, &new_c, &found, 1 );
        if( found ) {
          txt.c = new_c;
          ResetCInline( txt );
        }
        MemHeapFree( word );
      }
    } break;
    case seltype_t::s: {
      // TODO: find next selection match?
    } break;
    case seltype_t::m: {
      // TODO: do what?
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}
#endif


struct
txtfind_t
{
  u8* str;
  idx_t str_len;
  bool case_sens;
  bool word_boundary;
};

__TxtCmd( CmdFindStringR )
{
  AssertCrash( !misc2 );

  auto& txtfind = *Cast( txtfind_t*, misc );
  AddCsUndo( txt );
  if( txtfind.str_len ) {
    content_ptr_t new_c;
    bool found;
    FindFirstR(
      txt.buf,
      txt.c,
      txtfind.str,
      txtfind.str_len,
      &new_c,
      &found,
      txtfind.case_sens,
      txtfind.word_boundary
      );
    if( found ) {
      txt.c = new_c;
      AnchorSelect( txt, txt.c );
      txt.c = CursorCharR( txt.buf, txt.c, txtfind.str_len, 0 );
      ResetCInline( txt );
    }
  }
  MakeCursorVisible( txt );
}

__TxtCmd( CmdFindStringL )
{
  AssertCrash( !misc2 );

  auto& txtfind = *Cast( txtfind_t*, misc );
  AddCsUndo( txt );
  if( txtfind.str_len ) {
    content_ptr_t new_c;
    bool found;
    FindFirstL(
      txt.buf,
      txt.c,
      txtfind.str,
      txtfind.str_len,
      &new_c,
      &found,
      txtfind.case_sens,
      txtfind.word_boundary
      );
    if( found ) {
      txt.c = new_c;
      AnchorSelect( txt, txt.c );
      txt.c = CursorCharL( txt.buf, txt.c, txtfind.str_len, 0 );
      ResetCInline( txt );
    }
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdRemTrailspace )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddTxtUndo( txt );
  auto bol = GetBOF( txt.buf );
  Forever {
    auto eol = CursorStopAtNewlineR( txt.buf, bol, 0 );
    auto new_eol = CursorSkipSpacetabL( txt.buf, eol, 0 );
    if( Greater( eol, new_eol ) ) {
      content_ptr_t* concurrents[] = {
        &bol,
        &eol,
        &new_eol,
        __TxtConcurrentPtrs( txt )
      };
      Delete( txt.buf, new_eol, eol, AL( concurrents ) );
    }
    auto new_bol = CursorSingleNewlineR( txt.buf, eol, 0 );
    if( Equal( new_bol, bol ) ) {
      break;
    }
    bol = new_bol;
  }
  ResetCInline( txt );
}


// =================================================================================
// TXT DRAW CALLS
//

// loop:
//   pull window_n_chars from txt.buf at pos
//   render those chars.
//   increment y.
//   if word wrap, then
//     pos += window_n_chars.
//   else
//     pos = scan( pos+1, \n ).
//
// really, we want to output per-char render commands, and then combine as much as possible.
//   struct drawchar_t
//   {
//     u8* c; // points to
//     vec4<f32>* color;
//     u16 x; // window space line pos., u16 for safe drawchar_t <-> drawchar_t comparison.
//     u16 y; // window space line no., u16 for safe drawchar_t <-> drawchar_t comparison.
//   };



//Inl f32
//GetPxLineno( txt_t& txt, f32 FontCharW )
//{
//  if( !opts.lineno_show )
//    return 0.0f;
//  u8 tmp_str [ 32 ];
//  if( opts.lineno_fix_width )
//    Cstr::cstr_from_u64( tmp_str, nlines( *txt.buf ) - 1 );
//  else
//    Cstr::cstr_from_u64( tmp_str, txt.scroll.ln_end - 1 );
//  u8 LinenoDigits = Cast( u8, CsLen( tmp_str ) );
//  f32 PxLineno = FontCharW * ( LinenoDigits + 1 );
//  return PxLineno;
//}


constant idx_t c_max_line_len = 500; // sanity bounds.

void
TxtLayoutSingleLineSubset(
  txt_t& txt,
  content_ptr_t start,
  idx_t len,
  font_t& font
  )
{
  ProfFunc();

  auto spaces_per_tab = GetPropFromDb( u8, u8_spaces_per_tab );

  FontClear( txt.layout );

  if( len ) {
    u8 line[c_max_line_len];
    auto line_len = MIN( len, c_max_line_len ); // account for hard end-clipping
    Contents( txt.buf, start, line, line_len );

    FontAddLayoutLine(
      font,
      txt.layout,
      line,
      line_len,
      spaces_per_tab
      );
  }
}




void
TxtRenderSelection(
  txt_t& txt,
  array_t<f32>& stream,
  rectf32_t bounds,
  content_ptr_t line_start,
  content_ptr_t line_end,
  f32 px_space_advance,
  idx_t nchars,
  idx_t layout_line_idx,
  f32 x,
  f32 y,
  f32 z,
  f32 line_h
  )
{
  auto rgba_selection_bkgd = GetPropFromDb( vec4<f32>, rgba_selection_bkgd );
  auto px_cursor_w = GetPropFromDb( u8, u8_px_cursor_w );

  switch( txt.seltype ) {
    case seltype_t::none: {
    } break;

    case seltype_t::s: {
      content_ptr_t sl, sr;
      GetSelect( txt, &sl, &sr );
      // draw s_selection on line.
      auto sel_start = Max( line_start, sl );
      auto sel_end   = Min( line_end, sr );
      // fixup sel_end to show newlines inside the sel region.
      f32 overhang = 0.0f;
      if( Equal( line_end, sel_end )  &&  !Equal( line_end, sr ) ) {
        overhang = px_space_advance;
      }
      if( LEqual( sel_start, sel_end ) ) {
        auto sel_x0 = 0.0f;
        auto sel_x1 = 0.0f;
        if( nchars ) {
          auto nbeforesel = CountCharsBetween( txt.buf, line_start, sel_start );
          auto sel_len = CountCharsBetween( txt.buf, sel_start, sel_end );

          // account for hard end-clipping
          nbeforesel = MIN( nchars, nbeforesel );
          sel_len = MIN( nchars - nbeforesel, sel_len );

          sel_x0 = FontSumAdvances(
            txt.layout,
            layout_line_idx,
            0,
            nbeforesel
            );
          sel_x1 = sel_x0 + FontSumAdvances(
            txt.layout,
            layout_line_idx,
            nbeforesel,
            sel_len
            );
        }
        auto s0 = _vec2( x + sel_x0, y );
        auto s1 = _vec2( x + sel_x1 + overhang, y + line_h );
        RenderQuad(
          stream,
          rgba_selection_bkgd,
          bounds.p0 + s0,
          bounds.p0 + s1,
          bounds,
          z
          );
      }
    } break;

    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      // draw m_selection on line.
      auto sel_start = Min( CursorCharR( txt.buf, line_start, ms.left_inline, 0 ), line_end );
      auto sel_end   = Min( CursorCharR( txt.buf, line_start, ms.rght_inline, 0 ), line_end );
      bool m_x_valid = Less( sel_start, sel_end );
      bool m_y_valid = LEqual( ms.top_ln_start, line_start ) & LEqual( line_start, ms.bot_ln_start );
      bool m_draw = ( m_x_valid  &&  m_y_valid );
      if( m_draw ) {
        auto sel_x0 = 0.0f;
        auto sel_x1 = 0.0f;
        if( nchars ) {
          auto nbeforesel = CountCharsBetween( txt.buf, line_start, sel_start );
          auto sel_len = CountCharsBetween( txt.buf, sel_start, sel_end );

          // account for hard end-clipping
          nbeforesel = MIN( nchars, nbeforesel );
          sel_len = MIN( nchars - nbeforesel, sel_len );

          sel_x0 = FontSumAdvances(
            txt.layout,
            layout_line_idx,
            0,
            nbeforesel
            );
          sel_x1 = sel_x0 + FontSumAdvances(
            txt.layout,
            layout_line_idx,
            nbeforesel,
            sel_len
            );
        }
        auto s0 = _vec2( x + sel_x0, y );
        auto s1 = _vec2( x + sel_x1, y + line_h );
        if( Equal( sel_start, sel_end ) ) {
          s1.x += px_cursor_w;
        }
        RenderQuad(
          stream,
          rgba_selection_bkgd,
          bounds.p0 + s0,
          bounds.p0 + s1,
          bounds,
          z
          );
      }
    } break;
    default: UnreachableCrash();
  }
}

void
TxtRenderCursor(
  txt_t& txt,
  array_t<f32>& stream,
  rectf32_t bounds,
  content_ptr_t line_start,
  content_ptr_t line_end,
  f32 px_space_advance,
  idx_t nchars,
  idx_t layout_line_idx,
  f32 x,
  f32 y,
  f32 z,
  f32 line_h
  )
{
  auto px_cursor_w = GetPropFromDb( u8, u8_px_cursor_w );

  if( LEqual( line_start, txt.c ) & LEqual( txt.c, line_end ) ) {
    f32 cursor_advance = 0.0f;
    if( nchars ) {
      auto nbeforecur = CountCharsBetween( txt.buf, line_start, txt.c );

      // account for hard end-clipping
      nbeforecur = MIN( nchars, nbeforecur );

      cursor_advance = FontSumAdvances(
        txt.layout,
        layout_line_idx,
        0,
        nbeforecur
        );
    }

    f32 cx = x + cursor_advance;

    rectf32_t r;
    if( txt.overwrite ) {
      r.p0 = bounds.p0 + _vec2( cx, y + line_h - px_cursor_w );
      r.p1 = bounds.p0 + _vec2( cx + px_space_advance, y + line_h );
    } else {
      r.p0 = bounds.p0 + _vec2( cx, y );
      r.p1 = bounds.p0 + _vec2( cx + px_cursor_w, y + line_h );
    }
    RenderQuad(
      stream,
      GetPropFromDb( vec4<f32>, rgba_cursor ),
      r,
      bounds,
      z
      );
  }
}





Enumc( txtlayer_t )
{
  bkgd,
  cursorline,
  match,
  sel,
  txt,
  cur,
  scroll_bkgd,
  scroll_btn,

  COUNT
};


// NOTE: because of layout_t, you can't use both EditRender and RenderSingleLineSubset on the same txt_t !

void
TxtRenderSingleLineSubset(
  txt_t& txt,
  array_t<f32>& stream,
  font_t& font,
  rectf32_t bounds,
  vec2<f32> zrange,
  bool draw_bkgd,
  bool draw_cursor,
  bool draw_sel
  )
{
  ProfFunc();

  auto rgba_text = GetPropFromDb( vec4<f32>, rgba_text );

  auto line_h = FontLineH( font );
  auto line_len = MIN( TxtLen( txt ), c_max_line_len ); // account for hard end-clipping
  AssertCrash( line_len == txt.layout.raw_advances.len );
  auto px_space_advance = FontGetAdvance( font, ' ' );

  if( draw_bkgd ) {
    RenderQuad(
      stream,
      GetPropFromDb( vec4<f32>, rgba_text_bkgd ),
      bounds,
      GetZ( zrange, txtlayer_t::bkgd )
      );
  }

  if( !FontEmpty( txt.layout ) ) {
    RenderText(
      stream,
      font,
      txt.layout,
      bounds.p0,
      GetZ( zrange, txtlayer_t::txt ),
      bounds,
      rgba_text,
      0,
      0,
      line_len
      );
  }

  // draw selection.
  auto bof = GetBOF( txt.buf );
  auto eof = GetEOF( txt.buf );
  if( draw_sel ) {
    TxtRenderSelection(
      txt,
      stream,
      bounds,
      bof,
      eof,
      px_space_advance,
      line_len,
      0,
      0.0f,
      0.0f,
      GetZ( zrange, txtlayer_t::sel ),
      line_h
      );
  }

  // draw cursor.
  if( draw_cursor ) {
    TxtRenderCursor(
      txt,
      stream,
      bounds,
      bof,
      eof,
      px_space_advance,
      line_len,
      0,
      0.0f,
      0.0f,
      GetZ( zrange, txtlayer_t::cur ),
      line_h
      );
  }
}



struct
txt_wordspan_t
{
  content_ptr_t l;
  content_ptr_t r;
  bool is_ident;
};


Inl f32
EstimateLinearPos( txt_t& txt, content_ptr_t pos )
{
  ProfFunc();

  if( IsEOF( txt.buf, pos ) ) {
    return 1;
  }

  idx_t cumulative_sum = 0;
  ForLen( i, txt.buf.diffs ) { // PERF: this is slow / bad for large diff counts.
    auto diff = txt.buf.diffs.mem + i;
    if( i < pos.diff_idx ) {
      cumulative_sum += diff->slice.len;
    }
  }

  AssertCrash( pos.diff_idx < txt.buf.diffs.len );
  auto diff = txt.buf.diffs.mem + pos.diff_idx;
  AssertCrash( pos.offset_into_diff <= diff->slice.len );
  AssertCrash( diff->slice.len );
  auto t = Cast( f32, cumulative_sum + pos.offset_into_diff ) / Cast( f32, txt.buf.content_len );
  auto linear_pos = CLAMP( t, 0, 1 );
  return linear_pos;
}

Inl vec3<f32>
GetScrollPos( txt_t& txt ) // TODO: only need vec2 retval
{
  return _vec3<f32>(
    CLAMP( EstimateLinearPos( txt, txt.scroll_start.y ), 0, 1 ),
    CLAMP( EstimateLinearPos( txt, txt.c ), 0, 1 ),
    CLAMP( EstimateLinearPos( txt, txt.scroll_end ), 0, 1 )
    );
}

Inl bool
ScrollbarVisible(
  rectf32_t bounds,
  f32 px_scroll
  )
{
  bool r =
    ( bounds.p1.x - bounds.p0.x ) > 2 * px_scroll  &&
    ( bounds.p1.y - bounds.p0.y ) > 4 * px_scroll;
  return r;
}

Inl rectf32_t
GetScrollBtnUp(
  rectf32_t bounds,
  f32 px_scroll
  )
{
  rectf32_t r;
  r.p0 = bounds.p0 + _vec2( ( bounds.p1.x - bounds.p0.x ) - px_scroll, 0.0f ) + _vec2( 1.0f );
  r.p1 = bounds.p0 + _vec2( ( bounds.p1.x - bounds.p0.x ), px_scroll ) - _vec2( 1.0f );
  return r;
}

Inl rectf32_t
GetScrollBtnDn(
  rectf32_t bounds,
  f32 px_scroll
  )
{
  rectf32_t r;
  r.p0 = bounds.p1 - _vec2( px_scroll ) + _vec2( 1.0f );
  r.p1 = bounds.p1 - _vec2( 1.0f );
  return r;
}

Inl rectf32_t
GetScrollBtnPos(
  f32 t_start,
  f32 t_end,
  rectf32_t bounds,
  f32 px_scroll
  )
{
  auto track_len = ( bounds.p1.y - bounds.p0.y ) - 3 * px_scroll;
  rectf32_t r;
  r.p0 = _vec2(
    bounds.p1.x - px_scroll + 1.0f,
    bounds.p0.y + px_scroll + track_len * t_start + 1.0f
    );
  r.p1 = _vec2(
    bounds.p1.x - 1.0f,
    bounds.p0.y + 2 * px_scroll + track_len * t_end - 1.0f
    );
  return r;
}

Inl rectf32_t
GetScrollTrack(
  rectf32_t bounds,
  f32 px_scroll
  )
{
  auto r = GetScrollBtnPos( 0.0f, 1.0f, bounds, px_scroll );
  return r;
}

Inl void
ScrollbarRender(
  array_t<f32>& stream,
  rectf32_t bounds,
  f32 t_start,
  f32 t_end,
  f32 z_bkgd,
  f32 z_btn,
  f32 px_scroll,
  vec4<f32> rgba_scroll_bkgd,
  vec4<f32> rgba_scroll_btn
  )
{
  RenderQuad(
    stream,
    rgba_scroll_bkgd,
    AlignRight( bounds, px_scroll ),
    bounds.p1,
    bounds,
    z_bkgd
    );

  auto btn_up = GetScrollBtnUp( bounds, px_scroll );
  RenderQuad(
    stream,
    rgba_scroll_btn,
    btn_up,
    bounds,
    z_btn
    );

  auto btn_dn = GetScrollBtnDn( bounds, px_scroll );
  RenderQuad(
    stream,
    rgba_scroll_btn,
    btn_dn,
    bounds,
    z_btn
    );

  auto btn_pos = GetScrollBtnPos( t_start, t_end, bounds, px_scroll );
  RenderQuad(
    stream,
    rgba_scroll_btn,
    btn_pos,
    bounds,
    z_btn
    );
}


void
TxtRender(
  txt_t& txt,
  bool& target_valid,
  array_t<f32>& stream,
  font_t& font,
  rectf32_t bounds,
  vec2<f32> zrange,
  f64 timestep_realtime,
  f64 timestep_fixed,
  bool draw_cursor,
  bool draw_cursorline,
  bool draw_cursorwordmatch,
  bool allow_scrollbar
  )
{
  ProfFunc();

  auto spaces_per_tab = GetPropFromDb( u8, u8_spaces_per_tab );

  auto line_h = FontLineH( font );
  auto timestep = MIN( timestep_realtime, timestep_fixed );

  auto rgba_text = GetPropFromDb( vec4<f32>, rgba_text );
  auto rgba_wordmatch_text = GetPropFromDb( vec4<f32>, rgba_wordmatch_text );
  auto rgba_wordmatch_bkgd = GetPropFromDb( vec4<f32>, rgba_wordmatch_bkgd );
  auto rgba_scroll_btn = GetPropFromDb( vec4<f32>, rgba_scroll_btn );

  auto scroll_animated = GetPropFromDb( bool, bool_scroll_animated );

  auto scroll_pct = GetPropFromDb( f32, f32_scroll_pct );
  auto px_scroll = MAX( 16.0f, Round32( scroll_pct * MinElem( bounds.p1 - bounds.p0 ) ) );

  auto px_space_advance = FontGetAdvance( font, ' ' );

  // figure out how many lines we can render, using the same spacing we will for real later.
  txt.window_n_lines = 0;
  kahan32_t y1 = { bounds.p0.y };
  while( y1.sum < bounds.p1.y ) { // PERF: integer space Ceil32 and a multiply should be sufficient, I just don't want to bother with precision issues right now.
    Add( y1, line_h );
    y1.sum = Ceil32( y1.sum );
    y1.err = 0;
    txt.window_n_lines += 1;
  }

  auto bof = GetBOF( txt.buf );
  auto eof = GetEOF( txt.buf );
  AssertCrash( LEqual( txt.scroll_start.y, eof ) );


  // vertical scrolling
  {
#if USE_SIMPLE_SCROLLING
    // we already determined scroll_start in MakeCursorVisible, and we're not doing animated
    // scrolling for now, since it makes things feel laggy.
    // so this is trivial; just compute scroll_end for scrollbar position rendering.
    txt.scroll_end = CursorLineD( txt.buf, txt.scroll_start.y, 0, txt.window_n_lines, 0, 0 );
#else

    Prof( TxtUpdateScrollingVertical );

    // ensure these are on line starts.
    txt.scroll_start.y = CursorStopAtNewlineL( txt.buf, txt.scroll_start.y, 0 );
    txt.scroll_target.y = CursorStopAtNewlineL( txt.buf, txt.scroll_target.y, 0 );

    // reduce fractional position to integer position.
    s32 target_dlines = Cast( s32, txt.scroll_target.frac );
    txt.scroll_target.frac -= target_dlines;
    if( target_dlines < 0 ) {
      txt.scroll_target.y = CursorLineU( txt.buf, txt.scroll_target.y, 0, -target_dlines, 0, 0 );
    } elif( target_dlines > 0 ) {
      txt.scroll_target.y = CursorLineD( txt.buf, txt.scroll_target.y, 0, target_dlines, 0, 0 );
    }

    scrollpos_t scroll_half = txt.scroll_start;
    scroll_half.frac += 0.5 * txt.window_n_lines;

    auto target_dist_yl = Min( txt.scroll_target.y, scroll_half.y );
    auto target_dist_yr = Max( txt.scroll_target.y, scroll_half.y );
    f64 target_dist_sign = Less( scroll_half.y, txt.scroll_target.y )  ?  1  :  -1;
    auto target_dist_nlines = CountLinesBetween( txt.buf, target_dist_yl, target_dist_yr );
    auto target_dist = target_dist_sign * Cast( f64, target_dist_nlines );
    target_dist += txt.scroll_target.frac - scroll_half.frac;

    // PERF: until we optimize line traversal, smooth scrolling large distances is too slow.
    // eg 0.6612 sec spent in CmdCursorGotoline, and 1.088 sec spent in TxtUpdateScrollingVertical here.
    // so, avoid the smooth scrolling by jumping straight to the destination.

    auto instantaneous =
      !scroll_animated  ||
      10.0 * txt.window_n_lines < ABS( target_dist );

    if( instantaneous ) {
      txt.scroll_start.frac += target_dist;

    } else {
      constant f64 mass = 1.0;
      constant f64 spring_k = 1000.0;
      static f64 friction_k = 2.2 * Sqrt64( mass * spring_k ); // 2 * Sqrt( m * k ) is critical damping, but we want a little overdamping.

      f64 force_spring = spring_k * target_dist;
      f64 force_fric = -friction_k * txt.scroll_vel.sum;
      f64 force = force_spring + force_fric;

      // TODO: solve ODE and use explicit soln.

      f64 accel = force / mass;
      f64 delta_vel = timestep * accel;
      Add( txt.scroll_vel, delta_vel );

      // snap to 0 for small velocities to minimize pixel jitter.
      if( ABS( txt.scroll_vel.sum ) <= 2.0f ) {
        txt.scroll_vel = {};
      }

      f64 delta_pos = timestep * txt.scroll_vel.sum;
      txt.scroll_start.frac += delta_pos;

      // invalidate cached target, since we know animation will require a re-render.
      if( ABS( txt.scroll_vel.sum ) > 1e-2f ) {
        target_valid = 0;
      }
    }

    auto eof_ln_start = CursorStopAtNewlineL( txt.buf, eof, 0 );
    bool at_bof = Equal( txt.scroll_start.y, bof );
    bool at_eof = Equal( txt.scroll_start.y, eof_ln_start );
    if( at_bof ) {
      txt.scroll_start.frac = MAX( txt.scroll_start.frac, -0.5 * txt.window_n_lines );
    }
    if( at_eof ) {
      txt.scroll_start.frac = MIN( txt.scroll_start.frac, 0.5 * txt.window_n_lines );
    }

    s32 to_scroll = Cast( s32, txt.scroll_start.frac );
    bool multi_line = !at_bof  ||  !at_eof;
    bool allow_bof_reduce = at_bof  &&  to_scroll > 0;
    bool allow_eof_reduce = at_eof  &&  to_scroll < 0;
    bool allow_mid_reduce = !at_bof  &&  !at_eof;
    bool allow_reduce = multi_line  &&  ( allow_bof_reduce | allow_eof_reduce | allow_mid_reduce );
    if( allow_reduce ) {
      // reduce fractional position to integer position.
      txt.scroll_start.frac -= to_scroll; // take only fractional part.

      if( to_scroll < 0 ) {
        txt.scroll_start.y = CursorLineU( txt.buf, txt.scroll_start.y, 0, -to_scroll, 0, 0 );
      } elif( to_scroll > 0 ) {
        txt.scroll_start.y = CursorLineD( txt.buf, txt.scroll_start.y, 0, to_scroll, 0, 0 );
      }
    }
#if 0
    // don't let scrolling go past first line or last line, fractionally.
    bool scroll_on_bof = ( !txt.scroll_start.y );
    bool scroll_on_eof = ( txt.scroll_start.y == eof_ln_start );
    if( scroll_on_bof ) {
      txt.scroll_start.frac = MAX( txt.scroll_start.frac, 0 );
      if( txt.scroll_vel < 0 ) {
        txt.scroll_vel = 0;
      }
    }
    if( scroll_on_eof ) {
      txt.scroll_start.frac = MIN( txt.scroll_start.frac, 0 );
      if( txt.scroll_vel > 0 ) {
        txt.scroll_vel = 0;
      }
    }
#endif

    auto scroll_end = CursorLineD( txt.buf, txt.scroll_start.y, 0, txt.window_n_lines + 1, 0, 0 );
    txt.scroll_end = CursorStopAtNewlineR( txt.buf, scroll_end, 0 );

    ProfClose( TxtUpdateScrollingVertical );
  }
#endif


  // render the scrollbar.
  if( allow_scrollbar  &&  ScrollbarVisible( bounds, px_scroll ) ) {
    auto t = GetScrollPos( txt );

    ScrollbarRender(
      stream,
      bounds,
      t.x,
      t.z,
      GetZ( zrange, txtlayer_t::scroll_bkgd ),
      GetZ( zrange, txtlayer_t::scroll_btn ),
      px_scroll,
      GetPropFromDb( vec4<f32>, rgba_scroll_bkgd ),
      rgba_scroll_btn
      );

    bounds.p1.x -= px_scroll;
  }


  // horizontal scrolling
  {
    Prof( TxtUpdateScrollingHorizontal );

    auto ln_start = CursorStopAtNewlineL( txt.buf, txt.c, 0 );
    auto temp = AllocContents( txt.buf, ln_start, txt.c );
    auto offset = LayoutString( font, spaces_per_tab, ML( temp ) );

    auto dim_x = ( bounds.p1.x - bounds.p0.x );
    if( offset > txt.scroll_x + 0.8f * dim_x ) {
      txt.scroll_x = offset - 0.8f * dim_x;
    } elif( offset < txt.scroll_x + 0.2f * dim_x ) {
      txt.scroll_x = MAX( 0, offset - 0.2f * dim_x );
    }
    Free( temp );

    ProfClose( TxtUpdateScrollingHorizontal );
  }


  // font layout
  {
    Prof( TxtLayout );

    FontClear( txt.layout );

    auto line_start = txt.scroll_start.y;
    line_start = CursorLineU( txt.buf, line_start, 0, 1, 0, 0 );

    u8 line[c_max_line_len];

    Forever {
      idx_t line_len;
      auto line_end = CursorStopAtNewlineR( txt.buf, line_start, &line_len );
      line_len = MIN( c_max_line_len, line_len ); // account for hard end-clipping
      Contents( txt.buf, line_start, line, line_len );

      if( line_len ) {
        // add the line text to the layout_t.
        FontAddLayoutLine(
          font,
          txt.layout,
          line,
          line_len,
          spaces_per_tab
          );
      }

      auto line_start_next = CursorSingleNewlineR( txt.buf, line_end, 0 );
      if( Equal( line_end, line_start_next ) | Greater( line_start_next, txt.scroll_end ) ) {
        break;
      }
      line_start = line_start_next;
    }
    ProfClose( TxtLayout );
  }

  // draw bkgd
  RenderQuad(
    stream,
    GetPropFromDb( vec4<f32>, rgba_text_bkgd ),
    bounds,
    GetZ( zrange, txtlayer_t::bkgd )
    );

  // =================================================================================
  //
  // OUTPUT

  Reserve( txt.linerects, txt.window_n_lines + 1 );
  txt.linerects.len = 0;

  auto word_l = CursorStopAtNonWordCharL( txt.buf, txt.c, 0 );
  auto word_r = CursorStopAtNonWordCharR( txt.buf, txt.c, 0 );
  auto word = AllocContents( txt.buf, word_l, word_r );

  f32 y0 = Cast( f32, -line_h * txt.scroll_start.frac );

  kahan32_t x;
  kahan32_t y = { y0 };

  auto line_start = txt.scroll_start.y;
  line_start = CursorLineU( txt.buf, line_start, 0, 1, 0, 0 );

  // don't actually offset for the additional line above, if there is one.
  if( !Equal( line_start, txt.scroll_start.y ) ) {
    Sub( y, line_h );
  }
  y.sum = Ceil32( y.sum );
  y.err = 0;

  // layout_t doesn't store empty lines, so we have to skip them when looking up the layout info.
  idx_t layout_line_idx = 0;

  Forever {
    idx_t line_len;
    auto line_end = CursorStopAtNewlineR( txt.buf, line_start, &line_len );
    line_len = MIN( c_max_line_len, line_len ); // account for hard end-clipping

    // WARNING!!!
    // line_end is potentially past what we'll layout and draw!
    // see the clamp to c_max_line_len.

    x = { 0 - txt.scroll_x };

    // draw cursorline.
    if( draw_cursorline ) {
      if( LEqual( line_start, txt.c ) & LEqual( txt.c, line_end ) ) {
        RenderQuad(
          stream,
          GetPropFromDb( vec4<f32>, rgba_cursorline_bkgd ),
          _vec2( bounds.p0.x, bounds.p0.y + y.sum ),
          _vec2( bounds.p1.x, bounds.p0.y + y.sum + line_h ),
          bounds,
          GetZ( zrange, txtlayer_t::cursorline )
          );
      }
    }

    // emit linerect for later mouse code.
    {
      // PERF: could save some cycles by comparing in origin-relative space.
      auto linerect = AddBack( txt.linerects );
      linerect->p0 = _vec2( bounds.p0.x, bounds.p0.y + y.sum ),
      linerect->p1 = _vec2( bounds.p1.x, bounds.p0.y + y.sum + line_h ),
      linerect->line_start = line_start;
    }

    // draw line text.
    if( line_len ) {

      if( draw_cursorwordmatch  &&  word.len ) {

        auto linepos = bounds.p0 + _vec2( x.sum, y.sum );

        array_t<txt_wordspan_t> spans;
        Alloc( spans, 64 );
        {
          txt_wordspan_t span;
          span.l = line_start;
          span.r = span.l;
          span.is_ident = 0;

          Forever {
            if( CountCharsBetween( txt.buf, line_start, span.l ) >= line_len ) {
              AssertCrash( spans.len );
              auto lastspan = spans.mem + spans.len - 1;
              auto clipped_line_end = CursorCharR( txt.buf, line_start, line_len, 0 );
              lastspan->l = Min( lastspan->l, clipped_line_end );
              lastspan->r = Min( lastspan->r, clipped_line_end );
              break;
            }
            span.r = CursorStopAtNonWordCharR( txt.buf, span.l, 0 );

            if( !Equal( span.l, span.r ) ) {
              span.is_ident = 1;
              *AddBack( spans ) = span;
              span.l = span.r;
              span.is_ident = 0;

            } else {
              auto sr = span.l;
              Forever {
                if( Equal( sr, line_end ) ) {
                  span.r = sr;
                  break;
                }
                sr = CursorCharR( txt.buf, sr, 1, 0 );
                span.r = CursorStopAtNonWordCharR( txt.buf, sr, 0 );
                if( !Equal( sr, span.r ) ) {
                  span.r = sr;
                  break;
                }
              }
              *AddBack( spans ) = span;
              span.l = span.r;
              span.is_ident = 1;
            }
          }
        }

        auto match_start_x = x;
        ForLen( i, spans ) {

          auto span = spans.mem + i;
          auto span_len = CountBytesBetween( txt.buf, span->l, span->r );
          AssertWarn( span_len );
          auto tmp = MemHeapAlloc( u8, span_len );
          Contents( txt.buf, span->l, tmp, span_len );
          bool is_match = 0;
          if( span->is_ident ) {
            is_match = MemEqual( tmp, span_len, ML( word ) );
          }
          MemHeapFree( tmp );

          vec4<f32> color;
          if( is_match ) {
            color = rgba_wordmatch_text;
          } else {
            color = rgba_text;
          }

          auto char_offset = CountCharsBetween( txt.buf, line_start, span->l );

          if( c_max_line_len <= char_offset ) {
            break;
          }

          auto char_len = MIN( span_len, c_max_line_len - char_offset );

          auto advance_x = FontSumAdvances(
            txt.layout,
            layout_line_idx,
            char_offset,
            char_len
            );

          // draw match background quad
          if( is_match ) {
            RenderQuad(
              stream,
              rgba_wordmatch_bkgd,
              bounds.p0 + _vec2( match_start_x.sum, y.sum ),
              bounds.p0 + _vec2( match_start_x.sum + advance_x, y.sum + line_h ),
              bounds,
              GetZ( zrange, txtlayer_t::match )
              );
          }

          // draw text.
          RenderText(
            stream,
            font,
            txt.layout,
            linepos,
            GetZ( zrange, txtlayer_t::txt ),
            bounds,
            color,
            layout_line_idx,
            char_offset,
            char_len
            );

          // horizontal advance.
          Add( match_start_x, advance_x );
        }
        Free( spans );

      } else { // !draw_cursorwordmatch
        RenderText(
          stream,
          font,
          txt.layout,
          bounds.p0 + _vec2( x.sum, y.sum ),
          GetZ( zrange, txtlayer_t::txt ),
          bounds,
          rgba_text,
          layout_line_idx,
          0,
          line_len
          );
      }
    } // end if( line_len )

    // draw selection.
    TxtRenderSelection(
      txt,
      stream,
      bounds,
      line_start,
      line_end,
      px_space_advance,
      line_len,
      layout_line_idx,
      x.sum,
      y.sum,
      GetZ( zrange, txtlayer_t::sel ),
      line_h
      );

    // draw cursor.
    if( draw_cursor ) {
      TxtRenderCursor(
        txt,
        stream,
        bounds,
        line_start,
        line_end,
        px_space_advance,
        line_len,
        layout_line_idx,
        x.sum,
        y.sum,
        GetZ( zrange, txtlayer_t::cur ),
        line_h
        );
    } // end if( draw_cursor )

    // line advance.
    Add( y, line_h );
    y.sum = Ceil32( y.sum );
    y.err = 0;

    if( line_len ) {
      layout_line_idx += 1;
    }

    auto line_start_next = CursorSingleNewlineR( txt.buf, line_end, 0 );
    if( Equal( line_end, line_start_next )  ||  Greater( line_start_next, txt.scroll_end ) ) {
      break;
    }
    line_start = line_start_next;
  }

  Free( word );
}



// TXT INPUTS -> OPERATIONS DISPATCH.
//

Inl content_ptr_t
MapMouseToCursor(
  txt_t& txt,
  rectf32_t bounds,
  vec2<s32> m
  )
{
  auto c = txt.scroll_start.y;

  // PERF: could save some cycles by comparing in origin-relative space.
  f32 min_distance = MAX_f32;
  ForLen( i, txt.linerects ) {
    auto linerect = txt.linerects.mem + i;
    auto mp = _vec2( Cast( f32, m.x ), Cast( f32, m.y ) );
    if( PtInBox( mp, linerect->p0, linerect->p1, 0.001f ) ) {
      c = linerect->line_start;
      break;
    }
    auto distance = DistanceToBox( mp, linerect->p0, linerect->p1 );
    if( distance < min_distance ) {
      min_distance = distance;
      c = linerect->line_start;
    }
  }

  return c;

// TODO: x dimension

//#if 1
//  idx_t cx = 0;
//#else
//
//#if 1
//  f32 x_frac = ( m.x - origin.x + px_click_correct.x ) / Cast( f32, char_w );
//  auto cx = Cast( idx_t, x_frac );
//#else
//  f32 x_frac = ( m.x - origin.x + px_click_correct.x ) / dim.x;
//  x_frac = CLAMP( x_frac, 0, 1 );
//  auto nchars_screen_max = Cast( idx_t, dim.x / font.char_w );
//  auto cx = Cast( idx_t, x_frac * nchars_screen_max );
//#endif
//
//#endif
//
//  auto line_end = CursorStopAtNewlineR( txt.buf, c, 0 );
//  c = MIN( c + cx, line_end );
//
//  return c;
}

Inl void
SetScrollPosFraction(
  txt_t& txt,
  f32 t
  )
{
  auto p = Round_idx_from_f32( t * TxtLen( txt ) );
  auto pos = CursorCharR( txt.buf, GetBOF( txt.buf ), p, 0 );

#if USE_SIMPLE_SCROLLING
  auto center = CursorStopAtNewlineL( txt.buf, pos, 0 );
  txt.scroll_start.y = CursorLineU( txt.buf, center, 0, txt.window_n_lines / 2, 0, 0 );
  txt.scroll_start.frac = 0;
#else
  txt.scroll_target.y = CursorStopAtNewlineL( txt.buf, pos, 0 );
  txt.scroll_target.frac = 0;
#endif
}

void
TxtControlMouse(
  txt_t& txt,
  bool& target_valid,
  font_t& font,
  rectf32_t bounds,
  glwmouseevent_t type,
  glwmousebtn_t btn,
  bool* alreadydn,
  bool* keyalreadydn,
  vec2<s32> m,
  vec2<s32> raw_delta,
  s32 dwheel,
  bool allow_scrollbar
  )
{
  ProfFunc();

  auto px_click_correct = _vec2<s8>(); // TODO: mouse control.
  auto scroll_nlines = GetPropFromDb( u8, u8_scroll_nlines );
  auto scroll_sign = GetPropFromDb( s8, s8_scroll_sign );
//  auto dblclick_period_sec = GetPropFromDb( f64, f64_dblclick_period_sec );
  auto scroll_continuous = GetPropFromDb( bool, bool_scroll_continuous );
  auto scroll_continuous_sensitivity = GetPropFromDb( f64, f64_scroll_continuous_sensitivity );

  auto scroll_pct = GetPropFromDb( f32, f32_scroll_pct );
  auto px_scroll = MAX( 16.0f, Round32( scroll_pct * MinElem( bounds.p1 - bounds.p0 ) ) );

  auto keymods = GlwKeyModifiersDown();
  bool mod_isdn = AnyDown( keymods );

  bool has_scrollbar = ScrollbarVisible( bounds, px_scroll );

  auto bounds_contents = bounds;
  if( has_scrollbar ) {
    bounds_contents.p1.x -= px_scroll;
  }

  if( has_scrollbar ) {

    auto btn_up = GetScrollBtnUp( bounds, px_scroll );
    auto btn_dn = GetScrollBtnDn( bounds, px_scroll );
    auto scroll_pos = GetScrollPos( txt );
    auto btn_pos = GetScrollBtnPos( scroll_pos.x, scroll_pos.z, bounds, px_scroll );

#if USE_SIMPLE_SCROLLING
    f32 t = CLAMP( EstimateLinearPos( txt, txt.scroll_start.y ), 0, 1 );
#else
    f32 t = CLAMP( EstimateLinearPos( txt, txt.scroll_target.y ), 0, 1 );
#endif

    if( GlwMouseInsideRect( m, btn_up ) ) {
      switch( type ) {
        case glwmouseevent_t::dn: break;
        case glwmouseevent_t::up: {
          SetScrollPosFraction( txt, CLAMP( t - 0.1f, 0, 1 ) );
          target_valid = 0;
        } break;
        case glwmouseevent_t::move: break;
        case glwmouseevent_t::wheelmove: break;
        default: UnreachableCrash();
      }

    } elif( GlwMouseInsideRect( m, btn_dn ) ) {
      switch( type ) {
        case glwmouseevent_t::dn: break;
        case glwmouseevent_t::up: {
          SetScrollPosFraction( txt, CLAMP( t + 0.1f, 0, 1 ) );
          target_valid = 0;
        } break;
        case glwmouseevent_t::move: break;
        case glwmouseevent_t::wheelmove: break;
        default: UnreachableCrash();
      }

    } elif( GlwMouseInsideRect( m, btn_pos ) ) {
      // scrollbar rect interactivity.
      switch( type ) {
        case glwmouseevent_t::dn: {
          txt.scroll_grabbed = 1;
        } break;
        case glwmouseevent_t::up: break;
        case glwmouseevent_t::move: break;
        case glwmouseevent_t::wheelmove: break;
        default: UnreachableCrash();
      }
    }
  }

  if( GlwMouseInsideRect( m, bounds_contents ) ) {
    if( type == glwmouseevent_t::dn  &&  btn == glwmousebtn_t::l ) {
      txt.text_grabbed = 1;
      auto c_pre_move = txt.c;
      auto c_move = MapMouseToCursor(
        txt,
        bounds,
        m
        );

      if( keymods.ctrl ) {
        auto l = CursorStopAtNonWordCharL( txt.buf, c_move, 0 );
        auto r = CursorStopAtNonWordCharR( txt.buf, c_move, 0 );
        if( !Equal( l, r ) ) {
          txt.seltype = seltype_t::s;
          txt.c = r;
          txt.s = l;
        } else {
          txt.c = c_move;
        }
      } else {
        if( SelectIsZero( txt ) ) {
          if( keymods.shift ) {
            txt.seltype = seltype_t::s;
            txt.s = c_pre_move;
            txt.c = c_move;
          } else {
            txt.c = c_move;
          }
        } else {
          if( keymods.shift ) {
            txt.c = c_move;
          } else {
            txt.seltype = seltype_t::none;
            txt.c = c_move;
          }
        }
      }
      ResetCInline( txt );
      target_valid = 0;

      //// TODO: handle interaction with C,S,A
      //bool same_cursor = ( c_move == txt.dblclick.first_cursor );
      //bool double_click = And( txt.dblclick.first_made, same_cursor );
      //if( double_click ) {
      //  u64 curr_clock = TimeClock();
      //  f64 dblclick_period = TimeSecFromClocks64( txt.dblclick.first_clock, curr_clock );
      //  if( dblclick_period <= dblclick_period_sec ) {
      //    CmdSelectWordAtCursor( txt );
      //    txt.dblclick.first_made = 0;
      //  } else {
      //    txt.dblclick.first_clock = TimeClock();
      //  }
      //} else {
      //  txt.dblclick.first_made = 1;
      //  txt.dblclick.first_clock = TimeClock();
      //  txt.dblclick.first_cursor = c_move;
      //}
    }
  }

  switch( type ) {
    case glwmouseevent_t::dn: break;

    case glwmouseevent_t::up: {
      if( txt.scroll_grabbed ) {
        txt.scroll_grabbed = 0;
      }
      if( txt.text_grabbed ) {
        txt.text_grabbed = 0;
      }
      // clear all interactivity state.
      txt.dblclick.first_made = 0;
    } break;

    case glwmouseevent_t::move: {
      if( txt.scroll_grabbed ) {
        auto scroll_track = GetScrollTrack( bounds, px_scroll );
        auto my = CLAMP( Cast( f32, m.y ), scroll_track.p0.y, scroll_track.p1.y );
        auto t = Lerp_from_f32( 0.0f, 1.0f, my, scroll_track.p0.y, scroll_track.p1.y );
        SetScrollPosFraction( txt, CLAMP( t, 0, 1 ) );
        target_valid = 0;
        printf( "move_grabbed %f, %f\n", my, t );
      }
      if( txt.text_grabbed ) {
        auto c_pre_move = txt.c;
        auto c_move = MapMouseToCursor(
          txt,
          bounds,
          m
          );

        if( !Equal( c_move, txt.c )  &&  !keymods.ctrl ) {
          if( SelectIsZero( txt ) ) {
            if( !Equal( c_pre_move, c_move ) ) {
              txt.seltype = seltype_t::s;
              txt.s = c_pre_move;
              txt.c = c_move;
              ResetCInline( txt );
            }
          } else {
            if( !Equal( c_pre_move, c_move ) ) {
              txt.c = c_move;
              ResetCInline( txt );
            }
          }
        }
        target_valid = 0;
      }
    } break;

    case glwmouseevent_t::wheelmove: {
      if( GlwMouseInsideRect( m, bounds )  &&  dwheel  &  ( !mod_isdn ) ) {
        dwheel *= scroll_sign;
#if USE_SIMPLE_SCROLLING
        dwheel *= scroll_nlines;
        if( dwheel >= 0 ) {
          txt.scroll_start.y = CursorLineD( txt.buf, txt.scroll_start.y, 0, Cast( idx_t, dwheel ), 0, 0 );
        } else {
          txt.scroll_start.y = CursorLineU( txt.buf, txt.scroll_start.y, 0, Cast( idx_t, -dwheel ), 0, 0 );
        }
#else
        if( scroll_continuous ) {
          txt.scroll_target.frac += scroll_continuous_sensitivity * dwheel;
        } else {
          dwheel *= scroll_nlines;
          txt.scroll_target.frac += dwheel;
        }
#endif
        target_valid = 0;
      }
    } break;

    default: UnreachableCrash();
  }
}


// TODO: combine keybinds and cmdmap ?

struct
txt_cmdmap_t
{
  glwkeybind_t keybind;
  pfn_txtcmd_t fn;
  idx_t misc;
  idx_t misc2;
};

Inl txt_cmdmap_t
_txtcmdmap(
  glwkeybind_t keybind,
  pfn_txtcmd_t fn,
  idx_t misc = 0,
  idx_t misc2 = 0
  )
{
  txt_cmdmap_t r;
  r.keybind = keybind;
  r.fn = fn;
  r.misc = misc;
  r.misc2 = misc2;
  return r;
}


void
TxtControlKeyboardType(
  txt_t& txt,
  bool& target_valid,
  bool& content_changed,
  bool& ran_cmd,
  glwkeyevent_t type,
  glwkey_t key,
  glwkeylocks_t& keylocks,
  bool* alreadydn,
  bool allow_ln_add
  )
{
  ProfFunc();

  switch( type ) {
    case glwkeyevent_t::dn:
    case glwkeyevent_t::repeat: {

      bool caps_lock = keylocks.caps;
      txt_cmdmap_t table[] = {
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_a ), CmdAddAlpha , 'a' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_b ), CmdAddAlpha , 'b' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_c ), CmdAddAlpha , 'c' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_d ), CmdAddAlpha , 'd' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_e ), CmdAddAlpha , 'e' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_f ), CmdAddAlpha , 'f' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_g ), CmdAddAlpha , 'g' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_h ), CmdAddAlpha , 'h' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_i ), CmdAddAlpha , 'i' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_j ), CmdAddAlpha , 'j' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_k ), CmdAddAlpha , 'k' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_l ), CmdAddAlpha , 'l' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_m ), CmdAddAlpha , 'm' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_n ), CmdAddAlpha , 'n' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_o ), CmdAddAlpha , 'o' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_p ), CmdAddAlpha , 'p' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_q ), CmdAddAlpha , 'q' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_r ), CmdAddAlpha , 'r' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_s ), CmdAddAlpha , 's' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_t ), CmdAddAlpha , 't' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_u ), CmdAddAlpha , 'u' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_v ), CmdAddAlpha , 'v' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_w ), CmdAddAlpha , 'w' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_x ), CmdAddAlpha , 'x' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_y ), CmdAddAlpha , 'y' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_z ), CmdAddAlpha , 'z' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_A ), CmdAddAlpha , 'A' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_B ), CmdAddAlpha , 'B' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_C ), CmdAddAlpha , 'C' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_D ), CmdAddAlpha , 'D' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_E ), CmdAddAlpha , 'E' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_F ), CmdAddAlpha , 'F' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_G ), CmdAddAlpha , 'G' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_H ), CmdAddAlpha , 'H' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_I ), CmdAddAlpha , 'I' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_J ), CmdAddAlpha , 'J' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_K ), CmdAddAlpha , 'K' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_L ), CmdAddAlpha , 'L' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_M ), CmdAddAlpha , 'M' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_N ), CmdAddAlpha , 'N' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_O ), CmdAddAlpha , 'O' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_P ), CmdAddAlpha , 'P' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_Q ), CmdAddAlpha , 'Q' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_R ), CmdAddAlpha , 'R' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_S ), CmdAddAlpha , 's' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_T ), CmdAddAlpha , 'T' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_U ), CmdAddAlpha , 'U' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_V ), CmdAddAlpha , 'V' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_W ), CmdAddAlpha , 'W' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_X ), CmdAddAlpha , 'X' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_Y ), CmdAddAlpha , 'Y' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_Z ), CmdAddAlpha , 'Z' , !caps_lock ),

        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_0 ), CmdAddChar , '0' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_1 ), CmdAddChar , '1' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_2 ), CmdAddChar , '2' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_3 ), CmdAddChar , '3' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_4 ), CmdAddChar , '4' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_5 ), CmdAddChar , '5' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_6 ), CmdAddChar , '6' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_7 ), CmdAddChar , '7' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_8 ), CmdAddChar , '8' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_9 ), CmdAddChar , '9' ),

        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_space           ), CmdAddChar , ' '  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_tilde           ), CmdAddChar , '~'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_graveaccent     ), CmdAddChar , '`'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_exclamation     ), CmdAddChar , '!'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_atsign          ), CmdAddChar , '@'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_pound           ), CmdAddChar , '#'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_dollar          ), CmdAddChar , '$'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_percent         ), CmdAddChar , '%'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_caret           ), CmdAddChar , '^'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_ampersand       ), CmdAddChar , '&'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_star            ), CmdAddChar , '*'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_paren_l         ), CmdAddChar , '('  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_paren_r         ), CmdAddChar , ')'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_minus           ), CmdAddChar , '-'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_underscore      ), CmdAddChar , '_'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_plus            ), CmdAddChar , '+'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_equals          ), CmdAddChar , '='  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketsquare_l ), CmdAddChar , '['  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketsquare_r ), CmdAddChar , ']'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketcurly_l  ), CmdAddChar , '{'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketcurly_r  ), CmdAddChar , '}'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketangle_l  ), CmdAddChar , '<'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketangle_r  ), CmdAddChar , '>'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_slashback       ), CmdAddChar , '\\' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_slashforw       ), CmdAddChar , '/'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_verticalbar     ), CmdAddChar , '|'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_semicolon       ), CmdAddChar , ';'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_colon           ), CmdAddChar , ':'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_quotesingle     ), CmdAddChar , '\'' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_quotedouble     ), CmdAddChar , '"'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_comma           ), CmdAddChar , ','  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_period          ), CmdAddChar , '.'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_question        ), CmdAddChar , '?'  ),

        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_tab_r      ), CmdTabR     ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_ch_l   ), CmdRemChL   ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_word_l ), CmdRemWordL ),
      };
      ForEach( entry, table ) {
        if( GlwKeybind( key, entry.keybind ) ) {
          entry.fn( txt, entry.misc, entry.misc2 );
          target_valid = 0;
          content_changed = 1;
          ran_cmd = 1;
        }
      }

      if( allow_ln_add ) {
        if( GlwKeybind( key, GetPropFromDb( glwkeybind_t, keybind_txt_modal_ln_add ) ) ) {
          CmdAddLn( txt, 0, 0 );
          target_valid = 0;
          content_changed = 1;
          ran_cmd = 1;
        }
      }

      bool num_lock = keylocks.num;
      if( num_lock ) {
        txt_cmdmap_t numpadtable[] = {
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_div     ), CmdAddChar , '/' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_mul     ), CmdAddChar , '*' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_sub     ), CmdAddChar , '-' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_add     ), CmdAddChar , '+' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_decimal ), CmdAddChar , '.' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_0       ), CmdAddChar , '0' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_1       ), CmdAddChar , '1' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_2       ), CmdAddChar , '2' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_3       ), CmdAddChar , '3' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_4       ), CmdAddChar , '4' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_5       ), CmdAddChar , '5' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_6       ), CmdAddChar , '6' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_7       ), CmdAddChar , '7' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_8       ), CmdAddChar , '8' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_9       ), CmdAddChar , '9' ),
        };
        ForEach( entry, numpadtable ) {
          if( GlwKeybind( key, entry.keybind ) ) {
            entry.fn( txt, entry.misc, entry.misc2 );
            target_valid = 0;
            content_changed = 1;
            ran_cmd = 1;
          }
        }
      }

    } break;

    case glwkeyevent_t::up: {
    } break;

    default: UnreachableCrash();
  }
}

void
TxtControlKeyboardTypeNotModal(
  txt_t& txt,
  bool& target_valid,
  bool& content_changed,
  bool& ran_cmd,
  glwkeyevent_t type,
  glwkey_t key,
  glwkeylocks_t& keylocks,
  bool allow_ln_add
  )
{
  ProfFunc();

  switch( type ) {
    case glwkeyevent_t::dn:
    case glwkeyevent_t::repeat: {

      bool caps_lock = keylocks.caps;
      txt_cmdmap_t table[] = {
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_a ), CmdAddAlpha , 'a' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_b ), CmdAddAlpha , 'b' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_c ), CmdAddAlpha , 'c' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_d ), CmdAddAlpha , 'd' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_e ), CmdAddAlpha , 'e' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_f ), CmdAddAlpha , 'f' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_g ), CmdAddAlpha , 'g' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_h ), CmdAddAlpha , 'h' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_i ), CmdAddAlpha , 'i' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_j ), CmdAddAlpha , 'j' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_k ), CmdAddAlpha , 'k' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_l ), CmdAddAlpha , 'l' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_m ), CmdAddAlpha , 'm' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_n ), CmdAddAlpha , 'n' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_o ), CmdAddAlpha , 'o' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_p ), CmdAddAlpha , 'p' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_q ), CmdAddAlpha , 'q' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_r ), CmdAddAlpha , 'r' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_s ), CmdAddAlpha , 's' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_t ), CmdAddAlpha , 't' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_u ), CmdAddAlpha , 'u' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_v ), CmdAddAlpha , 'v' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_w ), CmdAddAlpha , 'w' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_x ), CmdAddAlpha , 'x' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_y ), CmdAddAlpha , 'y' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_z ), CmdAddAlpha , 'z' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_A ), CmdAddAlpha , 'A' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_B ), CmdAddAlpha , 'B' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_C ), CmdAddAlpha , 'C' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_D ), CmdAddAlpha , 'D' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_E ), CmdAddAlpha , 'E' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_F ), CmdAddAlpha , 'F' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_G ), CmdAddAlpha , 'G' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_H ), CmdAddAlpha , 'H' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_I ), CmdAddAlpha , 'I' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_J ), CmdAddAlpha , 'J' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_K ), CmdAddAlpha , 'K' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_L ), CmdAddAlpha , 'L' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_M ), CmdAddAlpha , 'M' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_N ), CmdAddAlpha , 'N' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_O ), CmdAddAlpha , 'O' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_P ), CmdAddAlpha , 'P' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_Q ), CmdAddAlpha , 'Q' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_R ), CmdAddAlpha , 'R' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_S ), CmdAddAlpha , 's' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_T ), CmdAddAlpha , 'T' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_U ), CmdAddAlpha , 'U' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_V ), CmdAddAlpha , 'V' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_W ), CmdAddAlpha , 'W' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_X ), CmdAddAlpha , 'X' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_Y ), CmdAddAlpha , 'Y' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_Z ), CmdAddAlpha , 'Z' , !caps_lock ),

        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_0 ), CmdAddChar , '0' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_1 ), CmdAddChar , '1' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_2 ), CmdAddChar , '2' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_3 ), CmdAddChar , '3' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_4 ), CmdAddChar , '4' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_5 ), CmdAddChar , '5' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_6 ), CmdAddChar , '6' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_7 ), CmdAddChar , '7' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_8 ), CmdAddChar , '8' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_9 ), CmdAddChar , '9' ),

        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_space           ), CmdAddChar , ' '  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_tilde           ), CmdAddChar , '~'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_graveaccent     ), CmdAddChar , '`'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_exclamation     ), CmdAddChar , '!'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_atsign          ), CmdAddChar , '@'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_pound           ), CmdAddChar , '#'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_dollar          ), CmdAddChar , '$'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_percent         ), CmdAddChar , '%'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_caret           ), CmdAddChar , '^'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_ampersand       ), CmdAddChar , '&'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_star            ), CmdAddChar , '*'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_paren_l         ), CmdAddChar , '('  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_paren_r         ), CmdAddChar , ')'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_minus           ), CmdAddChar , '-'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_underscore      ), CmdAddChar , '_'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_plus            ), CmdAddChar , '+'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_equals          ), CmdAddChar , '='  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketsquare_l ), CmdAddChar , '['  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketsquare_r ), CmdAddChar , ']'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketcurly_l  ), CmdAddChar , '{'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketcurly_r  ), CmdAddChar , '}'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketangle_l  ), CmdAddChar , '<'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketangle_r  ), CmdAddChar , '>'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_slashback       ), CmdAddChar , '\\' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_slashforw       ), CmdAddChar , '/'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_verticalbar     ), CmdAddChar , '|'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_semicolon       ), CmdAddChar , ';'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_colon           ), CmdAddChar , ':'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_quotesingle     ), CmdAddChar , '\'' ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_quotedouble     ), CmdAddChar , '"'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_comma           ), CmdAddChar , ','  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_period          ), CmdAddChar , '.'  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_question        ), CmdAddChar , '?'  ),

        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_tab_r      ), CmdTabR     ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_rem_ch_l   ), CmdRemChL   ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_rem_word_l ), CmdRemWordL ),
      };
      ForEach( entry, table ) {
        if( GlwKeybind( key, entry.keybind ) ) {
          entry.fn( txt, entry.misc, entry.misc2 );
          target_valid = 0;
          content_changed = 1;
          ran_cmd = 1;
        }
      }

      if( allow_ln_add ) {
        if( GlwKeybind( key, GetPropFromDb( glwkeybind_t, keybind_txt_ln_add ) ) ) {
          CmdAddLn( txt, 0, 0 );
          target_valid = 0;
          content_changed = 1;
          ran_cmd = 1;
        }
      }

      bool num_lock = keylocks.num;
      if( num_lock ) {
        txt_cmdmap_t numpadtable[] = {
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_div     ), CmdAddChar , '/' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_mul     ), CmdAddChar , '*' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_sub     ), CmdAddChar , '-' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_add     ), CmdAddChar , '+' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_decimal ), CmdAddChar , '.' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_0       ), CmdAddChar , '0' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_1       ), CmdAddChar , '1' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_2       ), CmdAddChar , '2' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_3       ), CmdAddChar , '3' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_4       ), CmdAddChar , '4' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_5       ), CmdAddChar , '5' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_6       ), CmdAddChar , '6' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_7       ), CmdAddChar , '7' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_8       ), CmdAddChar , '8' ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_9       ), CmdAddChar , '9' ),
        };
        ForEach( entry, numpadtable ) {
          if( GlwKeybind( key, entry.keybind ) ) {
            entry.fn( txt, entry.misc, entry.misc2 );
            target_valid = 0;
            content_changed = 1;
            ran_cmd = 1;
          }
        }
      }

    } break;

    case glwkeyevent_t::up: {
    } break;

    default: UnreachableCrash();
  }
}


void
TxtControlKeyboardNoContentChange(
  txt_t& txt,
  bool kb_command,
  bool& target_valid,
  bool& ran_cmd,
  glwkeyevent_t type,
  glwkey_t key,
  glwkeylocks_t& keylocks,
  bool* alreadydn
  )
{
  ProfFunc();

  if( kb_command ) {
    switch( type ) {
      case glwkeyevent_t::dn:
      case glwkeyevent_t::repeat: {
        txt_cmdmap_t table[] = {
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_copy                ), CmdCopy              ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cs_undo             ), CmdCsUndo            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cs_redo             ), CmdCsRedo            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_toggle_insertmode   ), CmdToggleInsertMode  ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_l            ), CmdCursorL           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_r            ), CmdCursorR           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_u            ), CmdCursorU           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_d            ), CmdCursorD           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_home         ), CmdCursorHome        ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_end          ), CmdCursorEnd         ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_page_d       ), CmdCursorJumpD       , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_page_u       ), CmdCursorJumpU       , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_skip_l       ), CmdCursorSkipL       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_skip_r       ), CmdCursorSkipR       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_l            ), CmdSelectL           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_r            ), CmdSelectR           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_u            ), CmdSelectU           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_d            ), CmdSelectD           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_home         ), CmdSelectHome        ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_end          ), CmdSelectEnd         ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_page_d       ), CmdSelectJumpD       , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_page_u       ), CmdSelectJumpU       , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_skip_l       ), CmdSelectSkipL       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_skip_r       ), CmdSelectSkipR       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_all          ), CmdSelectAll         ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_scroll_u            ), CmdScrollU           , Cast( idx_t, GetPropFromDb( f32, f32_lines_per_jump ) ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_scroll_d            ), CmdScrollD           , Cast( idx_t, GetPropFromDb( f32, f32_lines_per_jump ) ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_scroll_page_u       ), CmdScrollU           , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_scroll_page_d       ), CmdScrollD           , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_make_present ), CmdCursorMakePresent ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_multicursor_u       ), CmdMultiCursorU      ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_multicursor_d       ), CmdMultiCursorD      ),
        };
        ForEach( entry, table ) {
          if( GlwKeybind( key, entry.keybind ) ) {
            entry.fn( txt, entry.misc, entry.misc2 );
            target_valid = 0;
            ran_cmd = 1;
          }
        }
      } break;

      case glwkeyevent_t::up: {
      } break;

      default: UnreachableCrash();
    }
  }
}

void
TxtControlKeyboard(
  txt_t& txt,
  bool kb_command,
  bool& target_valid,
  bool& content_changed,
  bool& ran_cmd,
  glwkeyevent_t type,
  glwkey_t key,
  glwkeylocks_t& keylocks,
  bool* alreadydn
  )
{
  ProfFunc();

  if( kb_command ) {
    switch( type ) {
      case glwkeyevent_t::dn:
      case glwkeyevent_t::repeat: {
        txt_cmdmap_t table_contentchange[] = {
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cut                 ), CmdCut                ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_paste               ), CmdPaste              ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_txt_undo            ), CmdTxtUndo            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_txt_redo            ), CmdTxtRedo            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_tab_r               ), CmdTabR               ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_tab_l               ), CmdTabL               ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_ch_l            ), CmdRemChL             ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_ch_r            ), CmdRemChR             ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_word_l          ), CmdRemWordL           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_word_r          ), CmdRemWordR           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_line_r          ), CmdRemLineR           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_comment_selection   ), CmdCommentSelection   ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_uncomment_selection ), CmdUncommentSelection ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_ln_add              ), CmdAddLn              ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_ln_rem              ), CmdRemLn              ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_ln_comment          ), CmdComment            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_ln_uncomment        ), CmdUncomment          ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_ln_comment_toggle   ), CmdToggleComment      ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_ln_permute_u        ), CmdPermuteU           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_ln_permute_d        ), CmdPermuteD           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_trailspace      ), CmdRemTrailspace      ),
        };
        ForEach( entry, table_contentchange ) {
          if( GlwKeybind( key, entry.keybind ) ) {
            entry.fn( txt, entry.misc, entry.misc2 );
            target_valid = 0;
            content_changed = 1;
            ran_cmd = 1;
          }
        }

        txt_cmdmap_t table[] = {
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_copy                ), CmdCopy              ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cs_undo             ), CmdCsUndo            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cs_redo             ), CmdCsRedo            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_toggle_insertmode   ), CmdToggleInsertMode  ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_l            ), CmdCursorL           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_r            ), CmdCursorR           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_u            ), CmdCursorU           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_d            ), CmdCursorD           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_home         ), CmdCursorHome        ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_end          ), CmdCursorEnd         ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_page_d       ), CmdCursorJumpD       , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_page_u       ), CmdCursorJumpU       , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_skip_l       ), CmdCursorSkipL       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_skip_r       ), CmdCursorSkipR       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_l            ), CmdSelectL           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_r            ), CmdSelectR           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_u            ), CmdSelectU           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_d            ), CmdSelectD           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_home         ), CmdSelectHome        ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_end          ), CmdSelectEnd         ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_page_d       ), CmdSelectJumpD       , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_page_u       ), CmdSelectJumpU       , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_skip_l       ), CmdSelectSkipL       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_skip_r       ), CmdSelectSkipR       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_all          ), CmdSelectAll         ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_scroll_u            ), CmdScrollU           , Cast( idx_t, GetPropFromDb( f32, f32_lines_per_jump ) ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_scroll_d            ), CmdScrollD           , Cast( idx_t, GetPropFromDb( f32, f32_lines_per_jump ) ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_scroll_page_u       ), CmdScrollU           , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_scroll_page_d       ), CmdScrollD           , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_make_present ), CmdCursorMakePresent ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_multicursor_u       ), CmdMultiCursorU      ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_multicursor_d       ), CmdMultiCursorD      ),
        };
        ForEach( entry, table ) {
          if( GlwKeybind( key, entry.keybind ) ) {
            entry.fn( txt, entry.misc, entry.misc2 );
            target_valid = 0;
            ran_cmd = 1;
          }
        }
      } break;

      case glwkeyevent_t::up: {
      } break;

      default: UnreachableCrash();
    }
  }

  if( !ran_cmd ) {
    if( !kb_command ) {
      TxtControlKeyboardType(
        txt,
        target_valid,
        content_changed,
        ran_cmd,
        type,
        key,
        keylocks,
        alreadydn,
        1
        );
    }
  }
}


void
TxtControlKeyboardSingleLine(
  txt_t& txt,
  bool kb_command,
  bool& target_valid,
  bool& content_changed,
  bool& ran_cmd,
  glwkeyevent_t type,
  glwkey_t key,
  glwkeylocks_t& keylocks,
  bool* alreadydn
  )
{
  ProfFunc();

  if( kb_command ) {
    switch( type ) {
      case glwkeyevent_t::dn:
      case glwkeyevent_t::repeat: {
        txt_cmdmap_t table_contentchange[] = {
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cut        ), CmdCut               ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_paste      ), CmdPaste             ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_txt_undo   ), CmdTxtUndo           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_txt_redo   ), CmdTxtRedo           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_tab_r      ), CmdTabR              ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_tab_l      ), CmdTabL              ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_ch_l   ), CmdRemChL            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_ch_r   ), CmdRemChR            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_word_l ), CmdRemWordL          ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_word_r ), CmdRemWordR          ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_line_r ), CmdRemLineR          ),
        };
        ForEach( entry, table_contentchange ) {
          if( GlwKeybind( key, entry.keybind ) ) {
            entry.fn( txt, entry.misc, entry.misc2 );
            target_valid = 0;
            content_changed = 1;
            ran_cmd = 1;
          }
        }

        txt_cmdmap_t table[] = {
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_copy                ), CmdCopy              ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cs_undo             ), CmdCsUndo            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cs_redo             ), CmdCsRedo            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_toggle_insertmode   ), CmdToggleInsertMode  ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_l            ), CmdCursorL           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_r            ), CmdCursorR           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_home         ), CmdCursorHome        ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_end          ), CmdCursorEnd         ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_skip_l       ), CmdCursorSkipL       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_skip_r       ), CmdCursorSkipR       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_l            ), CmdSelectL           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_r            ), CmdSelectR           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_home         ), CmdSelectHome        ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_end          ), CmdSelectEnd         ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_skip_l       ), CmdSelectSkipL       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_skip_r       ), CmdSelectSkipR       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_all          ), CmdSelectAll         ),
        };
        ForEach( entry, table ) {
          if( GlwKeybind( key, entry.keybind ) ) {
            entry.fn( txt, entry.misc, entry.misc2 );
            target_valid = 0;
            ran_cmd = 1;
          }
        }
      } break;

      case glwkeyevent_t::up: {
      } break;

      default: UnreachableCrash();
    }
  }

  if( !ran_cmd ) {
    if( !kb_command ) {
      TxtControlKeyboardType(
        txt,
        target_valid,
        content_changed,
        ran_cmd,
        type,
        key,
        keylocks,
        alreadydn,
        0
        );
    }
  }
}

void
TxtControlKeyboardSingleLineNotModal(
  txt_t& txt,
  bool& target_valid,
  bool& content_changed,
  bool& ran_cmd,
  glwkeyevent_t type,
  glwkey_t key,
  glwkeylocks_t& keylocks
  )
{
  ProfFunc();

  switch( type ) {
    case glwkeyevent_t::dn:
    case glwkeyevent_t::repeat: {
      txt_cmdmap_t table_contentchange[] = {
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cut        ), CmdCut               ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_paste      ), CmdPaste             ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_txt_undo   ), CmdTxtUndo           ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_txt_redo   ), CmdTxtRedo           ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_tab_r      ), CmdTabR              ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_tab_l      ), CmdTabL              ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_rem_ch_l   ), CmdRemChL            ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_rem_ch_r   ), CmdRemChR            ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_rem_word_l ), CmdRemWordL          ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_rem_word_r ), CmdRemWordR          ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_rem_line_r ), CmdRemLineR          ),
      };
      ForEach( entry, table_contentchange ) {
        if( GlwKeybind( key, entry.keybind ) ) {
          entry.fn( txt, entry.misc, entry.misc2 );
          target_valid = 0;
          content_changed = 1;
          ran_cmd = 1;
        }
      }

      txt_cmdmap_t table[] = {
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_copy                ), CmdCopy              ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cs_undo             ), CmdCsUndo            ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cs_redo             ), CmdCsRedo            ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_toggle_insertmode   ), CmdToggleInsertMode  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cursor_l            ), CmdCursorL           ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cursor_r            ), CmdCursorR           ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cursor_home         ), CmdCursorHome        ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cursor_end          ), CmdCursorEnd         ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cursor_skip_l       ), CmdCursorSkipL       ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cursor_skip_r       ), CmdCursorSkipR       ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_select_l            ), CmdSelectL           ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_select_r            ), CmdSelectR           ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_select_home         ), CmdSelectHome        ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_select_end          ), CmdSelectEnd         ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_select_skip_l       ), CmdSelectSkipL       ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_select_skip_r       ), CmdSelectSkipR       ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_select_all          ), CmdSelectAll         ),
      };
      ForEach( entry, table ) {
        if( GlwKeybind( key, entry.keybind ) ) {
          entry.fn( txt, entry.misc, entry.misc2 );
          target_valid = 0;
          ran_cmd = 1;
        }
      }
    } break;

    case glwkeyevent_t::up: {
    } break;

    default: UnreachableCrash();
  }

  if( !ran_cmd ) {
    TxtControlKeyboardTypeNotModal(
      txt,
      target_valid,
      content_changed,
      ran_cmd,
      type,
      key,
      keylocks,
      0
      );
  }
}

