// Copyright (c) John A. Carlos Jr., all rights reserved.

struct
scrollpos_t
{
  u32 y; // pos at line start.
  f64 frac; // fractional line offset, in units of lines. TODO: consider kahansum64_t, since we do lots of accumulation
};


Enumc( seltype_t )
{
  none,
  s,
  m,
};


// if you change this struct, be sure to change: CsUndoFromTxt, ApplyCsUndo, cs_undo_absolute_t
// this also must match the set of things in __TxtConcurrentPtrs, so that our txt undo/redo restores all
// content ptrs to valid things.
struct
cs_undo_t
{
  u32 c_x;
  u32 s_x;
  u32 c_y;
  u32 s_y;
  u32 c_inline; // TODO: rename to c_x_virtual or x_virtual?
  scrollpos_t scroll_target;
  seltype_t seltype;
  bool overwrite;
};

Inl bool
Equal( cs_undo_t& a, cs_undo_t& b )
{
  bool r = 1;
  r = r  &&  ( a.c_x == b.c_x );
  r = r  &&  ( a.c_y == b.c_y );
  r = r  &&  ( a.s_x == b.s_x );
  r = r  &&  ( a.s_y == b.s_y );
  r = r  &&  ( a.c_inline == b.c_inline );
  r = r  &&  ( a.overwrite == b.overwrite );
  r = r  &&  ( a.seltype == b.seltype );
  r = r  &&  ( a.scroll_target.y == b.scroll_target.y );
  r = r  &&  ( ABS( a.scroll_target.frac - b.scroll_target.frac ) < 0.2 );
  return r;
}

struct
txt_dblclick_t
{
  bool first_made;
  u32 first_cursor;
  u64 first_clock;
};

struct
linerect_t
{
  vec2<f32> p0;
  vec2<f32> p1;
  u32 line_start;
};

struct
linespan_t
{
  idx_t offset; // into txt_t.charspans
  idx_t len;
  f32 yl; // constraint: yl <= yr
  f32 yr;
  u32 y;
};

struct
idxspan_t
{
  idx_t start;
  idx_t len;
};

struct
txt_t
{
  fsobj_t filename;
  buf_t buf;
  // cursor position.
  u32 c_x;
  u32 c_y;
  // select anchor.
  u32 s_x;
  u32 s_y;
  // stored so cursor / select u,d will try to stay on same ch.
  u32 c_inline; // TODO: rename to c_x_virtual or x_virtual?
  bool overwrite;
  seltype_t seltype;
  scrollpos_t scroll_start; // this is the line-start of the FIRST line of the CURRENT scroll view.
  scrollpos_t scroll_target; // this is the line-start of the CENTER line of the TARGET scroll view.
  u32 scroll_end; // this is the line-start of the LAST line of the CURRENT scroll view.
  kahansum64_t scroll_vel;
  f32 scroll_x;
  u16 window_n_lines;
  stack_resizeable_cont_t<cs_undo_t> undos_txtcs; // used in CmdTxtUndo/Redo. stores cursel state prior to each change.
  stack_resizeable_cont_t<cs_undo_t> redos_txtcs; // note these are locked into txt undo, which always restores previous diff state.
  stack_resizeable_cont_t<cs_undo_t> undos; // used in CmdCsUndo/Redo. stores cursel state prior to each change.
  stack_resizeable_cont_t<cs_undo_t> redos;
  txt_dblclick_t dblclick;
  fontlayout_t layout; // created on every EditRender call. sent to Glw for rendering.
  stack_resizeable_cont_t<linespan_t> linespans; // generated by rendering, used by mouse code to map to a line position.
  stack_resizeable_cont_t<charspan_t> charspans; // generated by rendering, used by mouse code to map to a char position.

  stack_resizeable_cont_t<charspan_t> charspans_wrapping; // temporary array only used during rendering.
  stack_resizeable_cont_t<wordspan_t> wordspans; // temporary array only used during rendering.
  stack_resizeable_cont_t<idxspan_t> wrapped_lines; // temporary array only used during rendering.
  stack_resizeable_cont_t<idx_t> nwords_per_wrapped_line; // temporary array only used during rendering. // TODO: buffer_t

  bool insert_spaces_for_tabs;
  u8 spaces_per_tab;
  bool text_grabbed;
  bool scroll_grabbed;
  bool has_scrollbar;
  rectf32_t scroll_track;
  rectf32_t scroll_btn_up;
  rectf32_t scroll_btn_dn;
  rectf32_t scroll_btn_pos;
  rectf32_t scroll_bounds_view_and_bar;
  rectf32_t scroll_bounds_view;

  eoltype_t eoltype;
};


#define __TxtCmd( name )   void ( name )( txt_t& txt, idx_t misc = 0, idx_t misc2 = 0 )
#define __TxtCmdDef( name )   void ( name )( txt_t& txt, idx_t misc, idx_t misc2 )
typedef __TxtCmdDef( *pfn_txtcmd_t );

// TODO: centralized command execution?
// would provide a nice place for some things, like DEBUGSLOW checks.
struct
txtcmd_options_t
{
  bool add_csundo;
  bool add_txtundo;
  bool make_cursor_visible;
};








// =================================================================================
// FIRST / LAST CALLS
//

void
Init( txt_t& txt )
{
  txt.filename.mem[0] = 0;
  txt.filename.len = 0;
  Init( &txt.buf );
  txt.c_x = 0;
  txt.c_y = 0;
  txt.s_x = 0;
  txt.s_y = 0;
  txt.c_inline = 0;
  txt.overwrite = 0;
  txt.seltype = seltype_t::none;
  txt.scroll_start = {};
  txt.scroll_target = {};
  txt.scroll_end = 0;
  txt.scroll_vel = {};
  txt.scroll_x = 0;
  txt.window_n_lines = 0;
  Alloc( txt.undos_txtcs, 16 );
  Alloc( txt.redos_txtcs, 16 );
  Alloc( txt.undos, 16 );
  Alloc( txt.redos, 16 );
  txt.dblclick.first_made = 0;
  txt.dblclick.first_cursor = 0;
  txt.dblclick.first_clock = 0;
  FontInit( txt.layout );
  Alloc( txt.linespans, 200 );
  Alloc( txt.charspans, 20000 );
  Alloc( txt.charspans_wrapping, 2000 );
  Alloc( txt.wordspans, 2000 );
  Alloc( txt.wrapped_lines, 200 );
  Alloc( txt.nwords_per_wrapped_line, 200 );
  txt.text_grabbed = 0;
  txt.scroll_grabbed = 0;
  txt.has_scrollbar = 0;
  txt.scroll_track = {};
  txt.scroll_btn_up = {};
  txt.scroll_btn_dn = {};
  txt.scroll_btn_pos = {};
  txt.scroll_bounds_view_and_bar = {};
  txt.scroll_bounds_view = {};
  txt.eoltype = eoltype_t::crlf;
}

void
Kill( txt_t& txt )
{
  txt.filename.mem[0] = 0;
  txt.filename.len = 0;
  Kill( &txt.buf );
  Free( txt.undos_txtcs );
  Free( txt.redos_txtcs );
  Free( txt.undos );
  Free( txt.redos );
  txt.dblclick.first_made = 0;
  txt.dblclick.first_cursor = 0;
  txt.dblclick.first_clock = 0;
  FontKill( txt.layout );
  Free( txt.linespans );
  Free( txt.charspans );
  Free( txt.charspans_wrapping );
  Free( txt.wordspans );
  Free( txt.wrapped_lines );
  Free( txt.nwords_per_wrapped_line );
  txt.text_grabbed = 0;
  txt.scroll_grabbed = 0;
  txt.has_scrollbar = 0;
  txt.scroll_track = {};
  txt.scroll_btn_up = {};
  txt.scroll_btn_dn = {};
  txt.scroll_btn_pos = {};
  txt.scroll_bounds_view_and_bar = {};
  txt.scroll_bounds_view = {};
  txt.eoltype = eoltype_t::crlf;
}


void
TxtLoadEmpty( txt_t& txt )
{
  txt.filename.mem[0] = 0;
  txt.filename.len = 0;
  BufLoadEmpty( &txt.buf );

  txt.spaces_per_tab = GetPropFromDb( u8, u8_spaces_per_tab );
  txt.insert_spaces_for_tabs = GetPropFromDb( bool, bool_insert_spaces_for_tabs );
}

void
TxtLoad( txt_t& txt, file_t& file )
{
  ProfFunc();
  Memmove( txt.filename.mem, ML( file.obj ) );
  txt.filename.len = file.obj.len;

  BufLoad( &txt.buf, &file, &txt.eoltype );

  auto default_spaces_per_tab = GetPropFromDb( u8, u8_spaces_per_tab );
  auto default_insert_spaces_for_tabs = GetPropFromDb( bool, bool_insert_spaces_for_tabs );

  // analyze leading spaces and tabs to figure out what settings to use for this file.

  constant u32 c_lines = 1000;
  stack_resizeable_cont_t<vec2<idx_t>> spacetabs;
  Alloc( spacetabs, c_lines );
  auto nlines = MIN( NLines( &txt.buf ), c_lines );
  FORLINES( &txt.buf, line, y, 0, nlines )
    auto bol_whitespace = CursorSkipSpacetabR( ML( *line ), 0 );
    if( bol_whitespace ) {
      auto spacetab = AddBack( spacetabs );
      *spacetab = _vec2<idx_t>( 0, 0 );
      For( j, 0, bol_whitespace ) {
        if( line->mem[j] == ' ' ) {
          spacetab->x += 1;
        } elif( line->mem[j] == '\t' ) {
          spacetab->y += 1;
        }
      }
    }
  }

  bool enough_samples = ( spacetabs.len >= 4 );
  idx_t linecount_mixed = 0;
  idx_t linecount_allspaces = 0;
  idx_t linecount_alltabs = 0;
  FORLEN( spacetab, i, spacetabs )
    if( spacetab->x  &&  spacetab->y ) {
      linecount_mixed += 1;
    } elif( spacetab->x ) {
      linecount_allspaces += 1;
    } elif( spacetab->y ) {
      linecount_alltabs += 1;
      // remove the alltab line.
      *spacetab = spacetabs.mem[ spacetabs.len - 1 ];
      spacetabs.len -= 1;
      i -= 1;
    }
  }
  auto linecount_sampled = linecount_mixed + linecount_allspaces + linecount_alltabs;
  if( enough_samples  &&  linecount_alltabs > linecount_sampled / 2 ) {
    // if more than half are alltabs, pick tabs.
    txt.insert_spaces_for_tabs = 0;
    txt.spaces_per_tab = default_spaces_per_tab;
  }
  elif( enough_samples  &&  linecount_allspaces > linecount_sampled / 2 ) {
    // if more than half are allspaces, pick spaces.
    // then we do a fuzzy gcd detection to pick the right spaces_per_tab.
    txt.insert_spaces_for_tabs = 1;
    // compute a fuzzy greatest-common-denominator for { spacetabs->x }
    f32 scores[16]; // 16 spaces_per_tab should be enough for anyone.
    f32 score_max = 0;
    ReverseFor( i, 1, _countof( scores ) ) { // exclude 1 spaces_per_tab, since that would always score highest.
      scores[i] = 0;
      auto rec_spaces_per_tab = 1.0f / Cast( f32, i + 1 );
      FORLEN( spacetab, j, spacetabs )
        auto divtest = Cast( f32, spacetab->x ) * rec_spaces_per_tab;
        scores[i] += Pow32( Frac32( divtest ), rec_spaces_per_tab );
      }
      score_max = MAX( score_max, scores[i] );
    }
    AssertWarn( score_max > 0 );
    For( i, 1, _countof( scores ) ) {
      scores[i] /= score_max;
    }
    bool found = 0;
    constant auto score_threshold = 0.15f;
    ReverseFor( i, 1, _countof( scores ) ) {
      if( scores[i] <= score_threshold ) {
        txt.spaces_per_tab = Cast( u8, i + 1 );
        found = 1;
        break;
      }
    }
    if( !found ) {
      txt.spaces_per_tab = default_spaces_per_tab;
    }
  }
  else {
    txt.insert_spaces_for_tabs = default_insert_spaces_for_tabs;
    txt.spaces_per_tab = default_spaces_per_tab;
  }
  Free( spacetabs );
}

void
TxtSave( txt_t& txt, file_t& file )
{
  BufSave( &txt.buf, &file, txt.eoltype );
}


Inl void
ForceInbounds(
  buf_t* buf,
  u32* x,
  u32* y
  )
{
  *y = MIN( LastLine( buf ), *y );
  auto line = LineFromY( buf, *y );
  *x = MIN( line->len, *x );
}


Inl void
_Checks(
  txt_t* txt
  )
{
#if DEBUGSLOW
//  _CheckNoDupes( &txt->buf );

  switch( txt->seltype ) {
    case seltype_t::none: {
      auto x = txt->c_x;
      auto y = txt->c_y;
      ForceInbounds( &txt->buf, &x, &y );
      AssertCrash( y == txt->c_y  &&  x == txt->c_x );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      auto x = txt->c_x;
      auto y = txt->c_y;
      ForceInbounds( &txt->buf, &x, &y );
      AssertCrash( y == txt->c_y  &&  x == txt->c_x );
      x = txt->s_x;
      y = txt->s_y;
      ForceInbounds( &txt->buf, &x, &y );
      AssertCrash( y == txt->s_y  &&  x == txt->s_x );
    } break;
    default: UnreachableCrash();
  }
  AssertCrash( txt->c_y < NLines( &txt->buf ) );
  AssertCrash( txt->c_y < NLines( &txt->buf ) );
#endif
}


// =================================================================================
// CURSOR / SELECT NAVIGATION
//

Inl void
ResetCInline( txt_t& txt )
{
  txt.c_inline = txt.c_x;
}


Inl void
CsUndoFromTxt( txt_t& txt, cs_undo_t* undo )
{
  undo->c_x = txt.c_x;
  undo->c_y = txt.c_y;
  undo->s_x = txt.s_x;
  undo->s_y = txt.s_y;
  undo->c_inline = txt.c_inline;
  undo->overwrite = txt.overwrite;
  undo->seltype = txt.seltype;
  undo->scroll_target = txt.scroll_target;
}

Inl void
ApplyCsUndo( txt_t& txt, cs_undo_t& undo )
{
  auto last_line = LastLine( &txt.buf );
  txt.c_y = MIN( undo.c_y, last_line );
  txt.s_y = MIN( undo.s_y, last_line );
  txt.c_x = MIN( undo.c_x, CursorInlineEOL( &txt.buf, txt.c_y ) );
  txt.s_x = MIN( undo.s_x, CursorInlineEOL( &txt.buf, txt.s_y ) );
  txt.c_inline = undo.c_inline;
  txt.overwrite = undo.overwrite;
  txt.seltype = undo.seltype;
  txt.scroll_target.frac = undo.scroll_target.frac;
  txt.scroll_target.y = MIN( undo.scroll_target.y, last_line );
  _Checks( &txt );
}



Inl bool
SelectIsZero( txt_t& txt )
{
  return ( txt.seltype != seltype_t::s )  ||  ( txt.c_x == txt.s_x  &&  txt.c_y == txt.s_y );
}



__TxtCmd( CmdScrollD )
{
  AssertCrash( !misc2 );
  auto delta_nlines = Cast( u32, misc );
  u32 x = 0;
  CursorLineD( &txt.buf, &x, &txt.scroll_target.y, 0, delta_nlines );
}

__TxtCmd( CmdScrollU )
{
  AssertCrash( !misc2 );
  auto delta_nlines = Cast( u32, misc );
  u32 x = 0;
  CursorLineU( &txt.buf, &x, &txt.scroll_target.y, 0, delta_nlines );
}


Inl void
MakeCursorVisible( txt_t& txt )
{
  auto make_cursor_visible_radius = GetPropFromDb( f32, f32_make_cursor_visible_radius );

  // TODO: this is all now wrong because of line wrapping!
  //   we can't just CursorLineU/D here, we need to account for line-wraps.
  //   ugh.

  u32 x = 0;
#if USE_SIMPLE_SCROLLING
  auto top = txt.scroll_start.y;
  auto bot = CursorLineD( txt.buf, &x, &top, 0, MAX( txt.window_n_lines, 1 ) - 1 );
  if( txt.c_y < top ) ) {
    txt.scroll_start.y = txt.c_y;
    txt.scroll_start.frac = 0;
  } elif( bot <= txt.c_y ) ) {
    auto delta = txt.c_y - bot;
    CursorLineD( txt.buf, &x, &txt.scroll_start.y, 0, delta + 1 );
    txt.scroll_start.frac = 0;
  } else {
    // no scrolling action, c already on screen.
  }
#else
  // always center on the cursor:
//  txt.scroll_target.y = c_ln_start;
//  txt.scroll_target.frac = 0;

  // We may have deleted from scroll_start to EOF, so we need to reset scroll_start so it's in-bounds.
  auto last_line = LastLine( &txt.buf );
  if( txt.scroll_start.y > last_line ) {
    txt.scroll_start.y = last_line;
    txt.scroll_start.frac = 0;
  }

  auto nlines = Cast( u32, txt.scroll_start.frac + 0.5 * txt.window_n_lines );
  auto scroll_half = txt.scroll_start.y;
  CursorLineD( &txt.buf, &x, &scroll_half, 0, nlines );

  auto half_scrollwin = Cast( u32, make_cursor_visible_radius * txt.window_n_lines );
  auto yl = scroll_half;
  auto yr = scroll_half;
  CursorLineU( &txt.buf, &x, &yl, 0, half_scrollwin );
  CursorLineD( &txt.buf, &x, &yr, 0, half_scrollwin );

  if( txt.c_y < yl ) {
    auto delta_y = yl - txt.c_y;
    CursorLineU( &txt.buf, &x, &scroll_half, 0, delta_y );
  } elif( txt.c_y > yr ) {
    auto delta_y = txt.c_y - yr;
    CursorLineD( &txt.buf, &x, &scroll_half, 0, delta_y );
  }
  txt.scroll_target.y = scroll_half;
  txt.scroll_target.frac = 0;
#endif

  _Checks( &txt );
}


Enumc( cmp_t )
{
  less,
  eq,
  greater,
};

Inl cmp_t
CmpCursors(
  buf_t* buf,
  u32 x0,
  u32 y0,
  u32 x1,
  u32 y1
  )
{
  if( y0 < y1 )  return cmp_t::less;
  if( y0 > y1 )  return cmp_t::greater;
  if( x0 < x1 )  return cmp_t::less;
  if( x0 > x1 )  return cmp_t::greater;
  return cmp_t::eq;
}


struct
sel_t
{
  u32 sl_x;
  u32 sr_x;
  u32 sl_y;
  u32 sr_y;
};

Inl void
GetSelect(
  txt_t& txt,
  sel_t* sel
  )
{
  if( CmpCursors( &txt.buf, txt.c_x, txt.c_y, txt.s_x, txt.s_y ) == cmp_t::less ) {
    sel->sl_x = txt.c_x;
    sel->sl_y = txt.c_y;
    sel->sr_x = txt.s_x;
    sel->sr_y = txt.s_y;
  }
  else {
    sel->sl_x = txt.s_x;
    sel->sl_y = txt.s_y;
    sel->sr_x = txt.c_x;
    sel->sr_y = txt.c_y;
  }
}



Inl string_t
AllocSelection( txt_t& txt, eoltype_t eoltype )
{
  AssertCrash( txt.seltype == seltype_t::s );
  sel_t sel;
  GetSelect( txt, &sel );
  return AllocContents( &txt.buf, sel.sl_x, sel.sl_y, sel.sr_x, sel.sr_y, eoltype );
}



struct
multisel_t
{
  u32 c_y;
  u32 s_y;
  u32 c_inline; // always-in-bounds inline pos. // TODO: rename to c_x / s_x.
  u32 s_inline; // always-in-bounds inline pos.
  u32 top_y; // line at multiselection top edge.
  u32 bot_y; // line at multiselection bot edge.
  u32 left_inline; // inline pos of multiselection l edge.
  u32 rght_inline; // inline pos of multiselection r edge.
};



Inl void
GetMultiselect( txt_t& txt, multisel_t& ms )
{
  ms.c_y = txt.c_y;
  ms.c_inline = txt.c_x;
  ms.s_y = txt.s_y;
  ms.s_inline = txt.s_x;

  ms.top_y = MIN( ms.c_y, ms.s_y );
  ms.bot_y = MAX( ms.c_y, ms.s_y );

  // virtual c_inline if the txt.c_inline is past the end of txt.c's current line.
  auto c_inline = MAX( ms.c_inline, txt.c_inline );

  ms.left_inline = MIN( c_inline, ms.s_inline );
  ms.rght_inline = MAX( c_inline, ms.s_inline );
}



Inl void
AnchorSelect( txt_t& txt, u32 x, u32 y )
{
  txt.s_x = x;
  txt.s_y = y;
  txt.seltype = seltype_t::s;
}



Inl void
AddCsUndo( txt_t& txt )
{
  // invalidate previous future.
  // if this function is called, then something's changed, and it doesn't
  //  make sense to step forward in the UndoStack. so we clear the stack
  //  past the current time.
  txt.redos.len = 0;

  // dump current state onto the UndoStack.
  cs_undo_t state;
  CsUndoFromTxt( txt, &state );

  bool add = 1;
  if( txt.undos.len ) {
    auto last = txt.undos.mem + txt.undos.len - 1;
    add = !Equal( state, *last );
  }
  if( add ) {
    *AddBack( txt.undos ) = state;
  }
}



__TxtCmd( CmdCsUndo )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  if( !txt.undos.len ) {
    return;
  }

  cs_undo_t state;
  CsUndoFromTxt( txt, &state );
  *AddBack( txt.redos ) = state;

  cs_undo_t undo = txt.undos.mem[txt.undos.len - 1];
  RemBack( txt.undos );
  ApplyCsUndo( txt, undo );
}

__TxtCmd( CmdCsRedo )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  if( !txt.redos.len ) {
    return;
  }

  cs_undo_t state;
  CsUndoFromTxt( txt, &state );
  *AddBack( txt.undos ) = state;

  cs_undo_t redo = txt.redos.mem[txt.redos.len - 1];
  RemBack( txt.redos );
  ApplyCsUndo( txt, redo );
}



__TxtCmd( CmdToggleInsertMode )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  txt.overwrite = !txt.overwrite;
}



__TxtCmd( CmdCursorL )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      CursorCharL( &txt.buf, &txt.c_x, &txt.c_y );
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectSelectL( txt_t& txt )
{
  auto c_inline = txt.c_x;
  auto c_move = CursorInlineCharL( &txt.buf, txt.c_x, txt.c_y, 1 );
  if( txt.c_x == c_move  ||  c_inline != txt.c_inline ) {
    if( txt.c_inline ) {
      txt.c_inline -= 1;
    }
  } else {
    txt.c_x = c_move;
    ResetCInline( txt );
  }
}

Inl void
SelectSelectL( txt_t& txt )
{
  CursorCharL( &txt.buf, &txt.c_x, &txt.c_y );
  ResetCInline( txt );
}

__TxtCmd( CmdSelectL )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move_x = txt.c_x;
      auto c_move_y = txt.c_y;
      CursorCharL( &txt.buf, &c_move_x, &c_move_y );
      if( txt.c_x != c_move_x  ||  txt.c_y != c_move_y ) {
        AnchorSelect( txt, txt.c_x, txt.c_y );
        txt.c_x = c_move_x;
        txt.c_y = c_move_y;
        ResetCInline( txt );
      }
    } break;
    case seltype_t::s: {
      SelectSelectL( txt );
    } break;
    case seltype_t::m: {
      MultiselectSelectL( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      CursorCharR( &txt.buf, &txt.c_x, &txt.c_y );
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectSelectR( txt_t& txt )
{
  auto c_inline = txt.c_x;
  auto c_move = CursorInlineCharR( &txt.buf, txt.c_x, txt.c_y, 1 );
  if( txt.c_x == c_move  ||  c_inline != txt.c_inline ) {
    txt.c_inline += 1;
  } else {
    txt.c_x = c_move;
    ResetCInline( txt );
  }
}

Inl void
SelectSelectR( txt_t& txt )
{
  CursorCharR( &txt.buf, &txt.c_x, &txt.c_y );
  ResetCInline( txt );
}

__TxtCmd( CmdSelectR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move_x = txt.c_x;
      auto c_move_y = txt.c_y;
      CursorCharR( &txt.buf, &c_move_x, &c_move_y );
      if( txt.c_x != c_move_x  ||  txt.c_y != c_move_y ) {
        AnchorSelect( txt, txt.c_x, txt.c_y );
        txt.c_x = c_move_x;
        txt.c_y = c_move_y;
        ResetCInline( txt );
      }
    } break;
    case seltype_t::s: {
      SelectSelectR( txt );
    } break;
    case seltype_t::m: {
      MultiselectSelectR( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorU )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      CursorLineU( &txt.buf, &txt.c_x, &txt.c_y, txt.c_inline, 1 );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdSelectU )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move_x = txt.c_x;
      auto c_move_y = txt.c_y;
      CursorLineU( &txt.buf, &c_move_x, &c_move_y, txt.c_inline, 1 );
      if( txt.c_x != c_move_x  ||  txt.c_y != c_move_y ) {
        AnchorSelect( txt, txt.c_x, txt.c_y );
        txt.c_x = c_move_x;
        txt.c_y = c_move_y;
      }
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      CursorLineU( &txt.buf, &txt.c_x, &txt.c_y, txt.c_inline, 1 );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorD )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      CursorLineD( &txt.buf, &txt.c_x, &txt.c_y, txt.c_inline, 1 );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdSelectD )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move_x = txt.c_x;
      auto c_move_y = txt.c_y;
      CursorLineD( &txt.buf, &c_move_x, &c_move_y, txt.c_inline, 1 );
      if( txt.c_x != c_move_x  ||  txt.c_y != c_move_y ) {
        AnchorSelect( txt, txt.c_x, txt.c_y );
        txt.c_x = c_move_x;
        txt.c_y = c_move_y;
      }
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      CursorLineD( &txt.buf, &txt.c_x, &txt.c_y, txt.c_inline, 1 );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdSelectWordAtCursor )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto line = LineFromY( &txt.buf, txt.c_y );
      auto r = CursorStopAtNonWordCharR( ML( *line ), txt.c_x );
      auto l = CursorStopAtNonWordCharL( ML( *line ), txt.c_x );
      txt.c_x = r;
      txt.s_x = l;
      txt.s_y = txt.c_y;
      txt.seltype = seltype_t::s;
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      // TODO: implement
      //ImplementCrash();
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorHome )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto line = LineFromY( &txt.buf, txt.c_y );
      txt.c_x = CursorInlineHome( ML( *line ), txt.c_x );
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectSelectHome( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );

  // TODO: alternate between bol and bol_whitespace, if it exists across all lines.
  txt.c_y = ( txt.s_y < txt.c_y )  ?  ms.bot_y  :  ms.top_y;
  txt.c_x = 0;
  txt.c_inline = 0;
}

Inl void
SelectSelectHome( txt_t& txt )
{
  auto line = LineFromY( &txt.buf, txt.c_y );
  txt.c_x = CursorInlineHome( ML( *line ), txt.c_x );
  ResetCInline( txt );
}

__TxtCmd( CmdSelectHome )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move_x = txt.c_x;
      auto c_move_y = txt.c_y;
      auto line = LineFromY( &txt.buf, txt.c_y );
      c_move_x = CursorInlineHome( ML( *line ), c_move_x );
      if( txt.c_x != c_move_x  ||  txt.c_y != c_move_y ) {
        AnchorSelect( txt, txt.c_x, txt.c_y );
        txt.c_x = c_move_x;
        txt.c_y = c_move_y;
        ResetCInline( txt );
      }
    } break;
    case seltype_t::s: {
      SelectSelectHome( txt );
    } break;
    case seltype_t::m: {
      MultiselectSelectHome( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorEnd )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto line = LineFromY( &txt.buf, txt.c_y );
      txt.c_x = CursorInlineEnd( ML( *line ), txt.c_x );
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectSelectEnd( txt_t& txt )
{
  // TODO: alternate between eol and eol_whitespace, if it exists across all lines.
  multisel_t ms;
  GetMultiselect( txt, ms );
  // walk each line of ms, and find the max c_inline across all lines.
  u32 max_inline = 0;
  ReverseFori( u32, y, ms.top_y, ms.bot_y ) {
    auto line = LineFromY( &txt.buf, y );
    max_inline = MAX( max_inline, line->len );
  }
  // set txt.c to line end, and txt.c_inline to the max c_inline found.
  txt.c_x = CursorInlineEOL( &txt.buf, txt.c_y );
  txt.c_inline = max_inline;
}

Inl void
SelectSelectEnd( txt_t& txt )
{
  auto line = LineFromY( &txt.buf, txt.c_y );
  txt.c_x = CursorInlineEnd( ML( *line ), txt.c_x );
  ResetCInline( txt );
}

__TxtCmd( CmdSelectEnd )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move_x = txt.c_x;
      auto c_move_y = txt.c_y;
      auto line = LineFromY( &txt.buf, txt.c_y );
      c_move_x = CursorInlineEnd( ML( *line ), c_move_x );
      if( txt.c_x != c_move_x  ||  txt.c_y != c_move_y ) {
        AnchorSelect( txt, txt.c_x, txt.c_y );
        txt.c_x = c_move_x;
        txt.c_y = c_move_y;
        ResetCInline( txt );
      }
    } break;
    case seltype_t::s: {
      SelectSelectEnd( txt );
    } break;
    case seltype_t::m: {
      MultiselectSelectEnd( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorFileL )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      txt.c_x = 0;
      txt.c_y = 0;
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}

__TxtCmd( CmdCursorFileR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      txt.c_y = LastLine( &txt.buf );
      txt.c_x = CursorInlineEOL( &txt.buf, txt.c_y );
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorGotoline )
{
  AssertCrash( !misc2 );
  AssertCrash( misc <= MAX_u32 );
  auto nlines = Cast( u32, misc );
  AddCsUndo( txt );
  txt.seltype = seltype_t::none;
  txt.c_y = MIN( nlines, LastLine( &txt.buf ) );
  txt.c_x = MIN( txt.c_x, CursorInlineEOL( &txt.buf, txt.c_y ) );
  MakeCursorVisible( txt );
}



struct
txt_setsel_t
{
  u32 x_start;
  u32 y_start;
  u32 x_end;
  u32 y_end;
};

__TxtCmd( CmdSetSelection )
{
  AssertCrash( misc );
  AssertCrash( !misc2 );
  auto setsel = Cast( txt_setsel_t*, misc );
  AddCsUndo( txt );
  txt.seltype = seltype_t::s;
  txt.c_x = MAX( setsel->x_start, setsel->x_end );
  txt.c_y = MAX( setsel->y_start, setsel->y_end );
  txt.s_x = MIN( setsel->x_start, setsel->x_end );
  txt.s_y = MIN( setsel->y_start, setsel->y_end );
  ResetCInline( txt );
  MakeCursorVisible( txt );
}


__TxtCmd( CmdCursorJumpD )
{
  AssertCrash( !misc2 );
  AssertCrash( misc <= MAX_u32 );
  auto nlines = Cast( u32, misc );
  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      CursorLineD( &txt.buf, &txt.c_x, &txt.c_y, txt.c_inline, nlines );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdSelectJumpD )
{
  AssertCrash( !misc2 );
  AssertCrash( misc <= MAX_u32 );
  auto nlines = Cast( u32, misc );
  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move_x = txt.c_x;
      auto c_move_y = txt.c_y;
      CursorLineD( &txt.buf, &c_move_x, &c_move_y, txt.c_inline, nlines );
      if( txt.c_x != c_move_x  ||  txt.c_y != c_move_y ) {
        AnchorSelect( txt, txt.c_x, txt.c_y );
        txt.c_x = c_move_x;
        txt.c_y = c_move_y;
      }
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      CursorLineD( &txt.buf, &txt.c_x, &txt.c_y, txt.c_inline, nlines );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorJumpU )
{
  AssertCrash( !misc2 );
  AssertCrash( misc <= MAX_u32 );
  auto nlines = Cast( u32, misc );
  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      CursorLineU( &txt.buf, &txt.c_x, &txt.c_y, txt.c_inline, nlines );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdSelectJumpU )
{
  AssertCrash( !misc2 );
  AssertCrash( misc <= MAX_u32 );
  auto nlines = Cast( u32, misc );
  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move_x = txt.c_x;
      auto c_move_y = txt.c_y;
      CursorLineU( &txt.buf, &c_move_x, &c_move_y, txt.c_inline, nlines );
      if( txt.c_x != c_move_x  ||  txt.c_y != c_move_y ) {
        AnchorSelect( txt, txt.c_x, txt.c_y );
        txt.c_x = c_move_x;
        txt.c_y = c_move_y;
      }
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      CursorLineU( &txt.buf, &txt.c_x, &txt.c_y, txt.c_inline, nlines );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorSkipL )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      CursorSkipWordSpacetabNewlineL( &txt.buf, &txt.c_x, &txt.c_y );
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdSelectSkipL )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move_x = txt.c_x;
      auto c_move_y = txt.c_y;
      CursorSkipWordSpacetabNewlineL( &txt.buf, &c_move_x, &c_move_y );
      if( txt.c_x != c_move_x  ||  txt.c_y != c_move_y ) {
        AnchorSelect( txt, txt.c_x, txt.c_y );
        txt.c_x = c_move_x;
        txt.c_y = c_move_y;
        ResetCInline( txt );
      }
    } break;
    case seltype_t::s: {
      CursorSkipWordSpacetabNewlineL( &txt.buf, &txt.c_x, &txt.c_y );
      ResetCInline( txt );
    } break;
    case seltype_t::m: {
      MultiselectSelectL( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCursorSkipR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      CursorSkipWordSpacetabNewlineR( &txt.buf, &txt.c_x, &txt.c_y );
      ResetCInline( txt );
    } break;
    case seltype_t::s:
    case seltype_t::m: {
      txt.seltype = seltype_t::none;
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}

__TxtCmd( CmdSelectSkipR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move_x = txt.c_x;
      auto c_move_y = txt.c_y;
      CursorSkipWordSpacetabNewlineR( &txt.buf, &c_move_x, &c_move_y );
      if( txt.c_x != c_move_x  ||  txt.c_y != c_move_y ) {
        AnchorSelect( txt, txt.c_x, txt.c_y );
        txt.c_x = c_move_x;
        txt.c_y = c_move_y;
        ResetCInline( txt );
      }
    } break;
    case seltype_t::s: {
      CursorSkipWordSpacetabNewlineR( &txt.buf, &txt.c_x, &txt.c_y );
      ResetCInline( txt );
    } break;
    case seltype_t::m: {
      MultiselectSelectR( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdSelectAll )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  auto last_line = LastLine( &txt.buf );
  txt.s_x = 0;
  txt.s_y = 0;
  txt.c_y = last_line;
  txt.c_x = CursorInlineEOL( &txt.buf, last_line );
  ResetCInline( txt );
  txt.seltype = seltype_t::s;
}



__TxtCmd( CmdCursorMakePresent )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  txt.c_x = 0;
  txt.c_y = txt.scroll_start.y;
  auto nlines = txt.window_n_lines / 2;
  CursorLineD( &txt.buf, &txt.c_x, &txt.c_y, txt.c_inline, nlines );
  ResetCInline( txt );
}



__TxtCmd( CmdMultiCursorU )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      ResetCInline( txt ); // we don't want standard c_inline behavior for this Line move.
      txt.s_x = txt.c_x;
      txt.s_y = txt.c_y;
      txt.seltype = seltype_t::m;
    } break;
    case seltype_t::s: {
      ResetCInline( txt ); // we don't want standard c_inline behavior for this Line move.
      txt.seltype = seltype_t::m;
    } break;
    case seltype_t::m: {
    } break;
    default: UnreachableCrash();
  }
  CursorLineU( &txt.buf, &txt.c_x, &txt.c_y, txt.c_inline, 1 );

  // TODO: should we turn single-line multiselects into standard selects?
  //   definitely not for when we have txt.c_inline > eol.

  MakeCursorVisible( txt );
}

__TxtCmd( CmdMultiCursorD )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      ResetCInline( txt ); // we don't want standard c_inline behavior for this Line move.
      txt.s_x = txt.c_x;
      txt.s_y = txt.c_y;
      txt.seltype = seltype_t::m;
    } break;
    case seltype_t::s: {
      ResetCInline( txt ); // we don't want standard c_inline behavior for this Line move.
      txt.seltype = seltype_t::m;
    } break;
    case seltype_t::m: {
    } break;
    default: UnreachableCrash();
  }
  CursorLineD( &txt.buf, &txt.c_x, &txt.c_y, txt.c_inline, 1 );

  // TODO: should we turn single-line multiselects into standard selects?
  //   definitely not for when we have txt.c_inline > eol.

  MakeCursorVisible( txt );
}





// =================================================================================
// CONTENT EDITING
//

__TxtCmd( CmdWipeHistory )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  txt.undos.len = 0;
  txt.redos.len = 0;
  txt.undos_txtcs.len = 0;
  txt.redos_txtcs.len = 0;
  WipeHistories( &txt.buf );
}

Inl void
AddTxtUndo( txt_t& txt )
{
  // let buf_t add an internal checkpt so it can unwind enough times.
  UndoCheckpt( &txt.buf );

  // invalidate previous futures.
  txt.redos_txtcs.len = 0;

  cs_undo_t state;
  CsUndoFromTxt( txt, &state );
  *AddBack( txt.undos_txtcs ) = state;
}


Inl void
MultiselectDelete( txt_t& txt, multisel_t& ms )
{
  AssertCrash( ms.left_inline != ms.rght_inline );
  REVERSEFORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
    // the selection range on the given line ln_start.
    auto ml = MIN( line->len, ms.left_inline );
    auto mr = MIN( line->len, ms.rght_inline );
    Delete( &txt.buf, ml, y, mr, y );
  }
  txt.c_x = MIN( ms.left_inline, CursorInlineEOL( &txt.buf, txt.c_y ) );
  txt.s_x = MIN( ms.left_inline, CursorInlineEOL( &txt.buf, txt.s_y ) );
  txt.c_inline = ms.left_inline;
}


Inl void
SelectDelete( txt_t& txt )
{
  sel_t sel;
  GetSelect( txt, &sel );
  Delete( &txt.buf, sel.sl_x, sel.sl_y, sel.sr_x, sel.sr_y, &txt.c_x, &txt.c_y );
  txt.seltype = seltype_t::none;
  ResetCInline( txt );
}



Inl void
SelectAddString( txt_t& txt, u8* str, idx_t str_len )
{
  if( txt.overwrite ) {
    SelectDelete( txt );
  } else {
    SelectDelete( txt );
    if( str_len ) {
      Insert( &txt.buf, txt.c_x, txt.c_y, str, str_len, &txt.c_x, &txt.c_y );
      ResetCInline( txt );
    }
  }
}

Inl void
MultiselectAddString( txt_t& txt, u8* str, idx_t str_len )
{
  // we'd have to do more work here to support adding multi-line strings here.
  auto num_newlines = CountNewlines( str, str_len );
  if( num_newlines ) {
    return;
  }
  // not supported due to the above.
  if( str_len > MAX_u32 ) {
    return;
  }

  multisel_t ms;
  GetMultiselect( txt, ms );

  if( txt.overwrite ) {
    if( ms.left_inline != ms.rght_inline ) {
      MultiselectDelete( txt, ms );
      return;

    } else {
      ms.rght_inline += Cast( u32, str_len );
      MultiselectDelete( txt, ms );
      // txt.c/c_inline has probably changed, so ms.left_inline/rght_inline will be different!
      // so, re-get the ms so MultiselectAddChar can work!
      GetMultiselect( txt, ms );
    }
  } else {
    if( ms.left_inline != ms.rght_inline ) {
      MultiselectDelete( txt, ms );
      // txt.c/c_inline has probably changed, so ms.left_inline/rght_inline will be different!
      // so, re-get the ms so MultiselectAddChar can work!
      GetMultiselect( txt, ms );
    }

    AssertCrash( ms.left_inline == ms.rght_inline );
  }

  if( !str_len ) {
    return;
  }

  REVERSEFORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
    auto pos = MIN( line->len, ms.left_inline );
    if( pos < ms.left_inline ) {
      auto nspaces = ms.left_inline - pos;
      auto spaces = MemHeapAlloc( u8, nspaces );
      For( i, 0, nspaces ) {
        spaces[i] = ' ';
      }
      Insert(
        &txt.buf,
        line->len,
        y,
        spaces,
        nspaces
        );
      // grab line again, since we modified it.
      line = LineFromY( &txt.buf, y );
      MemHeapFree( spaces );
    }
    Insert(
      &txt.buf,
      ms.left_inline,
      y,
      str,
      str_len
      );
  }
  txt.c_x = ms.left_inline + Cast( u32, str_len );
  txt.s_x = ms.left_inline + Cast( u32, str_len );
  ResetCInline( txt );
}

Inl void
AddString( txt_t& txt, u8* str, idx_t str_len )
{
  if( !str_len ) {
    return;
  }
  if( txt.overwrite ) {
    auto eol = CursorInlineEOL( &txt.buf, txt.c_y );
    if( txt.c_x == eol ) {
      Insert( &txt.buf, txt.c_x, txt.c_y, str, str_len, &txt.c_x, &txt.c_y );
    }
    else {
      Replace( &txt.buf, txt.c_x, txt.c_y, txt.c_x + 1, txt.c_y, str, str_len, &txt.c_x, &txt.c_y );
    }
  } else {
    Insert( &txt.buf, txt.c_x, txt.c_y, str, str_len, &txt.c_x, &txt.c_y );
  }
  ResetCInline( txt );
}




__TxtCmd( CmdAddString )
{
  auto str = Cast( u8*, misc );
  auto str_len = Cast( idx_t, misc2 );
  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      AddString( txt, str, str_len );
    } break;
    case seltype_t::s: {
      SelectAddString( txt, str, str_len );
    } break;
    case seltype_t::m: {
      MultiselectAddString( txt, str, str_len );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}

__TxtCmd( CmdAddAlpha )
{
  auto c = Cast( u8, misc );
  auto caps = ( misc2 != 0 );
  c = caps ? ToUpperAscii( c ) : ToLowerAscii( c );
  CmdAddString( txt, Cast( idx_t, &c ), 1 );
}



Inl void
MultiselectTabR( txt_t& txt )
{
  auto nspaces = txt.spaces_per_tab;
  auto spaces = MemHeapAlloc( u8, nspaces );
  For( i, 0, nspaces ) {
    spaces[i] = ' ';
  }

  multisel_t ms;
  GetMultiselect( txt, ms );
  if( txt.insert_spaces_for_tabs ) {
    REVERSEFORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
      Insert( &txt.buf, 0, y, spaces, nspaces );
    }
  } else {
    REVERSEFORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
      Insert( &txt.buf, 0, y, Str( "\t" ), 1 );
    }
  }
  auto ninc = ( txt.insert_spaces_for_tabs )  ?  txt.spaces_per_tab  :  1;
  txt.c_x += ninc;
  txt.s_x += ninc;
  txt.c_inline += ninc;

  MemHeapFree( spaces );
}

Inl void
TabR( txt_t& txt )
{
  auto nspaces = txt.spaces_per_tab;
  auto spaces = MemHeapAlloc( u8, nspaces );
  For( i, 0, nspaces ) {
    spaces[i] = ' ';
  }

  if( txt.insert_spaces_for_tabs ) {
    Insert( &txt.buf, txt.c_x, txt.c_y, spaces, nspaces, &txt.c_x, &txt.c_y );
  } else {
    Insert( &txt.buf, txt.c_x, txt.c_y, Str( "\t" ), 1, &txt.c_x, &txt.c_y );
  }
  ResetCInline( txt );

  MemHeapFree( spaces );
}

__TxtCmd( CmdTabR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      TabR( txt );
    } break;
    case seltype_t::s: // defer to multiselect implementation. this works because c, s are the same across sel, multisel!
    case seltype_t::m: {
      MultiselectTabR( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl bool
IsAllSpaces( slice32_t slice )
{
  FORLEN32( elem, i, slice )
    if( *elem != ' ' ) {
      return 0;
    }
  }
  return 1;
}
Inl bool
EveryNonEmptyMultiselLineIsLeadingAllSpaces( txt_t& txt, multisel_t& ms )
{
  REVERSEFORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
    auto spaces_end = MIN( line->len, txt.spaces_per_tab );
    if( !IsAllSpaces( { line->mem, spaces_end } ) ) {
      return 0;
    }
  }
  return 1;
}
Inl bool
EveryNonEmptyMultiselLineIsLeadingOneTab( txt_t& txt, multisel_t& ms )
{
  REVERSEFORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
    if( !line->len ) {
      continue;
    }
    if( line->mem[0] != '\t' ) {
      return 0;
    }
  }
  return 1;
}

Inl void
MultiselectTabL( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );

  // TODO: implement mixed tabs/spaces.
  bool all_spaces = EveryNonEmptyMultiselLineIsLeadingAllSpaces( txt, ms );
  bool all_tab = EveryNonEmptyMultiselLineIsLeadingOneTab( txt, ms );

  if( all_spaces ) {
    REVERSEFORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
      auto del_end = MIN( line->len, txt.spaces_per_tab );
      Delete( &txt.buf, 0, y, del_end, y );
    }
    auto ninc = txt.spaces_per_tab;
    txt.c_x = MAX( txt.c_x, ninc ) - ninc;
    txt.s_x = MAX( txt.s_x, ninc ) - ninc;
    txt.c_inline = MAX( txt.c_inline, ninc ) - ninc;
  }
  elif( all_tab ) {
    REVERSEFORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
      auto del_end = MIN( line->len, 1 );
      Delete( &txt.buf, 0, y, del_end, y );
    }
    u32 ninc = 1;
    txt.c_x = MAX( txt.c_x, ninc ) - ninc;
    txt.s_x = MAX( txt.s_x, ninc ) - ninc;
    txt.c_inline = MAX( txt.c_inline, ninc ) - ninc;
  }
}

Inl void
TabL( txt_t& txt )
{
  auto line = LineFromY( &txt.buf, txt.c_y );
  if( !line->len ) {
    return;
  }
  if( line->mem[0] == '\t' ) {
    Delete( &txt.buf, 0, txt.c_y, 1, txt.c_y );
    txt.c_x = MAX( txt.c_x, 1 ) - 1;
  } elif( line->mem[0] == ' ' ) {
    slice32_t spaces;
    spaces.mem = line->mem;
    spaces.len = MIN( line->len, txt.spaces_per_tab );
    if( IsAllSpaces( spaces ) ) {
      Delete( &txt.buf, 0, txt.c_y, spaces.len, txt.c_y );
      txt.c_x = MAX( txt.c_x, spaces.len ) - spaces.len;
    }
  }
  // if first wasn't space or tab, then no-op.
}

__TxtCmd( CmdTabL )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      TabL( txt );
    } break;
    case seltype_t::s: // defer to multiselect implementation. this works because c, s are the same across sel, multisel!
    case seltype_t::m: {
      MultiselectTabL( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}


Inl void
MultiselectRemChL( txt_t& txt, multisel_t& ms, u32 len )
{
  AssertCrash( ms.left_inline == ms.rght_inline );
  if( !ms.left_inline ) {
    return;
  }
  REVERSEFORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
    auto ml = MIN( line->len, ms.left_inline );
    // skip lines that aren't long enough to reach ms.left_inline
    if( ml == ms.left_inline ) {
      auto del_start = MAX( ml, len ) - len;
      auto del_end = ml;
      Delete( &txt.buf, del_start, y, del_end, y );
    }
  }
  auto new_x = MAX( ms.left_inline, len ) - len;
  txt.c_x = MIN( new_x, CursorInlineEOL( &txt.buf, txt.c_y ) );
  txt.s_x = MIN( new_x, CursorInlineEOL( &txt.buf, txt.s_y ) );
  txt.c_inline = MAX( txt.c_inline, len ) - len;
}

#define __TCountMultiselFn( name ) \
  u32 \
  ( name )( \
    u8* src, \
    u32 src_len, \
    u32 pos \
    ) \

typedef __TCountMultiselFn( *pfn_tcountmultisel_t );

Templ Inl u32
GetTCountAcrossAllNonEmptyMultiselLines( txt_t& txt, multisel_t& ms, T fn )
{
  bool min_valid = 0;
  u32 min_nchars = 0;
  REVERSEFORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
    // the selection range on the given line ln_start.
    auto ml = MIN( line->len, ms.left_inline );
    // skip lines that aren't long enough to reach ms.left_inline
    if( line->len  &&  ml == ms.left_inline ) {
      auto ml_moved = fn( ML( *line ), ml );
      auto nmoved = MAX( ml, ml_moved ) - MIN( ml, ml_moved );
      if( !nmoved ) {
        return 0;
      }
      if( !min_valid ) {
        min_valid = 1;
        min_nchars = nmoved;
      }
      else {
        min_nchars = MIN( min_nchars, nmoved );
      }
    }
  }
  return min_nchars;
}

Inl u32
GetNumSpacetabsAcrossAllNonEmptyMultiselLinesL( txt_t& txt, multisel_t& ms )
{
  return GetTCountAcrossAllNonEmptyMultiselLines<pfn_tcountmultisel_t>( txt, ms, CursorSkipSpacetabL );
}
Inl u32
GetNumSpacetabsAcrossAllNonEmptyMultiselLinesR( txt_t& txt, multisel_t& ms )
{
  return GetTCountAcrossAllNonEmptyMultiselLines<pfn_tcountmultisel_t>( txt, ms, CursorSkipSpacetabR );
}

Inl u32
GetNumWordCharsAcrossAllNonEmptyMultiselLinesL( txt_t& txt, multisel_t& ms )
{
  return GetTCountAcrossAllNonEmptyMultiselLines<pfn_tcountmultisel_t>( txt, ms, CursorStopAtNonWordCharL );
}
Inl u32
GetNumWordCharsAcrossAllNonEmptyMultiselLinesR( txt_t& txt, multisel_t& ms )
{
  return GetTCountAcrossAllNonEmptyMultiselLines<pfn_tcountmultisel_t>( txt, ms, CursorStopAtNonWordCharR );
}




Inl void
MultiselectRemWordL( txt_t& txt, multisel_t& ms )
{
  AssertCrash( ms.left_inline == ms.rght_inline );
  if( !ms.left_inline ) {
    return;
  }
  auto nwordchars = GetNumWordCharsAcrossAllNonEmptyMultiselLinesL( txt, ms );
  auto nspacetabs = GetNumSpacetabsAcrossAllNonEmptyMultiselLinesL( txt, ms );
  u32 nrem;
  if( nwordchars ) {
    nrem = nwordchars;
  } elif( nspacetabs ) {
    nrem = nspacetabs;
  } else {
    nrem = 1;
  }
  MultiselectRemChL( txt, ms, nrem );
}

__TxtCmd( CmdRemChL )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move_x = txt.c_x;
      auto c_move_y = txt.c_y;
      CursorCharL( &txt.buf, &c_move_x, &c_move_y );
      Delete( &txt.buf, c_move_x, c_move_y, txt.c_x, txt.c_y, &txt.c_x, &txt.c_y );
      ResetCInline( txt );
    } break;
    case seltype_t::s: {
      SelectDelete( txt );
    } break;
    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      if( ms.left_inline != ms.rght_inline ) {
        MultiselectDelete( txt, ms );
      } else {
        MultiselectRemChL( txt, ms, 1 );
      }
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectRemChR( txt_t& txt, multisel_t& ms, u32 len )
{
  AssertCrash( ms.left_inline == ms.rght_inline );
  REVERSEFORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
    // the selection range on the given line ln_start.
    auto ml = MIN( line->len, ms.left_inline );
    // skip lines that aren't long enough to reach ms.left_inline
    if( line->len  &&  ml == ms.left_inline ) {
      auto del_end = MIN( line->len, ml + len );
      Delete( &txt.buf, ml, y, del_end, y );
    }
  }
}

Inl void
MultiselectRemWordR( txt_t& txt, multisel_t& ms )
{
  AssertCrash( ms.left_inline == ms.rght_inline );
  auto nwordchars = GetNumWordCharsAcrossAllNonEmptyMultiselLinesR( txt, ms );
  auto nspacetabs = GetNumSpacetabsAcrossAllNonEmptyMultiselLinesR( txt, ms );
  u32 nrem;
  if( nwordchars ) {
    nrem = nwordchars;
  } elif( nspacetabs ) {
    nrem = nspacetabs;
  } else {
    nrem = 1;
  }
  MultiselectRemChR( txt, ms, nrem );
}

__TxtCmd( CmdRemChR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move_x = txt.c_x;
      auto c_move_y = txt.c_y;
      CursorCharR( &txt.buf, &c_move_x, &c_move_y );
      Delete( &txt.buf, txt.c_x, txt.c_y, c_move_x, c_move_y );
    } break;
    case seltype_t::s: {
      SelectDelete( txt );
    } break;
    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      if( ms.left_inline != ms.rght_inline ) {
        MultiselectDelete( txt, ms );
      } else {
        MultiselectRemChR( txt, ms, 1 );
      }
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdRemWordL )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move_x = txt.c_x;
      auto c_move_y = txt.c_y;
      CursorSkipWordSpacetabNewlineL( &txt.buf, &c_move_x, &c_move_y );
      Delete( &txt.buf, c_move_x, c_move_y, txt.c_x, txt.c_y, &txt.c_x, &txt.c_y );
      ResetCInline( txt );
    } break;
    case seltype_t::s: {
      SelectDelete( txt );
    } break;
    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      if( ms.left_inline != ms.rght_inline ) {
        MultiselectDelete( txt, ms );
      } else {
        MultiselectRemWordL( txt, ms );
      }
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdRemWordR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto c_move_x = txt.c_x;
      auto c_move_y = txt.c_y;
      CursorSkipWordSpacetabNewlineR( &txt.buf, &c_move_x, &c_move_y );
      Delete( &txt.buf, txt.c_x, txt.c_y, c_move_x, c_move_y );
    } break;
    case seltype_t::s: {
      SelectDelete( txt );
    } break;
    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      if( ms.left_inline != ms.rght_inline ) {
        MultiselectDelete( txt, ms );
      } else {
        MultiselectRemWordR( txt, ms );
      }
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectRemLineR( txt_t& txt, multisel_t& ms )
{
  AssertCrash( ms.left_inline == ms.rght_inline );
  REVERSEFORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
    // the selection range on the given line ln_start.
    auto ml = MIN( line->len, ms.left_inline );
    // skip lines that aren't long enough to reach ms.left_inline
    if( line->len  &&  ml == ms.left_inline ) {
      Delete( &txt.buf, ml, y, line->len, y );
    }
  }
}

__TxtCmd( CmdRemLineR )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto eol = CursorInlineEOL( &txt.buf, txt.c_y );
      Delete( &txt.buf, txt.c_x, txt.c_y, eol, txt.c_y );
    } break;
    case seltype_t::s: {
      SelectDelete( txt );
    } break;
    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      if( ms.left_inline != ms.rght_inline ) {
        MultiselectDelete( txt, ms );
      } else {
        MultiselectRemLineR( txt, ms );
      }
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdAddLn )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      auto line = LineFromY( &txt.buf, txt.c_y );
      auto bol_whitespace = CursorSkipSpacetabR( ML( *line ), 0 );
      auto whitespace = AllocContents( &txt.buf, 0, txt.c_y, bol_whitespace, txt.c_y, eoltype_t::lf );
      auto eol = EolString( txt.eoltype );
      Insert( &txt.buf, txt.c_x, txt.c_y, ML( eol ), &txt.c_x, &txt.c_y );
      Insert( &txt.buf, txt.c_x, txt.c_y, ML( whitespace ), &txt.c_x, &txt.c_y );
      ResetCInline( txt );
      Free( whitespace );
    } break;
    case seltype_t::s: {
      SelectDelete( txt );
    } break;
    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      if( ms.left_inline != ms.rght_inline ) {
        MultiselectDelete( txt, ms );
      }
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectRemLn( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );
  REVERSEFORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
    DeleteLine( &txt.buf, line, y );
  }
  txt.seltype = seltype_t::none;
  txt.c_y = MIN( LastLine( &txt.buf ), ms.top_y );
  txt.c_x = CursorInlineCharR( &txt.buf, 0, txt.c_y, ms.c_inline );
  txt.c_inline = ms.left_inline;
}

Inl void
RemLn( txt_t& txt )
{
  auto line = LineFromY( &txt.buf, txt.c_y );
  DeleteLine( &txt.buf, line, txt.c_y );
  txt.c_y = MIN( LastLine( &txt.buf ), txt.c_y );
  txt.c_x = CursorInlineCharR( &txt.buf, 0, txt.c_y, txt.c_inline );
}

__TxtCmd( CmdRemLn )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      RemLn( txt );
    } break;
    case seltype_t::s: // defer to multiselect implementation. this works because c, s are the same across sel, multisel!
    case seltype_t::m: {
      MultiselectRemLn( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectCommentElseUncomment( txt_t& txt, bool comment )
{
  multisel_t ms;
  GetMultiselect( txt, ms );
  if( comment ) {
    REVERSEFORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
      Insert( &txt.buf, 0, y, Str( "//" ), 2 );
    }
    txt.c_x += 2;
    txt.s_x += 2;
  } else {
    REVERSEFORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
      auto del_end = MIN( line->len, 2 );
      Delete( &txt.buf, 0, y, del_end, y );
    }
    txt.c_x = MAX( txt.c_x, 2 ) - 2;
    txt.s_x = MAX( txt.s_x, 2 ) - 2;
  }
  ResetCInline( txt );
}

Inl void
Comment( txt_t& txt )
{
  Insert( &txt.buf, 0, txt.c_y, Str( "//" ), 2 );
  txt.c_x += 2;
  txt.c_inline += 2;
}

__TxtCmd( CmdComment )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      Comment( txt );
    } break;
    case seltype_t::s: // defer to multiselect implementation. this works because c, s are the same across sel, multisel!
    case seltype_t::m: {
      MultiselectCommentElseUncomment( txt, 1 );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl bool
MultiselectIsAllCommentLines( txt_t& txt, multisel_t& ms )
{
  REVERSEFORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
    auto slash_end = MIN( line->len, 2 );
    if( !MemEqual( line->mem, slash_end, "//", 2 ) ) {
      return 0;
    }
  }
  return 1;
}


Inl void
MultiselectUncomment( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );
  if( MultiselectIsAllCommentLines( txt, ms ) ) {
    MultiselectCommentElseUncomment( txt, 0 );
  }
}

Inl void
Uncomment( txt_t& txt )
{
  auto line = LineFromY( &txt.buf, txt.c_y );
  auto slash_end = MIN( line->len, 2 );
  if( MemEqual( line->mem, slash_end, "//", 2 ) ) {
    Delete( &txt.buf, 0, txt.c_y, slash_end, txt.c_y );
    txt.c_x = MAX( txt.c_x, 2 ) - 2;
    txt.c_inline = MAX( txt.c_inline, 2 ) - 2;
  }
}

__TxtCmd( CmdUncomment )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      Uncomment( txt );
    } break;
    case seltype_t::s: // defer to multiselect implementation. this works because c, s are the same across sel, multisel!
    case seltype_t::m: {
      MultiselectUncomment( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}


Inl void
MultiselectToggleComment( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );
  auto all_comments = MultiselectIsAllCommentLines( txt, ms );
  MultiselectCommentElseUncomment( txt, !all_comments );
}

Inl void
ToggleComment( txt_t& txt )
{
  auto line = LineFromY( &txt.buf, txt.c_y );
  auto slash_end = MIN( line->len, 2 );
  if( MemEqual( line->mem, slash_end, "//", 2 ) ) {
    Delete( &txt.buf, 0, txt.c_y, slash_end, txt.c_y );
    txt.c_x = MAX( txt.c_x, 2 ) - 2;
    txt.c_inline = MAX( txt.c_inline, 2 ) - 2;
  } else {
    Insert( &txt.buf, 0, txt.c_y, Str( "//" ), 2 );
    txt.c_x += 2;
    txt.c_inline += 2;
  }
}

__TxtCmd( CmdToggleComment )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      ToggleComment( txt );
    } break;
    case seltype_t::s: // defer to multiselect implementation. this works because c, s are the same across sel, multisel!
    case seltype_t::m: {
      MultiselectToggleComment( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
CommentSelection( txt_t& txt )
{
  sel_t sel;
  GetSelect( txt, &sel );
  Insert( &txt.buf, sel.sr_x, sel.sr_y, Str( "*/" ), 2 );
  Insert( &txt.buf, sel.sl_x, sel.sl_y, Str( "/*" ), 2 );
  auto dx = txt.c_y == txt.s_y  ?  4  :  2;
  if( CmpCursors( &txt.buf, txt.c_x, txt.c_y, txt.s_x, txt.s_y ) == cmp_t::less ) {
    txt.s_x += dx;
  }
  else {
    txt.c_x += dx;
  }
  ResetCInline( txt );
}

__TxtCmd( CmdCommentSelection )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none:
    case seltype_t::m: {
    } break;
    case seltype_t::s: {
      CommentSelection( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}

Inl void
UncommentSelection( txt_t& txt )
{
  sel_t sel;
  GetSelect( txt, &sel );

  // TODO: allow selecting just the thing inside the comment
  // TODO: allow whitespace inside the comment ?

  auto open_start_x = sel.sl_x;
  auto open_start_y = sel.sl_y;
  auto open_end_x = open_start_x;
  auto open_end_y = open_start_y;
  CursorCharR( &txt.buf, &open_end_x, &open_end_y, 2 );
  if( open_start_y != open_end_y ) {
    return;
  }
  auto close_end_x = sel.sr_x;
  auto close_end_y = sel.sr_y;
  auto close_start_x = close_end_x;
  auto close_start_y = close_end_y;
  CursorCharL( &txt.buf, &close_start_x, &close_start_y, 2 );
  if( close_start_y != close_end_y ) {
    return;
  }
  auto open = AllocContents( &txt.buf, open_start_x, open_start_y, open_end_x, open_end_y, txt.eoltype );
  auto close = AllocContents( &txt.buf, close_start_x, close_start_y, close_end_x, close_end_y, txt.eoltype );
  auto nonoverlapping =
    open_end_y != close_start_y  ||
    open_end_x <= close_start_x;
  auto is_comment =
    nonoverlapping  &&
    MemEqual( ML( open ), Str( "/*" ), 2 )  &&
    MemEqual( ML( close ), Str( "*/" ), 2 );
  if( is_comment ) {
    Delete( &txt.buf, close_start_x, close_start_y, close_end_x, close_end_y, &close_start_x, &close_start_y );
    Delete( &txt.buf, open_start_x, open_start_y, open_end_x, open_end_y, &open_start_x, &open_start_y );
    auto dx = txt.c_y == txt.s_y  ?  4u  :  2u;
    if( CmpCursors( &txt.buf, txt.c_x, txt.c_y, txt.s_x, txt.s_y ) == cmp_t::less ) {
      AssertCrash( txt.s_x >= dx );
      txt.s_x -= dx;
    }
    else {
      AssertCrash( txt.c_x >= dx );
      txt.c_x -= dx;
    }
    ResetCInline( txt );
  }

  Free( open );
  Free( close );
}

__TxtCmd( CmdUncommentSelection )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none:
    case seltype_t::m: {
    } break;
    case seltype_t::s: {
      UncommentSelection( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}


Inl void
MultiselectPermuteU( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );
  bool moved;
  ForwardPermuteOper( &txt.buf, ms.top_y, ms.bot_y, undoableopertype_t::permuteu, &moved );
  if( moved ) {
    AssertCrash( txt.c_y );
    AssertCrash( txt.s_y );
    txt.c_y -= 1;
    txt.s_y -= 1;
  }
}

Inl void
PermuteU( txt_t& txt )
{
  bool moved;
  ForwardPermuteOper( &txt.buf, txt.c_y, txt.c_y, undoableopertype_t::permuteu, &moved );
  if( moved ) {
    AssertCrash( txt.c_y );
    txt.c_y -= 1;
  }
}

__TxtCmd( CmdPermuteU )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      PermuteU( txt );
    } break;
    case seltype_t::s: // defer to multiselect implementation. this works because c, s are the same across sel, multisel!
    case seltype_t::m: {
      MultiselectPermuteU( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



Inl void
MultiselectPermuteD( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );
  bool moved;
  ForwardPermuteOper( &txt.buf, ms.top_y, ms.bot_y, undoableopertype_t::permuted, &moved );
  if( moved ) {
    txt.c_y += 1;
    txt.s_y += 1;
  }
}

Inl void
PermuteD( txt_t& txt )
{
  bool moved;
  ForwardPermuteOper( &txt.buf, txt.c_y, txt.c_y, undoableopertype_t::permuted, &moved );
  if( moved ) {
    txt.c_y += 1;
  }
}

__TxtCmd( CmdPermuteD )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddCsUndo( txt );
  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      PermuteD( txt );
    } break;
    case seltype_t::s: // defer to multiselect implementation. this works because c, s are the same across sel, multisel!
    case seltype_t::m: {
      MultiselectPermuteD( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdTxtUndo )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  if( !txt.undos_txtcs.len ) {
    return;
  }

  cs_undo_t state;
  CsUndoFromTxt( txt, &state );
  *AddBack( txt.redos_txtcs ) = state;

  // ApplyCsUndo depends on buf.content_len, so we need to update buf first!
  Undo( &txt.buf );

  cs_undo_t undo = txt.undos_txtcs.mem[txt.undos_txtcs.len - 1];
  RemBack( txt.undos_txtcs );
  ApplyCsUndo( txt, undo );

  MakeCursorVisible( txt );
}

__TxtCmd( CmdTxtRedo )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  if( !txt.redos_txtcs.len ) {
    return;
  }

  cs_undo_t state;
  CsUndoFromTxt( txt, &state );
  *AddBack( txt.undos_txtcs ) = state;

  // ApplyCsUndo depends on buf.content_len, so we need to update buf first!
  Redo( &txt.buf );

  cs_undo_t redo = txt.redos_txtcs.mem[txt.redos_txtcs.len - 1];
  RemBack( txt.redos_txtcs );
  ApplyCsUndo( txt, redo );

  MakeCursorVisible( txt );
}

Inl void
MultiselectCopy( txt_t& txt, multisel_t& ms )
{
  AssertCrash( ms.left_inline != ms.rght_inline );
  auto eol = EolString( txt.eoltype );
  stack_resizeable_cont_t<u8> clip;
  Alloc( clip, 32768 ); // PERF: smarter allocation size
  FORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
    // the selection range on the given line ln_start.
    auto ml = MIN( line->len, ms.left_inline );
    auto mr = MIN( line->len, ms.rght_inline );
    auto copy_len = mr - ml;
    if( copy_len ) {
      auto copy = AddBack( clip, copy_len );
      Memmove( copy, line->mem + ml, copy_len );
    }
    auto dst_eol = AddBack( clip, eol.len );
    Memmove( dst_eol, ML( eol ) );
  }
  // TODO: make a back-reference to glwclient_t inside txt_t on creation.
  SendToClipboardText( *g_client, ML( clip ) );
  Free( clip );
}

Inl void
SelectCopy( txt_t& txt )
{
  sel_t sel;
  GetSelect( txt, &sel );
  if( sel.sl_y != sel.sr_y  ||  sel.sl_x != sel.sr_x ) {
    auto contents = AllocContents(
      &txt.buf,
      sel.sl_x,
      sel.sl_y,
      sel.sr_x,
      sel.sr_y,
      txt.eoltype
      );
    // TODO: make a back-reference to glwclient_t inside txt_t on creation.
    SendToClipboardText( *g_client, ML( contents ) );
    Free( contents );
  }
}

__TxtCmd( CmdCopy )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  switch( txt.seltype ) {
    case seltype_t::none: {
    } break;
    case seltype_t::s: {
      SelectCopy( txt );
    } break;
    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      if( ms.left_inline != ms.rght_inline ) {
        MultiselectCopy( txt, ms );
      }
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}



__TxtCmd( CmdCut )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
    } break;
    case seltype_t::s: {
      SelectCopy( txt );
      SelectDelete( txt );
    } break;
    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      if( ms.left_inline != ms.rght_inline ) {
        MultiselectCopy( txt, ms );
        MultiselectDelete( txt, ms );
      }
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}

Inl
USECLIPBOARDTXT( UseClipboardTxtFillAllocString )
{
  auto string = Cast( string_t*, misc );
  *string = AllocString<u8>( text_len );
  Memmove( string->mem, text, text_len );
}

Inl void
MultiselectPaste( txt_t& txt )
{
  multisel_t ms;
  GetMultiselect( txt, ms );
  if( ms.left_inline != ms.rght_inline ) {
    MultiselectDelete( txt, ms );
    // txt.c/c_inline has probably changed, so ms.left_inline/rght_inline will be different!
    // so, re-get the ms so MultiselectAddChar can work!
    GetMultiselect( txt, ms );
  }
  AssertCrash( ms.left_inline == ms.rght_inline );

  string_t to_paste;
  GetFromClipboardText( *g_client, UseClipboardTxtFillAllocString, &to_paste );
  auto nlines = CountNewlines( ML( to_paste ) ) + 1;
  stack_resizeable_cont_t<slice32_t> lines_to_paste;
  Alloc( lines_to_paste, nlines );
  SplitIntoLines( &lines_to_paste, ML( to_paste ) );
  bool all_linepastes_equal_len = 1;
  AssertCrash( lines_to_paste.len );
  u32 linepastes_len = lines_to_paste.mem[ 0 ].len;
  if( lines_to_paste.len ) {
    REVERSEFORLINES( &txt.buf, line, y, ms.top_y, ms.bot_y + 1 )
      // repeat the lines_to_paste we're pasting.
      auto idx_to_paste = ( y - ms.top_y ) % lines_to_paste.len;
      auto line_to_paste = lines_to_paste.mem[ idx_to_paste ];
      if( all_linepastes_equal_len  &&  line_to_paste.len != linepastes_len ) {
        all_linepastes_equal_len = 0;
      }
      if( !line_to_paste.len ) {
        continue;
      }
      auto pos = MIN( line->len, ms.left_inline );
      if( pos < ms.left_inline ) {
        auto nspaces = ms.left_inline - pos;
        auto spaces = MemHeapAlloc( u8, nspaces );
        For( i, 0, nspaces ) {
          spaces[i] = ' ';
        }
        Insert(
          &txt.buf,
          line->len,
          y,
          spaces,
          nspaces
          );
        // grab line again, since we modified it.
        line = LineFromY( &txt.buf, y );
        MemHeapFree( spaces );
      }
      Insert(
        &txt.buf,
        ms.left_inline,
        y,
        ML( line_to_paste )
        );
    }
    auto extra = all_linepastes_equal_len  ?  linepastes_len  :  0u;
    txt.c_x = MIN( ms.left_inline + extra, CursorInlineEOL( &txt.buf, txt.c_y ) );
    txt.s_x = MIN( ms.left_inline + extra, CursorInlineEOL( &txt.buf, txt.s_y ) );
    txt.c_inline = ms.left_inline + extra;
  }
  Free( to_paste );
  Free( lines_to_paste );
}

Inl
USECLIPBOARDTXT( UseClipboardTxtPaste )
{
  auto txt = Cast( txt_t*, misc );
  Insert( &txt->buf, txt->c_x, txt->c_y, text, text_len, &txt->c_x, &txt->c_y );
  ResetCInline( *txt );
}

Inl void
Paste( txt_t& txt )
{
  GetFromClipboardText( *g_client, UseClipboardTxtPaste, &txt );
}

__TxtCmd( CmdPaste )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddTxtUndo( txt );
  switch( txt.seltype ) {
    case seltype_t::none: {
      Paste( txt );
    } break;
    case seltype_t::s: {
      SelectDelete( txt );
      Paste( txt );
    } break;
    case seltype_t::m: {
      MultiselectPaste( txt );
    } break;
    default: UnreachableCrash();
  }
  MakeCursorVisible( txt );
}


#if 0
                __TxtCmd( CmdFindCursorWordR )
                {
                  AssertCrash( !misc );
                  AssertCrash( !misc2 );

                  AddCsUndo( txt );
                  switch( txt.seltype ) {
                    case seltype_t::none: {
                      idx_t word_start = CursorStopAtNonWordCharL( txt.buf, txt.c );
                      idx_t word_end = CursorStopAtNonWordCharR( txt.buf, txt.c );
                      idx_t word_len = word_end - word_start;
                      if( word_len ) {
                        auto word = MemHeapAlloc( u8, word_len );
                        Contents( txt.buf, word_start, word, word_len );
                        idx_t new_c;
                        bool found;
                        FindFirstInlineR( txt.buf, word_end, word, word_len, &new_c, &found, 1 );
                        if( found ) {
                          txt.c = new_c;
                          ResetCInline( txt );
                        }
                        MemHeapFree( word );
                      }
                    } break;
                    case seltype_t::s: {
                      // TODO: find next selection match?
                    } break;
                    case seltype_t::m: {
                      // TODO: do what?
                    } break;
                    default: UnreachableCrash();
                  }
                  MakeCursorVisible( txt );
                }

                __TxtCmd( CmdFindCursorWordL )
                {
                  AssertCrash( !misc );
                  AssertCrash( !misc2 );

                  AddCsUndo( txt );
                  switch( txt.seltype ) {
                    case seltype_t::none: {
                      idx_t word_start = CursorStopAtNonWordCharL( txt.buf, txt.c );
                      idx_t word_end = CursorStopAtNonWordCharR( txt.buf, txt.c );
                      idx_t word_len = word_end - word_start;
                      if( word_len ) {
                        auto word = MemHeapAlloc( u8, word_len );
                        Contents( txt.buf, word_start, word, word_len );
                        idx_t new_c;
                        bool found;
                        FindFirstL( txt.buf, word_start, word, word_len, &new_c, &found, 1 );
                        if( found ) {
                          txt.c = new_c;
                          ResetCInline( txt );
                        }
                        MemHeapFree( word );
                      }
                    } break;
                    case seltype_t::s: {
                      // TODO: find next selection match?
                    } break;
                    case seltype_t::m: {
                      // TODO: do what?
                    } break;
                    default: UnreachableCrash();
                  }
                  MakeCursorVisible( txt );
                }
#endif


struct
txtfind_t
{
  u8* str;
  u32 str_len;
  bool case_sens;
  bool word_boundary;
};

__TxtCmd( CmdFindStringR )
{
  AssertCrash( !misc2 );

  auto& txtfind = *Cast( txtfind_t*, misc );
  AddCsUndo( txt );
  if( txtfind.str_len ) {
    u32 x_start;
    u32 y_start;
    switch( txt.seltype ) {
      case seltype_t::none: {
        x_start = txt.c_x;
        y_start = txt.c_y;
      } break;
      case seltype_t::s: {
        sel_t sel;
        GetSelect( txt, &sel );
        x_start = sel.sl_x;
        y_start = sel.sl_y;
        CursorCharR( &txt.buf, &x_start, &y_start );
      } break;
      case seltype_t::m: {
        // just use the cursor, don't bother with the opposite m edge, since m sel is usually big.
        x_start = txt.c_x;
        y_start = txt.c_y;
      } break;
      default: UnreachableCrash();  return;
    }
    u32 x_found;
    u32 y_found;
    bool found;
    FindFirstInlineR(
      &txt.buf,
      x_start,
      y_start,
      txtfind.str,
      txtfind.str_len,
      &x_found,
      &y_found,
      &found,
      txtfind.case_sens,
      txtfind.word_boundary
      );
    if( found ) {
      txt.c_x = x_found;
      txt.c_y = y_found;
      AnchorSelect( txt, txt.c_x, txt.c_y );
      txt.c_x += txtfind.str_len;
      ResetCInline( txt );
    }
  }
  MakeCursorVisible( txt );
}

__TxtCmd( CmdFindStringL )
{
  AssertCrash( !misc2 );

  auto& txtfind = *Cast( txtfind_t*, misc );
  AddCsUndo( txt );
  if( txtfind.str_len ) {
    u32 x_start;
    u32 y_start;
    switch( txt.seltype ) {
      case seltype_t::none: {
        x_start = txt.c_x;
        y_start = txt.c_y;
      } break;
      case seltype_t::s: {
        sel_t sel;
        GetSelect( txt, &sel );
        x_start = sel.sl_x;
        y_start = sel.sl_y;
        CursorCharL( &txt.buf, &x_start, &y_start );
      } break;
      case seltype_t::m: {
        // just use the cursor, don't bother with the opposite m edge, since m sel is usually big.
        x_start = txt.c_x;
        y_start = txt.c_y;
      } break;
      default: UnreachableCrash();  return;
    }
    u32 x_found;
    u32 y_found;
    bool found;
    FindFirstInlineL(
      &txt.buf,
      x_start,
      y_start,
      txtfind.str,
      txtfind.str_len,
      &x_found,
      &y_found,
      &found,
      txtfind.case_sens,
      txtfind.word_boundary
      );
    if( found ) {
      txt.c_x = x_found;
      txt.c_y = y_found;
      AnchorSelect( txt, txt.c_x, txt.c_y );
      txt.c_x += txtfind.str_len;
      ResetCInline( txt );
    }
  }
  MakeCursorVisible( txt );
}

__TxtCmd( CmdRemTrailspace )
{
  AssertCrash( !misc );
  AssertCrash( !misc2 );

  AddTxtUndo( txt );
  FORALLLINES( &txt.buf, line, y )
    auto new_eol = CursorSkipSpacetabL( ML( *line ), line->len );
    if( new_eol != line->len ) {
      Delete( &txt.buf, new_eol, y, line->len, y );
    }
  }

  switch( txt.seltype ) {
    case seltype_t::none: {
      ForceInbounds( &txt.buf, &txt.c_x, &txt.c_y );
    } break;

    case seltype_t::s: __fallthrough;
    case seltype_t::m: {
      ForceInbounds( &txt.buf, &txt.c_x, &txt.c_y );
      ForceInbounds( &txt.buf, &txt.s_x, &txt.s_y );
    } break;
    default: UnreachableCrash();
  }

  ResetCInline( txt );
}


// =================================================================================
// TXT DRAW CALLS
//

// loop:
//   pull window_n_chars from txt.buf at pos
//   render those chars.
//   increment y.
//   if word wrap, then
//     pos += window_n_chars.
//   else
//     pos = scan( pos+1, \n ).
//
// really, we want to output per-char render commands, and then combine as much as possible.
//   struct drawchar_t
//   {
//     u8* c; // points to
//     vec4<f32>* color;
//     u16 x; // window space line pos., u16 for safe drawchar_t <-> drawchar_t comparison.
//     u16 y; // window space line no., u16 for safe drawchar_t <-> drawchar_t comparison.
//   };



//Inl f32
//GetPxLineno( txt_t& txt, f32 FontCharW )
//{
//  if( !opts.lineno_show )
//    return 0.0f;
//  u8 tmp_str [ 32 ];
//  if( opts.lineno_fix_width )
//    Cstr::cstr_from_u64( tmp_str, nlines( *txt.buf ) - 1 );
//  else
//    Cstr::cstr_from_u64( tmp_str, txt.scroll.ln_end - 1 );
//  u8 LinenoDigits = Cast( u8, CstrLength( tmp_str ) );
//  f32 PxLineno = FontCharW * ( LinenoDigits + 1 );
//  return PxLineno;
//}


constant idx_t c_max_line_len = 500; // sanity bounds.





void
TxtRenderSelectionPerLine(
  txt_t& txt,
  stack_resizeable_cont_t<f32>& stream,
  rectf32_t bounds,
  slice_t line,
  u32 line_idx,
  f32 px_space_advance,
  idx_t layout_line_idx,
  f32 x,
  f32 y,
  f32 z,
  f32 line_h
  )
{
  auto rgba_selection_bkgd = GetPropFromDb( vec4<f32>, rgba_selection_bkgd );
  auto px_cursor_w = GetPropFromDb( u8, u8_px_cursor_w );

  switch( txt.seltype ) {
    case seltype_t::none: {
    } break;

    case seltype_t::s: {
      sel_t sel;
      GetSelect( txt, &sel );
      idx_t sel_start = ( sel.sl_y == line_idx )  ?  sel.sl_x  :  0;
      idx_t sel_end   = ( sel.sr_y == line_idx )  ?  sel.sr_x  :  line.len;
      AssertCrash( sel_start <= sel_end );
      auto sel_len = sel_end - sel_start;
      f32 overhang  = ( sel.sr_y == line_idx )  ?  0  :  px_space_advance;
      auto line_within_sel = ( sel.sl_y <= line_idx  &&  line_idx <= sel.sr_y );
      if( line.len  &&  line_within_sel ) {
        auto sel_x0 = FontSumAdvances(
          txt.layout,
          layout_line_idx,
          0,
          sel_start
          );
        auto sel_x1 = sel_x0 + FontSumAdvances(
          txt.layout,
          layout_line_idx,
          sel_start,
          sel_len
          );
        auto s0 = _vec2( x + sel_x0, y );
        auto s1 = _vec2( x + sel_x1 + overhang, y + line_h );
        RenderQuad(
          stream,
          rgba_selection_bkgd,
          bounds.p0 + s0,
          bounds.p0 + s1,
          bounds,
          z
          );
      }
    } break;

    case seltype_t::m: {
      multisel_t ms;
      GetMultiselect( txt, ms );
      // draw selection on line.
      auto sel_start = MIN( line.len, ms.left_inline );
      auto sel_end   = MIN( line.len, ms.rght_inline );
      AssertCrash( sel_start <= sel_end );
      auto sel_len = sel_end - sel_start;
      auto line_within_sel = ( ms.top_y <= line_idx  &&  line_idx <= ms.bot_y );
      if( line_within_sel ) {
        auto sel_x0 = FontSumAdvances(
          txt.layout,
          layout_line_idx,
          0,
          sel_start
          );
        auto sel_x1 = sel_x0 + FontSumAdvances(
          txt.layout,
          layout_line_idx,
          sel_start,
          sel_len
          );
        auto s0 = _vec2( x + sel_x0, y );
        auto s1 = _vec2( x + sel_x1 + px_cursor_w, y + line_h );
        RenderQuad(
          stream,
          rgba_selection_bkgd,
          bounds.p0 + s0,
          bounds.p0 + s1,
          bounds,
          z
          );
      }
    } break;
    default: UnreachableCrash();
  }
}

void
TxtRenderCursor(
  txt_t& txt,
  stack_resizeable_cont_t<f32>& stream,
  rectf32_t bounds,
  slice_t line,
  u32 line_idx,
  f32 px_space_advance,
  idx_t layout_line_idx,
  f32 x,
  f32 y,
  f32 z,
  f32 line_h
  )
{
  auto px_cursor_w = GetPropFromDb( u8, u8_px_cursor_w );

  if( line_idx == txt.c_y  &&  txt.c_x <= c_max_line_len ) {
    auto cursor_advance = FontSumAdvances(
      txt.layout,
      layout_line_idx,
      0,
      txt.c_x
      );
    auto cx = x + cursor_advance;
    rectf32_t r;
    if( txt.overwrite ) {
      r.p0 = bounds.p0 + _vec2( cx, y + line_h - px_cursor_w );
      r.p1 = bounds.p0 + _vec2( cx + px_space_advance, y + line_h );
    } else {
      r.p0 = bounds.p0 + _vec2( cx, y );
      r.p1 = bounds.p0 + _vec2( cx + px_cursor_w, y + line_h );
    }
    RenderQuad(
      stream,
      GetPropFromDb( vec4<f32>, rgba_cursor ),
      r,
      bounds,
      z
      );
  }
}





Enumc( txtlayer_t )
{
  bkgd,
  cursorline,
  match,
  sel,
  txt,
  cur,
  scroll_bkgd,
  scroll_btn,

  COUNT
};


Inl slice_t
ClipLine(
  line_t* line
  )
{
  slice_t r;
  r.mem = line->mem;
  r.len = MIN( line->len, c_max_line_len );
  return r;
}


// NOTE: because of layout_t, you can't use both EditRender and RenderSingleLineSubset on the same txt_t !

void
TxtRenderSingleLineSubset(
  txt_t& txt,
  stack_resizeable_cont_t<f32>& stream,
  font_t& font,
  u32 y,
  rectf32_t bounds,
  vec2<f32> zrange,
  bool draw_bkgd,
  bool draw_cursor,
  bool draw_sel
  )
{
  ProfFunc();

  auto spaces_per_tab = GetPropFromDb( u8, u8_spaces_per_tab );
  auto rgba_text = GetPropFromDb( vec4<f32>, rgba_text );
  auto line_h = FontLineH( font );
  auto line = LineFromY( &txt.buf, y );
  auto line_clipped = ClipLine( line );
  auto px_space_advance = FontGetAdvance( font, ' ' );

  FontClear( txt.layout );
  if( line_clipped.len ) {
    FontAddLayoutLine(
      font,
      txt.layout,
      ML( line_clipped ),
      spaces_per_tab
      );
  }
  AssertCrash( line_clipped.len == txt.layout.raw_advances.len );

  if( draw_bkgd ) {
    RenderQuad(
      stream,
      GetPropFromDb( vec4<f32>, rgba_text_bkgd ),
      bounds,
      GetZ( zrange, txtlayer_t::bkgd )
      );
  }

  if( !FontEmpty( txt.layout ) ) {
    RenderText(
      stream,
      font,
      txt.layout,
      bounds.p0,
      GetZ( zrange, txtlayer_t::txt ),
      bounds,
      rgba_text,
      0,
      0,
      line_clipped.len
      );
  }

  // draw selection.
  if( draw_sel ) {
    TxtRenderSelectionPerLine(
      txt,
      stream,
      bounds,
      line_clipped,
      y,
      px_space_advance,
      0,
      0.0f,
      0.0f,
      GetZ( zrange, txtlayer_t::sel ),
      line_h
      );
  }

  // draw cursor.
  if( draw_cursor ) {
    TxtRenderCursor(
      txt,
      stream,
      bounds,
      line_clipped,
      y,
      px_space_advance,
      0,
      0.0f,
      0.0f,
      GetZ( zrange, txtlayer_t::cur ),
      line_h
      );
  }
}




Inl f32
MapLineToZeta(
  txt_t& txt,
  u32 y
  )
{
  auto r64 = Lerp_from_f64(
    0,
    1,
    Cast( f32, y ),
    0,
    Cast( f32, LastLine( &txt.buf ) )
    );
  auto r = Cast( f32, r64 );
  return r;
}


// TODO: unify this scrolling code with listview_t

Inl vec2<f32>
GetScrollPos( txt_t& txt )
{
  return _vec2<f32>(
    MapLineToZeta( txt, txt.scroll_start.y ),
    MapLineToZeta( txt, txt.scroll_end )
    );
}

Inl bool
ScrollbarVisible(
  rectf32_t bounds,
  f32 px_scroll
  )
{
  bool r =
    ( bounds.p1.x - bounds.p0.x ) > 2 * px_scroll  &&
    ( bounds.p1.y - bounds.p0.y ) > 4 * px_scroll;
  return r;
}

Inl void
GetScrollBtnUp(
  rectf32_t bounds,
  f32 px_scroll,
  rectf32_t* btn_render,
  rectf32_t* btn_mouse
  )
{
  btn_mouse->p0 = bounds.p0 + _vec2( ( bounds.p1.x - bounds.p0.x ) - px_scroll, 0.0f );
  btn_mouse->p1 = bounds.p0 + _vec2( ( bounds.p1.x - bounds.p0.x ), px_scroll );
  btn_render->p0 = btn_mouse->p0 + _vec2( 1.0f );
  btn_render->p1 = btn_mouse->p1 - _vec2( 1.0f );
}

Inl void
GetScrollBtnDn(
  rectf32_t bounds,
  f32 px_scroll,
  rectf32_t* btn_render,
  rectf32_t* btn_mouse
  )
{
  btn_mouse->p0 = bounds.p1 - _vec2( px_scroll );
  btn_mouse->p1 = bounds.p1;
  btn_render->p0 = btn_mouse->p0 + _vec2( 1.0f );
  btn_render->p1 = btn_mouse->p1 - _vec2( 1.0f );
}

Inl void
GetScrollBtnPos(
  f32 t_start,
  f32 t_end,
  rectf32_t bounds,
  f32 px_scroll,
  rectf32_t* btn_render,
  rectf32_t* btn_mouse
  )
{
  auto min_pos_btn_size = px_scroll;
  // note that for t parameterization purposes, the track starts at 0.5 * min_pos_btn_size, and ends the same way.
  auto track_len = ( bounds.p1.y - bounds.p0.y ) - 2 * px_scroll - min_pos_btn_size;
  btn_mouse->p0 = _vec2(
    bounds.p1.x - px_scroll,
    bounds.p0.y + px_scroll + track_len * t_start
    );
  btn_mouse->p1 = _vec2(
    bounds.p1.x,
    bounds.p0.y + px_scroll + min_pos_btn_size + track_len * t_end
    );
  btn_render->p0 = btn_mouse->p0 + _vec2( 1.0f );
  btn_render->p1 = btn_mouse->p1 - _vec2( 1.0f );
}

Inl f32
GetScrollMouseT(
  vec2<s32> m,
  rectf32_t scroll_track
  )
{
  auto my = CLAMP( Cast( f32, m.y ), scroll_track.p0.y, scroll_track.p1.y );
  auto t = Lerp_from_f32( 0.0f, 1.0f, my, scroll_track.p0.y, scroll_track.p1.y );
  return t;
}


Inl rectf32_t
GetScrollTrack(
  rectf32_t bounds,
  f32 px_scroll
  )
{
  rectf32_t r;
  rectf32_t dummy;
  GetScrollBtnPos( 0.0f, 1.0f, bounds, px_scroll, &dummy, &r );
  return r;
}

Inl void
ScrollbarRender(
  stack_resizeable_cont_t<f32>& stream,
  rectf32_t bounds,
  f32 t_start,
  f32 t_end,
  f32 z_bkgd,
  f32 z_btn,
  f32 px_scroll,
  vec4<f32> rgba_scroll_bkgd,
  vec4<f32> rgba_scroll_btn,
  rectf32_t* track, // mouse version of the rects, meaning they're not shrunk for borderings.
  rectf32_t* btn_up,
  rectf32_t* btn_dn,
  rectf32_t* btn_pos
  )
{
  *track = _rect( AlignRight( bounds, px_scroll ), bounds.p1 );
  RenderQuad(
    stream,
    rgba_scroll_bkgd,
    *track,
    bounds,
    z_bkgd
    );

  // account for top/bottom buttons, after drawing above so we have bordering.
  track->p0.y += px_scroll;
  track->p1.y -= px_scroll;

  rectf32_t render_up;
  GetScrollBtnUp( bounds, px_scroll, &render_up, btn_up );
  RenderQuad(
    stream,
    rgba_scroll_btn,
    render_up,
    bounds,
    z_btn
    );

  rectf32_t render_dn;
  GetScrollBtnDn( bounds, px_scroll, &render_dn, btn_dn );
  RenderQuad(
    stream,
    rgba_scroll_btn,
    render_dn,
    bounds,
    z_btn
    );

  rectf32_t render_pos;
  GetScrollBtnPos( t_start, t_end, bounds, px_scroll, &render_pos, btn_pos );
  RenderQuad(
    stream,
    rgba_scroll_btn,
    render_pos,
    bounds,
    z_btn
    );
}


void
TxtRender(
  txt_t& txt,
  bool& target_valid,
  stack_resizeable_cont_t<f32>& stream,
  font_t& font,
  rectf32_t bounds,
  vec2<f32> zrange,
  f64 timestep_realtime,
  f64 timestep_fixed,
  bool draw_cursor,
  bool draw_cursorline,
  bool draw_cursorwordmatch,
  bool allow_scrollbar
  )
{
  ProfFunc();

  auto spaces_per_tab = GetPropFromDb( u8, u8_spaces_per_tab );

  auto line_h = FontLineH( font );
  auto timestep = MIN( timestep_realtime, timestep_fixed );

  auto rgba_text = GetPropFromDb( vec4<f32>, rgba_text );
  // auto rgba_wordmatch_text = GetPropFromDb( vec4<f32>, rgba_wordmatch_text );
  auto rgba_wordmatch_bkgd = GetPropFromDb( vec4<f32>, rgba_wordmatch_bkgd );
  auto rgba_scroll_btn = GetPropFromDb( vec4<f32>, rgba_scroll_btn );
  auto rgba_lineno = GetPropFromDb( vec4<f32>, rgba_lineno );

  auto scroll_animated = GetPropFromDb( bool, bool_scroll_animated );
  auto px_cursor_w = GetPropFromDb( u8, u8_px_cursor_w );

  auto scroll_pct = GetPropFromDb( f32, f32_scroll_pct );
  auto px_scroll = scroll_pct * line_h;

  auto px_space_advance = FontGetAdvance( font, ' ' );

  // leave a small gap on the left/right, so things aren't exactly at the screen edge.
  // esp. important for scrollbars, since window-resize covers some of the active area.
  bounds.p0.x = MIN( bounds.p0.x + 0.25f * px_space_advance, bounds.p1.x );
  bounds.p1.x = MAX( bounds.p1.x - 0.25f * px_space_advance, bounds.p0.x );

  // draw bkgd
  RenderQuad(
    stream,
    GetPropFromDb( vec4<f32>, rgba_text_bkgd ),
    bounds,
    GetZ( zrange, txtlayer_t::bkgd )
    );

  // figure out how many lines we can render, using the same spacing we will for real later.
  txt.window_n_lines = 0;
  kahansum32_t y1 = { bounds.p0.y };
  while( y1.sum < bounds.p1.y ) { // PERF: integer space Ceil32 and a multiply should be sufficient, I just don't want to bother with precision issues right now.
    Add( y1, line_h );
    y1.sum = Ceil32( y1.sum );
    y1.err = 0;
    txt.window_n_lines += 1;
  }

  // vertical scrolling
  {
#if USE_SIMPLE_SCROLLING
    // we already determined scroll_start in MakeCursorVisible, and we're not doing animated
    // scrolling for now, since it makes things feel laggy.
    // so this is trivial; just compute scroll_end for scrollbar position rendering.
    txt.scroll_end = CursorLineD( txt.buf, txt.scroll_start.y, 0, txt.window_n_lines, 0, 0 );
#else

    Prof( TxtUpdateScrollingVertical );

    // reduce fractional position to integer position.
    s32 target_dlines = Cast( s32, txt.scroll_target.frac );
    txt.scroll_target.frac -= target_dlines;
    u32 x;
    if( target_dlines < 0 ) {
      CursorLineU( &txt.buf, &x, &txt.scroll_target.y, 0, -target_dlines );
    } elif( target_dlines > 0 ) {
      CursorLineD( &txt.buf, &x, &txt.scroll_target.y, 0, target_dlines );
    }

    scrollpos_t scroll_half = txt.scroll_start;
    scroll_half.frac += 0.5 * txt.window_n_lines;

    auto target_dist_yl = MIN( txt.scroll_target.y, scroll_half.y );
    auto target_dist_yr = MAX( txt.scroll_target.y, scroll_half.y );
    f64 target_dist_sign = ( scroll_half.y < txt.scroll_target.y )  ?  1  :  -1;
    auto target_dist_nlines = target_dist_yr - target_dist_yl;
    auto target_dist = target_dist_sign * Cast( f64, target_dist_nlines );
    target_dist += txt.scroll_target.frac - scroll_half.frac;

    // PERF: until we optimize line traversal, smooth scrolling large distances is too slow.
    // eg 0.6612 sec spent in CmdCursorGotoline, and 1.088 sec spent in TxtUpdateScrollingVertical here.
    // so, avoid the smooth scrolling by jumping straight to the destination.

//    auto instantaneous =
//      !scroll_animated  ||
//      10.0 * txt.window_n_lines < ABS( target_dist );
//    auto instantaneous =
//      !scroll_animated  ||
//      !txt.scroll_grabbed;
    auto instantaneous = !scroll_animated;

    if( instantaneous ) {
      txt.scroll_start.frac += target_dist;
    }
    else {
      constant f64 mass = 1.0;
      constant f64 spring_k = 1000.0;
      static f64 friction_k = 2.2 * Sqrt64( mass * spring_k ); // 2 * Sqrt( m * k ) is critical damping, but we want a little overdamping.

      f64 force_spring = spring_k * target_dist;
      f64 force_fric = -friction_k * txt.scroll_vel.sum;
      f64 force = force_spring + force_fric;

      // TODO: solve ODE and use explicit soln.
      //   not sure it will simplify much, just require more stored state.

      f64 accel = force / mass;
      f64 delta_vel = timestep * accel;
      Add( txt.scroll_vel, delta_vel );

      // snap to 0 for small velocities to minimize pixel jitter.
      if( ABS( txt.scroll_vel.sum ) <= 2.0f ) {
        txt.scroll_vel = {};
      }

      f64 delta_pos = timestep * txt.scroll_vel.sum;
      txt.scroll_start.frac += delta_pos;

      // invalidate cached target, since we know animation will require a re-render.
      if( ABS( txt.scroll_vel.sum ) > 1e-2f ) {
        target_valid = 0;
      }
    }

    bool at_bof = !txt.scroll_start.y;
    bool at_eof = ( txt.scroll_start.y == LastLine( &txt.buf ) );
    if( at_bof ) {
      txt.scroll_start.frac = MAX( txt.scroll_start.frac, -0.5 * txt.window_n_lines );
    }
    if( at_eof ) {
      txt.scroll_start.frac = MIN( txt.scroll_start.frac, 0.5 * txt.window_n_lines );
    }

    s32 to_scroll = Cast( s32, txt.scroll_start.frac );
    bool multi_line = !at_bof  ||  !at_eof;
    bool allow_bof_reduce = at_bof  &&  to_scroll > 0;
    bool allow_eof_reduce = at_eof  &&  to_scroll < 0;
    bool allow_mid_reduce = !at_bof  &&  !at_eof;
    bool allow_reduce = multi_line  &&  ( allow_bof_reduce | allow_eof_reduce | allow_mid_reduce );
    if( allow_reduce ) {
      // reduce fractional position to integer position.
      txt.scroll_start.frac -= to_scroll; // take only fractional part.
      if( to_scroll < 0 ) {
        CursorLineU( &txt.buf, &x, &txt.scroll_start.y, 0, -to_scroll );
      } elif( to_scroll > 0 ) {
        CursorLineD( &txt.buf, &x, &txt.scroll_start.y, 0, to_scroll );
      }
    }
#if 0
    // don't let scrolling go past first line or last line, fractionally.
    bool scroll_on_bof = ( !txt.scroll_start.y );
    bool scroll_on_eof = ( txt.scroll_start.y == eof_ln_start );
    if( scroll_on_bof ) {
      txt.scroll_start.frac = MAX( txt.scroll_start.frac, 0 );
      if( txt.scroll_vel < 0 ) {
        txt.scroll_vel = 0;
      }
    }
    if( scroll_on_eof ) {
      txt.scroll_start.frac = MIN( txt.scroll_start.frac, 0 );
      if( txt.scroll_vel > 0 ) {
        txt.scroll_vel = 0;
      }
    }
#endif

    txt.scroll_end = txt.scroll_start.y;
    auto nlines_before_start = txt.scroll_start.frac < 0  ?  Cast( u32, -txt.scroll_start.frac )  :  0u;
    AssertCrash( nlines_before_start <= txt.window_n_lines + 1u );
    CursorLineD( &txt.buf, &x, &txt.scroll_end, 0, txt.window_n_lines + 1u - nlines_before_start );

    ProfClose( TxtUpdateScrollingVertical );
  }
#endif


  // render the scrollbar.
  txt.has_scrollbar = allow_scrollbar  &&  ScrollbarVisible( bounds, px_scroll );
  txt.scroll_bounds_view_and_bar = bounds;
  if( txt.has_scrollbar ) {
    auto scroll_pos = GetScrollPos( txt );
    ScrollbarRender(
      stream,
      bounds,
      scroll_pos.x,
      scroll_pos.y,
      GetZ( zrange, txtlayer_t::scroll_bkgd ),
      GetZ( zrange, txtlayer_t::scroll_btn ),
      px_scroll,
      GetPropFromDb( vec4<f32>, rgba_scroll_bkgd ),
      rgba_scroll_btn,
      &txt.scroll_track,
      &txt.scroll_btn_up,
      &txt.scroll_btn_dn,
      &txt.scroll_btn_pos
      );

    bounds.p1.x = MAX( bounds.p1.x - px_scroll, bounds.p0.x );
  }
  txt.scroll_bounds_view = bounds;

  // horizontal scrolling
  if( 0 ) {
    Prof( TxtUpdateScrollingHorizontal );

    // layout the cursor line from line start to c_x, and that's our effective x position.
    auto line = LineFromY( &txt.buf, txt.c_y );
    auto line_clipped = ClipLine( line );
    line_clipped.len = MIN( txt.c_x, line_clipped.len );
    auto offset = LayoutString( font, spaces_per_tab, ML( line_clipped ) );
    auto dim_x = ( bounds.p1.x - bounds.p0.x );
    if( offset > txt.scroll_x + 0.8f * dim_x ) {
      txt.scroll_x = offset - 0.8f * dim_x;
    } elif( offset < txt.scroll_x + 0.2f * dim_x ) {
      txt.scroll_x = MAX( 0, offset - 0.2f * dim_x );
    }

    ProfClose( TxtUpdateScrollingHorizontal );
  }


  // font layout
  {
    Prof( TxtLayout );

    FontClear( txt.layout );
    auto line_start = txt.scroll_start.y;
    u32 ignored_x;
    CursorLineU( &txt.buf, &ignored_x, &line_start, 0, 1 );
    FORLINES( &txt.buf, line, y, line_start, txt.scroll_end + 1 )
      if( line->len ) {
        // add the line text to the layout_t.
        FontAddLayoutLine(
          font,
          txt.layout,
          ML( *line ),
          spaces_per_tab
          );
      }
    }

    ProfClose( TxtLayout );
  }

  // =================================================================================
  //
  // OUTPUT

  Reserve( txt.linespans, txt.window_n_lines + 1 );
  Reserve( txt.charspans, ( txt.window_n_lines + 1 ) * ( txt.window_n_lines + 1 ) );
  txt.linespans.len = 0;
  txt.charspans.len = 0;

  auto c_line = LineFromY( &txt.buf, txt.c_y );
  auto word_l = CursorStopAtNonWordCharL( ML( *c_line ), txt.c_x );
  auto word_r = CursorStopAtNonWordCharR( ML( *c_line ), txt.c_x );
  slice_t word;
  word.mem = c_line->mem + word_l;
  word.len = word_r - word_l;

  auto est_nchars_per_line = 1 + Round_idx_from_f32( ( bounds.p1.x - bounds.p0.x ) / px_space_advance );

  f32 y0 = Cast( f32, -line_h * txt.scroll_start.frac );

  kahansum32_t x;
  kahansum32_t y = { y0 };

  kahansum32_t y_wrapped;

  u32 ignored_x;
  auto line_start = txt.scroll_start.y;
  CursorLineU( &txt.buf, &ignored_x, &line_start, 0, 1 );

  // don't actually offset for the additional line above, if there is one.
  if( line_start != txt.scroll_start.y ) {
    Sub( y, line_h );
  }
  y.sum = Ceil32( y.sum );
  y.err = 0;

  // layout_t doesn't store empty lines, so we have to skip them when looking up the layout info.
  idx_t layout_line_idx = 0;

  FORLINES( &txt.buf, line, line_idx, line_start, txt.scroll_end + 1 )

    x = { 0 - txt.scroll_x };

    y_wrapped = y;

    // split the given line if it's too long.
    Reserve( txt.wrapped_lines, 1 + line->len / est_nchars_per_line );
    txt.wrapped_lines.len = 0;
    {
      // start with all the chars on the same line, and we'll do some accumulation math
      // to find the appropriate splitting points.
      Reserve( txt.charspans_wrapping, line->len );
      txt.charspans_wrapping.len = 0;
      FontGetCharSpans(
        txt.layout,
        layout_line_idx,
        0,
        line->len,
        bounds.p0.x,
        &txt.charspans_wrapping
        );

      if( !line->len ) {
        auto wrapped_line = AddBack( txt.wrapped_lines );
        wrapped_line->start = 0;
        wrapped_line->len = 0;
      }
      else {
        idx_t start = 0;
        auto total = bounds.p0.x;
        while( start < line->len ) {
          auto len = line->len - start;
          For( i, start, txt.charspans_wrapping.len ) {
            auto charspan = txt.charspans_wrapping.mem + i;
            if( ( charspan->xr - total ) > ( bounds.p1.x - bounds.p0.x ) ) {
              len = i - start;
              total = charspan->xl;
              break;
            }
          }

          auto wrapped_line = AddBack( txt.wrapped_lines );
          wrapped_line->start = start;
          wrapped_line->len = len;

          if( !len ) {
            break;
          }

          start += len;
        }
      }

      AssertCrash( txt.wrapped_lines.len );
      idx_t verify_wrapping_len = 0;
      FORLEN( wrapped_line, i, txt.wrapped_lines )
        verify_wrapping_len += wrapped_line->len;
      }
      AssertCrash( verify_wrapping_len == line->len );
    }

    // emit linerect for later mouse code.
    FORLEN( wrapped_line, i, txt.wrapped_lines )
      // PERF: could save some cycles by comparing in origin-relative space.
      auto linespan = AddBack( txt.linespans );
      linespan->yl = bounds.p0.y + y_wrapped.sum;
      linespan->yr = bounds.p0.y + y_wrapped.sum + line_h;
      linespan->y = line_idx;
      AssertCrash( wrapped_line->len <= MAX_u32 ); // TODO: convert txt.linespans/charspans/etc. to u32 sizes?
      if( wrapped_line->len ) {
        linespan->offset = txt.charspans.len;
        FontGetCharSpans(
          txt.layout,
          layout_line_idx,
          wrapped_line->start,
          wrapped_line->len,
          bounds.p0.x,
          &txt.charspans
          );
        // add a charspan for the overhanging pseudo-newline.
        // this is so when you click off the end, this overhang charspan will be chosen as the closest rect.
        // since we allow cursor x to be in [0, line->len], inclusive on the right end, this final charspan will map to that line end.
        auto xr_last = txt.charspans.len  ?  txt.charspans.mem[ txt.charspans.len - 1 ].xr  :  bounds.p0.x;
        auto charspan = AddBack( txt.charspans );
        charspan->xl = xr_last;
        charspan->xr = xr_last + px_space_advance;
        charspan->char_idx_in_line = Cast( u32, wrapped_line->start + wrapped_line->len );
        linespan->len = txt.charspans.len - linespan->offset;
      }
      else {
        linespan->offset = txt.charspans.len;
        auto xr_last = bounds.p0.x;
        auto charspan = AddBack( txt.charspans );
        charspan->xl = xr_last;
        charspan->xr = xr_last + px_space_advance;
        charspan->char_idx_in_line = Cast( u32, wrapped_line->start + wrapped_line->len );
        linespan->len = txt.charspans.len - linespan->offset;
      }
      // line advance.
      Add( y_wrapped, line_h );
      y_wrapped.sum = Ceil32( y_wrapped.sum );
      y_wrapped.err = 0;
    }
    y_wrapped = y;

    // draw cursorline.
    if( draw_cursorline ) {
      if( line_idx == txt.c_y ) {
        ForLen( i, txt.wrapped_lines ) {
          Add( y_wrapped, line_h );
          y_wrapped.sum = Ceil32( y_wrapped.sum );
          y_wrapped.err = 0;
        }
        RenderQuad(
          stream,
          GetPropFromDb( vec4<f32>, rgba_cursorline_bkgd ),
          _vec2( bounds.p0.x, bounds.p0.y + y.sum ),
          _vec2( bounds.p1.x, bounds.p0.y + y_wrapped.sum ),
          bounds,
          GetZ( zrange, txtlayer_t::cursorline )
          );
        y_wrapped = y;
      }
    }

    // draw lineno
    if( txt.wrapped_lines.len == 1 ) {
      // we skip drawing linenos for lines that are wrapped, since they by design render to the end.
      // we could do the same lineno logic and draw at the end of the last pseudo line,
      // but it's probably easier and good enough to just skip it.
      auto line_no = line_idx + 1;
      stack_nonresizeable_stack_t<u8, 64> tmp;
      CsFromIntegerU( tmp.mem, Capacity( tmp ), &tmp.len, line_no, 1 );
      auto lineno_w = LayoutString( font, spaces_per_tab, ML( tmp ) ) + 0.25f * px_space_advance;
      auto lineno_p0 = AlignRight( bounds.p0 + _vec2( x.sum, y.sum ), bounds.p1.x, lineno_w );
      // don't draw the lineno if the line text will overlap, since it looks bad.
      // surrounding lines with linenos provide enough visual context.
      bool draw_lineno = 1;
      if( line->len ) {
        auto linetext_p0 = bounds.p0 + _vec2( x.sum, y.sum );
        auto linetext_w = FontSumAdvances(
          txt.layout,
          layout_line_idx,
          0,
          line->len
          );
        // use an extra px_space_advance for spacing, so we don't draw exactly-abutting linenos.
        if( lineno_p0.x < linetext_p0.x + linetext_w + px_space_advance ) {
          draw_lineno = 0;
        }
      }
      if( draw_lineno ) {
        DrawString(
          stream,
          font,
          lineno_p0,
          GetZ( zrange, txtlayer_t::txt ),
          bounds,
          rgba_lineno,
          spaces_per_tab,
          ML( tmp )
          );
      }
    }

    // draw line text.
    if( line->len ) {
      if( draw_cursorwordmatch  &&  word.len ) {
        // TODO: we really only want to know word-matches, we don't need all the words.
        //   might be more efficient to do a loop of FindFirstInlineR to generate the splits.

        Reserve( txt.wordspans, line->len / 8 );
        txt.wordspans.len = 0;
        SplitIntoWords( &txt.wordspans, ML( *line ) );
        // reuse span->inword to mean 'does the word match the given one'.
        // this is so we can do span splitting w/o losing this info.
        FORLEN( span, span_idx, txt.wordspans )
          auto span_len = span->r - span->l;
          AssertCrash( span_len );
          if( span->inword ) {
            span->inword = MemEqual( line->mem + span->l, span_len, ML( word ) );
          }
        }
        // now we introduce more split points, namely the intermediate boundaries of the wrapped lines.
        // so iterate over all but the last, and use the end of the wrapped line as the split point.
        Reserve( txt.nwords_per_wrapped_line, txt.wrapped_lines.len );
        txt.nwords_per_wrapped_line.len = txt.wrapped_lines.len;
        txt.nwords_per_wrapped_line.mem[0] = 0; // subsequent ones initialized by below code.

        idx_t span_iter = 0;
        idx_t wrapped_line_iter = 0;
        Forever {
          if( wrapped_line_iter >= txt.wrapped_lines.len ) {
            break;
          }
          if( span_iter >= txt.wordspans.len ) {
            break;
          }
          auto span = txt.wordspans.mem + span_iter;
          auto wrapped_line = txt.wrapped_lines.mem + wrapped_line_iter;
          auto wrapped_line_end = wrapped_line->start + wrapped_line->len;
          if( span->r <= wrapped_line_end ) {
            span_iter += 1;
            txt.nwords_per_wrapped_line.mem[wrapped_line_iter] += 1;
            continue;
          }
          if( span->l >= wrapped_line_end ) {
            wrapped_line_iter += 1;
            txt.nwords_per_wrapped_line.mem[wrapped_line_iter] = 0;
            continue;
          }
          auto span_l = AddAt( txt.wordspans, span_iter );
          auto span_r = txt.wordspans.mem + span_iter + 1; // the moved version of 'span'
          span_l->l = span_r->l;
          span_l->r = wrapped_line_end;
          span_l->inword = span_r->inword;
          span_r->l = wrapped_line_end;
          span_iter += 1;
          txt.nwords_per_wrapped_line.mem[wrapped_line_iter] += 1;
          wrapped_line_iter += 1;
          txt.nwords_per_wrapped_line.mem[wrapped_line_iter] = 0;
        }
        AssertCrash( span_iter == txt.wordspans.len );
        AssertCrash( wrapped_line_iter + 1 == txt.wrapped_lines.len );

        idx_t verify_nwords = 0;
        FORLEN( nwords, j, txt.nwords_per_wrapped_line )
          verify_nwords += *nwords;
        }
        AssertCrash( verify_nwords == txt.wordspans.len ); // note we expanded wordspans during splitting above.

        idx_t span_start = 0;
        FORLEN( wrapped_line, wrapped_line_idx, txt.wrapped_lines )
          auto match_start_x = x;
          auto nwords = txt.nwords_per_wrapped_line.mem[wrapped_line_idx];
          For( word_idx, 0, nwords ) {
            auto span = txt.wordspans.mem + span_start + word_idx;
            auto span_len = span->r - span->l;
            AssertCrash( span_len );
            auto is_match = span->inword;
            // auto color = is_match  ?  rgba_wordmatch_text  :  rgba_text;
            auto char_offset = span->l;
            auto char_len = MIN( span_len, c_max_line_len - char_offset );
            auto advance_x = FontSumAdvances(
              txt.layout,
              layout_line_idx,
              char_offset,
              char_len
              );
            // draw match background quad
            if( is_match ) {
              RenderQuad(
                stream,
                rgba_wordmatch_bkgd,
                bounds.p0 + _vec2( match_start_x.sum, y_wrapped.sum ),
                bounds.p0 + _vec2( match_start_x.sum + advance_x, y_wrapped.sum + line_h ),
                bounds,
                GetZ( zrange, txtlayer_t::match )
                );
            }
            // horizontal advance.
            Add( match_start_x, advance_x );
          }
          span_start += nwords;

          // draw text.
          RenderText(
            stream,
            font,
            txt.layout,
            bounds.p0 + _vec2( x.sum, y_wrapped.sum ),
            GetZ( zrange, txtlayer_t::txt ),
            bounds,
            rgba_text,
            layout_line_idx,
            wrapped_line->start,
            wrapped_line->len
            );
          // line advance.
          Add( y_wrapped, line_h );
          y_wrapped.sum = Ceil32( y_wrapped.sum );
          y_wrapped.err = 0;
        }
        y_wrapped = y;
      }
      else { // !draw_cursorwordmatch
        FORLEN( wrapped_line, i, txt.wrapped_lines )
          RenderText(
            stream,
            font,
            txt.layout,
            bounds.p0 + _vec2( x.sum, y_wrapped.sum ),
            GetZ( zrange, txtlayer_t::txt ),
            bounds,
            rgba_text,
            layout_line_idx,
            wrapped_line->start,
            wrapped_line->len
            );
          // line advance.
          Add( y_wrapped, line_h );
          y_wrapped.sum = Ceil32( y_wrapped.sum );
          y_wrapped.err = 0;
        }
        y_wrapped = y;
      }
    } // end if( line->len )

    // draw selection.
    {
      auto rgba_selection_bkgd = GetPropFromDb( vec4<f32>, rgba_selection_bkgd );

      switch( txt.seltype ) {
        case seltype_t::none: {
        } break;

        case seltype_t::s: {
          sel_t sel;
          GetSelect( txt, &sel );
          idx_t sel_start = ( sel.sl_y == line_idx )  ?  sel.sl_x  :  0;
          idx_t sel_end   = ( sel.sr_y == line_idx )  ?  sel.sr_x  :  line->len;
          AssertCrash( sel_start <= sel_end );
          // auto sel_len = sel_end - sel_start;
          f32 overhang  = ( sel.sr_y == line_idx )  ?  0  :  px_space_advance;
          auto line_within_sel = ( sel.sl_y <= line_idx  &&  line_idx <= sel.sr_y );
          if( line->len  &&  line_within_sel ) {
            // WARNING!! identical code to below m case.
            FORLEN( wrapped_line, wrapped_line_idx, txt.wrapped_lines )
              auto wrapped_line_within_sel = !(
                sel_start >= wrapped_line->start + wrapped_line->len  ||
                sel_end <= wrapped_line->start
                );
              if( wrapped_line->len  &&  wrapped_line_within_sel ) {
                auto wsel_start = MAX( sel_start, wrapped_line->start ) - wrapped_line->start;
                auto wsel_end = MIN( sel_end, wrapped_line->start + wrapped_line->len ) - wrapped_line->start;
                AssertCrash( wsel_start <= wsel_end );
                auto wsel_len = wsel_end - wsel_start;
                auto sel_x0 = FontSumAdvances(
                  txt.layout,
                  layout_line_idx,
                  wrapped_line->start,
                  wsel_start
                  );
                auto sel_x1 = sel_x0 + FontSumAdvances(
                  txt.layout,
                  layout_line_idx,
                  wsel_start,
                  wsel_len
                  );
                auto s0 = _vec2( x.sum + sel_x0, y_wrapped.sum );
                auto s1 = _vec2( x.sum + sel_x1 + overhang, y_wrapped.sum + line_h );
                RenderQuad(
                  stream,
                  rgba_selection_bkgd,
                  bounds.p0 + s0,
                  bounds.p0 + s1,
                  bounds,
                  GetZ( zrange, txtlayer_t::sel )
                  );
              }
              // line advance.
              Add( y_wrapped, line_h );
              y_wrapped.sum = Ceil32( y_wrapped.sum );
              y_wrapped.err = 0;
            }
            y_wrapped = y;
          }
        } break;

        case seltype_t::m: {
          multisel_t ms;
          GetMultiselect( txt, ms );
          // draw selection on line.
          auto sel_start = MIN( line->len, ms.left_inline );
          auto sel_end   = MIN( line->len, ms.rght_inline );
          AssertCrash( sel_start <= sel_end );
          // auto sel_len = sel_end - sel_start;
          auto line_within_sel = ( ms.top_y <= line_idx  &&  line_idx <= ms.bot_y );
          if( line_within_sel ) {
            // WARNING!! identical code to above s case.
            FORLEN( wrapped_line, wrapped_line_idx, txt.wrapped_lines )
              auto wrapped_line_within_sel = !(
                sel_start >= wrapped_line->start + wrapped_line->len  ||
                sel_end <= wrapped_line->start
                );
              if( wrapped_line->len  &&  wrapped_line_within_sel ) {
                auto wsel_start = MAX( sel_start, wrapped_line->start ) - wrapped_line->start;
                auto wsel_end = MIN( sel_end, wrapped_line->start + wrapped_line->len ) - wrapped_line->start;
                AssertCrash( wsel_start <= wsel_end );
                auto wsel_len = wsel_end - wsel_start;
                auto sel_x0 = FontSumAdvances(
                  txt.layout,
                  layout_line_idx,
                  wrapped_line->start,
                  wsel_start
                  );
                auto sel_x1 = sel_x0 + FontSumAdvances(
                  txt.layout,
                  layout_line_idx,
                  wsel_start,
                  wsel_len
                  );
                auto s0 = _vec2( x.sum + sel_x0, y_wrapped.sum );
                auto s1 = _vec2( x.sum + sel_x1 + px_cursor_w, y_wrapped.sum + line_h );
                RenderQuad(
                  stream,
                  rgba_selection_bkgd,
                  bounds.p0 + s0,
                  bounds.p0 + s1,
                  bounds,
                  GetZ( zrange, txtlayer_t::sel )
                  );
              }
              // line advance.
              Add( y_wrapped, line_h );
              y_wrapped.sum = Ceil32( y_wrapped.sum );
              y_wrapped.err = 0;
            }
            y_wrapped = y;
          }
        } break;
        default: UnreachableCrash();
      }
    }

    // draw cursor.
    if( draw_cursor ) {
      if( line_idx == txt.c_y ) {
        FORLEN( wrapped_line, i, txt.wrapped_lines )
          if( LTEandLTE( txt.c_x, wrapped_line->start, wrapped_line->start + wrapped_line->len ) ) {
            auto c_x_within_wrapped_line = txt.c_x - wrapped_line->start;
            auto cursor_advance = FontSumAdvances(
              txt.layout,
              layout_line_idx,
              wrapped_line->start,
              c_x_within_wrapped_line
              );
            auto cx = x.sum + cursor_advance;
            rectf32_t r;
            if( txt.overwrite ) {
              r.p0 = bounds.p0 + _vec2( cx, y_wrapped.sum + line_h - px_cursor_w );
              r.p1 = bounds.p0 + _vec2( cx + px_space_advance, y_wrapped.sum + line_h );
            } else {
              r.p0 = bounds.p0 + _vec2( cx, y_wrapped.sum );
              r.p1 = bounds.p0 + _vec2( cx + px_cursor_w, y_wrapped.sum + line_h );
            }
            RenderQuad(
              stream,
              GetPropFromDb( vec4<f32>, rgba_cursor ),
              r,
              bounds,
              GetZ( zrange, txtlayer_t::cur )
              );
          }
          // line advance.
          Add( y_wrapped, line_h );
          y_wrapped.sum = Ceil32( y_wrapped.sum );
          y_wrapped.err = 0;
        }
        y_wrapped = y;
      }
    } // end if( draw_cursor )

    // line advance.
    ForLen( i, txt.wrapped_lines ) {
      Add( y, line_h );
      y.sum = Ceil32( y.sum );
      y.err = 0;
    }
    if( line->len ) {
      layout_line_idx += 1;
    }
  }
}



// TXT INPUTS -> OPERATIONS DISPATCH.
//

Inl void
MapMouseToCursor(
  txt_t& txt,
  rectf32_t bounds,
  vec2<s32> m,
  u32* x,
  u32* y
  )
{
  // PERF: could save some cycles by comparing in origin-relative space.
  auto c_y = txt.scroll_start.y;
  f32 min_distance = MAX_f32;
  linespan_t* linespan_match = 0;
  auto mp = _vec2( Cast( f32, m.x ), Cast( f32, m.y ) );
  constant f32 epsilon = 0.001f;
  FORLEN( linespan, i, txt.linespans )
    if( PtInInterval( mp.y, linespan->yl, linespan->yr, epsilon ) ) {
      linespan_match = linespan;
      break;
    }
    auto distance = DistanceToInterval( mp.y, linespan->yl, linespan->yr );
    if( distance < min_distance ) {
      min_distance = distance;
      linespan_match = linespan;
    }
  }
  auto c_x = 0;
  if( linespan_match ) {
    c_y = linespan_match->y;
    min_distance = MAX_f32;
    AssertCrash( linespan_match->offset <= MAX_u32 );
    Fori( u32, j, 0, linespan_match->len ) {
      auto charspan_idx = Cast( u32, linespan_match->offset ) + j;
      auto charspan = txt.charspans.mem[charspan_idx];
      if( PtInInterval( mp.x, charspan.xl, charspan.xr, epsilon ) ) {
        c_x = charspan.char_idx_in_line;
        break;
      }
      auto distance = DistanceToInterval( mp.x, charspan.xl, charspan.xr );
      if( distance < min_distance ) {
        min_distance = distance;
        c_x = charspan.char_idx_in_line;
      }
    }
  }
  *x = c_x;
  *y = c_y;
}

Inl void
SetScrollPosFraction(
  txt_t& txt,
  f32 t
  )
{
  auto last_line = LastLine( &txt.buf );
  auto pos = Round_u32_from_f32( t * last_line );
  AssertCrash( pos <= last_line );

#if USE_SIMPLE_SCROLLING
  auto center = CursorStopAtNewlineL( txt.buf, pos, 0 );
  txt.scroll_start.y = CursorLineU( txt.buf, center, 0, txt.window_n_lines / 2, 0, 0 );
  txt.scroll_start.frac = 0;
#else
  txt.scroll_target.y = pos;
  txt.scroll_target.frac = 0;
#endif
}

void
TxtControlMouse(
  txt_t& txt,
  bool& target_valid,
  font_t& font,
  rectf32_t bounds,
  glwmouseevent_t type,
  glwmousebtn_t btn,
  vec2<s32> m,
  vec2<s32> raw_delta,
  s32 dwheel,
  bool allow_scrollbar
  )
{
  ProfFunc();

//  auto px_click_correct = _vec2<s8>(); // TODO: mouse control.
  auto scroll_nlines = GetPropFromDb( u8, u8_scroll_nlines );
  auto scroll_sign = GetPropFromDb( s8, s8_scroll_sign );
//  auto dblclick_period_sec = GetPropFromDb( f64, f64_dblclick_period_sec );
  auto scroll_continuous = GetPropFromDb( bool, bool_scroll_continuous );
  auto scroll_continuous_sensitivity = GetPropFromDb( f64, f64_scroll_continuous_sensitivity );

  auto keymods = GlwKeyModifiersDown();
  bool mod_isdn = AnyDown( keymods );

  auto has_scrollbar = txt.has_scrollbar;
  auto btn_up = txt.scroll_btn_up;
  auto btn_dn = txt.scroll_btn_dn;
  // auto btn_pos = txt.scroll_btn_pos;
  auto scroll_track = txt.scroll_track;
  auto scroll_t_mouse = GetScrollMouseT( m, scroll_track );
  auto bounds_view_and_bar = txt.scroll_bounds_view_and_bar;
  auto bounds_view = txt.scroll_bounds_view;

  if( has_scrollbar ) {

    if( GlwMouseInsideRect( m, btn_up ) ) {
      switch( type ) {
        case glwmouseevent_t::dn: break;
        case glwmouseevent_t::up: {
          auto t = MapLineToZeta( txt, txt.scroll_start.y );
          SetScrollPosFraction( txt, CLAMP( t - 0.1f, 0, 1 ) );
          target_valid = 0;
        } break;
        case glwmouseevent_t::move: break;
        case glwmouseevent_t::wheelmove: break;
        default: UnreachableCrash();
      }
    }
    elif( GlwMouseInsideRect( m, btn_dn ) ) {
      switch( type ) {
        case glwmouseevent_t::dn: break;
        case glwmouseevent_t::up: {
          auto t = MapLineToZeta( txt, txt.scroll_start.y );
          SetScrollPosFraction( txt, CLAMP( t + 0.1f, 0, 1 ) );
          target_valid = 0;
        } break;
        case glwmouseevent_t::move: break;
        case glwmouseevent_t::wheelmove: break;
        default: UnreachableCrash();
      }
    }
    elif( GlwMouseInsideRect( m, scroll_track ) ) {
      // note that btn_pos isn't really a button; it's just a rendering of where we are in the track.
      // it's more complicated + stateful to track a button that changes size as we scroll.
      // much easier to just do the linear mapping of the track, and it also feels nice to not have to
      // click exactly on a tiny button; the whole track works the same way.
      switch( type ) {
        case glwmouseevent_t::dn: {
          txt.scroll_grabbed = 1;
          SetScrollPosFraction( txt, CLAMP( scroll_t_mouse, 0, 1 ) );
          target_valid = 0;
        } break;
        case glwmouseevent_t::up: break;
        case glwmouseevent_t::move: break;
        case glwmouseevent_t::wheelmove: break;
        default: UnreachableCrash();
      }
    }
  }

  if( GlwMouseInsideRect( m, bounds_view ) ) {
    if( type == glwmouseevent_t::dn  &&  btn == glwmousebtn_t::l ) {
      txt.text_grabbed = 1;
      auto c_pre_move_x = txt.c_x;
      auto c_pre_move_y = txt.c_y;
      auto c_move_x = c_pre_move_x;
      auto c_move_y = c_pre_move_y;
      MapMouseToCursor(
        txt,
        bounds_view,
        m,
        &c_move_x,
        &c_move_y
        );

      if( keymods.alt ) {
        auto line = LineFromY( &txt.buf, c_move_y );
        auto l = CursorStopAtNonWordCharL( ML( *line ), c_move_x );
        auto r = CursorStopAtNonWordCharR( ML( *line ), c_move_x );
        if( l != r ) {
          txt.seltype = seltype_t::s;
          txt.c_x = r;
          txt.c_y = c_move_y;
          txt.s_x = l;
          txt.s_y = c_move_y;
        } else {
          txt.c_x = c_move_x;
          txt.c_y = c_move_y;
        }
      } else {
        if( SelectIsZero( txt ) ) {
          if( keymods.shift ) {
            txt.seltype = seltype_t::s;
            txt.s_x = c_pre_move_x;
            txt.s_y = c_pre_move_y;
          }
        } else {
          if( !keymods.shift ) {
            txt.seltype = seltype_t::none;
          }
        }
        txt.c_x = c_move_x;
        txt.c_y = c_move_y;
      }
      ResetCInline( txt );
      target_valid = 0;

      //// TODO: handle interaction with C,S,A
      //bool same_cursor = ( c_move == txt.dblclick.first_cursor );
      //bool double_click = And( txt.dblclick.first_made, same_cursor );
      //if( double_click ) {
      //  u64 curr_clock = TimeClock();
      //  f64 dblclick_period = TimeSecFromClocks64( txt.dblclick.first_clock, curr_clock );
      //  if( dblclick_period <= dblclick_period_sec ) {
      //    CmdSelectWordAtCursor( txt );
      //    txt.dblclick.first_made = 0;
      //  } else {
      //    txt.dblclick.first_clock = TimeClock();
      //  }
      //} else {
      //  txt.dblclick.first_made = 1;
      //  txt.dblclick.first_clock = TimeClock();
      //  txt.dblclick.first_cursor = c_move;
      //}
    }
  }

  switch( type ) {
    case glwmouseevent_t::dn: break;

    case glwmouseevent_t::up: {
      if( txt.scroll_grabbed ) {
        txt.scroll_grabbed = 0;
      }
      if( txt.text_grabbed ) {
        txt.text_grabbed = 0;
      }
//      // clear all interactivity state.
//      txt.dblclick.first_made = 0;
    } break;

    case glwmouseevent_t::move: {
      if( txt.scroll_grabbed ) {
        SetScrollPosFraction( txt, CLAMP( scroll_t_mouse, 0, 1 ) );
        target_valid = 0;
      }
      if( txt.text_grabbed ) {
        auto c_pre_move_x = txt.c_x;
        auto c_pre_move_y = txt.c_y;
        auto c_move_x = c_pre_move_x;
        auto c_move_y = c_pre_move_y;
        MapMouseToCursor(
          txt,
          bounds_view,
          m,
          &c_move_x,
          &c_move_y
          );
        bool moved = c_pre_move_x != c_move_x  ||  c_pre_move_y != c_move_y;
        if( !keymods.alt  &&  moved ) {
          if( SelectIsZero( txt ) ) {
            if( moved ) {
              txt.seltype = seltype_t::s;
              txt.s_x = c_pre_move_x;
              txt.s_y = c_pre_move_y;
              txt.c_x = c_move_x;
              txt.c_y = c_move_y;
              ResetCInline( txt );
            }
          } else {
            if( moved ) {
              txt.c_x = c_move_x;
              txt.c_y = c_move_y;
              ResetCInline( txt );
            }
          }
        }
        target_valid = 0;
      }
    } break;

    case glwmouseevent_t::wheelmove: {
      if( GlwMouseInsideRect( m, bounds_view_and_bar )  &&  dwheel  &&  !mod_isdn ) {
        dwheel *= scroll_sign;
#if USE_SIMPLE_SCROLLING
        dwheel *= scroll_nlines;
        if( dwheel >= 0 ) {
          txt.scroll_start.y = CursorLineD( txt.buf, txt.scroll_start.y, 0, Cast( idx_t, dwheel ), 0, 0 );
        } else {
          txt.scroll_start.y = CursorLineU( txt.buf, txt.scroll_start.y, 0, Cast( idx_t, -dwheel ), 0, 0 );
        }
#else
        if( scroll_continuous ) {
          txt.scroll_target.frac += scroll_continuous_sensitivity * dwheel;
        } else {
          dwheel *= scroll_nlines;
          txt.scroll_target.frac += dwheel;
        }
#endif
        target_valid = 0;
      }
    } break;

    default: UnreachableCrash();
  }
}


// TODO: combine keybinds and cmdmap ?

struct
txt_cmdmap_t
{
  glwkeybind_t keybind;
  pfn_txtcmd_t fn;
  idx_t misc;
  idx_t misc2;
};

Inl txt_cmdmap_t
_txtcmdmap(
  glwkeybind_t keybind,
  pfn_txtcmd_t fn,
  idx_t misc = 0,
  idx_t misc2 = 0
  )
{
  txt_cmdmap_t r;
  r.keybind = keybind;
  r.fn = fn;
  r.misc = misc;
  r.misc2 = misc2;
  return r;
}


void
TxtControlKeyboardType(
  txt_t& txt,
  bool& target_valid,
  bool& content_changed,
  bool& ran_cmd,
  glwkeyevent_t type,
  glwkey_t key,
  glwkeylocks_t& keylocks,
  bool allow_ln_add
  )
{
  ProfFunc();

  switch( type ) {
    case glwkeyevent_t::dn:
    case glwkeyevent_t::repeat: {

      bool caps_lock = keylocks.caps;
      txt_cmdmap_t table[] = {
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_a ), CmdAddAlpha , 'a' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_b ), CmdAddAlpha , 'b' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_c ), CmdAddAlpha , 'c' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_d ), CmdAddAlpha , 'd' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_e ), CmdAddAlpha , 'e' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_f ), CmdAddAlpha , 'f' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_g ), CmdAddAlpha , 'g' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_h ), CmdAddAlpha , 'h' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_i ), CmdAddAlpha , 'i' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_j ), CmdAddAlpha , 'j' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_k ), CmdAddAlpha , 'k' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_l ), CmdAddAlpha , 'l' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_m ), CmdAddAlpha , 'm' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_n ), CmdAddAlpha , 'n' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_o ), CmdAddAlpha , 'o' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_p ), CmdAddAlpha , 'p' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_q ), CmdAddAlpha , 'q' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_r ), CmdAddAlpha , 'r' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_s ), CmdAddAlpha , 's' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_t ), CmdAddAlpha , 't' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_u ), CmdAddAlpha , 'u' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_v ), CmdAddAlpha , 'v' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_w ), CmdAddAlpha , 'w' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_x ), CmdAddAlpha , 'x' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_y ), CmdAddAlpha , 'y' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_z ), CmdAddAlpha , 'z' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_A ), CmdAddAlpha , 'A' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_B ), CmdAddAlpha , 'B' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_C ), CmdAddAlpha , 'C' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_D ), CmdAddAlpha , 'D' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_E ), CmdAddAlpha , 'E' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_F ), CmdAddAlpha , 'F' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_G ), CmdAddAlpha , 'G' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_H ), CmdAddAlpha , 'H' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_I ), CmdAddAlpha , 'I' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_J ), CmdAddAlpha , 'J' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_K ), CmdAddAlpha , 'K' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_L ), CmdAddAlpha , 'L' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_M ), CmdAddAlpha , 'M' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_N ), CmdAddAlpha , 'N' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_O ), CmdAddAlpha , 'O' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_P ), CmdAddAlpha , 'P' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_Q ), CmdAddAlpha , 'Q' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_R ), CmdAddAlpha , 'R' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_S ), CmdAddAlpha , 's' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_T ), CmdAddAlpha , 'T' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_U ), CmdAddAlpha , 'U' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_V ), CmdAddAlpha , 'V' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_W ), CmdAddAlpha , 'W' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_X ), CmdAddAlpha , 'X' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_Y ), CmdAddAlpha , 'Y' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_Z ), CmdAddAlpha , 'Z' , !caps_lock ),

        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_0 ), CmdAddString, Cast( idx_t, "0" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_1 ), CmdAddString, Cast( idx_t, "1" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_2 ), CmdAddString, Cast( idx_t, "2" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_3 ), CmdAddString, Cast( idx_t, "3" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_4 ), CmdAddString, Cast( idx_t, "4" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_5 ), CmdAddString, Cast( idx_t, "5" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_6 ), CmdAddString, Cast( idx_t, "6" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_7 ), CmdAddString, Cast( idx_t, "7" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_8 ), CmdAddString, Cast( idx_t, "8" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_9 ), CmdAddString, Cast( idx_t, "9" ), 1 ),

        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_space           ), CmdAddString, Cast( idx_t, " "  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_tilde           ), CmdAddString, Cast( idx_t, "~"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_graveaccent     ), CmdAddString, Cast( idx_t, "`"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_exclamation     ), CmdAddString, Cast( idx_t, "!"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_atsign          ), CmdAddString, Cast( idx_t, "@"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_pound           ), CmdAddString, Cast( idx_t, "#"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_dollar          ), CmdAddString, Cast( idx_t, "$"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_percent         ), CmdAddString, Cast( idx_t, "%"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_caret           ), CmdAddString, Cast( idx_t, "^"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_ampersand       ), CmdAddString, Cast( idx_t, "&"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_star            ), CmdAddString, Cast( idx_t, "*"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_paren_l         ), CmdAddString, Cast( idx_t, "("  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_paren_r         ), CmdAddString, Cast( idx_t, ")"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_minus           ), CmdAddString, Cast( idx_t, "-"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_underscore      ), CmdAddString, Cast( idx_t, "_"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_plus            ), CmdAddString, Cast( idx_t, "+"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_equals          ), CmdAddString, Cast( idx_t, "="  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketsquare_l ), CmdAddString, Cast( idx_t, "["  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketsquare_r ), CmdAddString, Cast( idx_t, "]"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketcurly_l  ), CmdAddString, Cast( idx_t, "{"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketcurly_r  ), CmdAddString, Cast( idx_t, "}"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketangle_l  ), CmdAddString, Cast( idx_t, "<"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketangle_r  ), CmdAddString, Cast( idx_t, ">"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_slashback       ), CmdAddString, Cast( idx_t, "\\" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_slashforw       ), CmdAddString, Cast( idx_t, "/"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_verticalbar     ), CmdAddString, Cast( idx_t, "|"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_semicolon       ), CmdAddString, Cast( idx_t, ";"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_colon           ), CmdAddString, Cast( idx_t, ":"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_quotesingle     ), CmdAddString, Cast( idx_t, "'"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_quotedouble     ), CmdAddString, Cast( idx_t, "\"" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_comma           ), CmdAddString, Cast( idx_t, ","  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_period          ), CmdAddString, Cast( idx_t, "."  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_question        ), CmdAddString, Cast( idx_t, "?"  ), 1 ),

        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_tab_r      ), CmdTabR     ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_ch_l   ), CmdRemChL   ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_word_l ), CmdRemWordL ),
      };
      ForEach( entry, table ) {
        if( GlwKeybind( key, entry.keybind ) ) {
          entry.fn( txt, entry.misc, entry.misc2 );
          target_valid = 0;
          content_changed = 1;
          ran_cmd = 1;
        }
      }

      if( allow_ln_add ) {
        if( GlwKeybind( key, GetPropFromDb( glwkeybind_t, keybind_txt_modal_ln_add ) ) ) {
          CmdAddLn( txt, 0, 0 );
          target_valid = 0;
          content_changed = 1;
          ran_cmd = 1;
        }
      }

      bool num_lock = keylocks.num;
      if( num_lock ) {
        txt_cmdmap_t numpadtable[] = {
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_div     ), CmdAddString, Cast( idx_t, "/" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_mul     ), CmdAddString, Cast( idx_t, "*" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_sub     ), CmdAddString, Cast( idx_t, "-" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_add     ), CmdAddString, Cast( idx_t, "+" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_decimal ), CmdAddString, Cast( idx_t, "." ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_0       ), CmdAddString, Cast( idx_t, "0" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_1       ), CmdAddString, Cast( idx_t, "1" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_2       ), CmdAddString, Cast( idx_t, "2" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_3       ), CmdAddString, Cast( idx_t, "3" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_4       ), CmdAddString, Cast( idx_t, "4" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_5       ), CmdAddString, Cast( idx_t, "5" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_6       ), CmdAddString, Cast( idx_t, "6" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_7       ), CmdAddString, Cast( idx_t, "7" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_8       ), CmdAddString, Cast( idx_t, "8" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_9       ), CmdAddString, Cast( idx_t, "9" ), 1 ),
        };
        ForEach( entry, numpadtable ) {
          if( GlwKeybind( key, entry.keybind ) ) {
            entry.fn( txt, entry.misc, entry.misc2 );
            target_valid = 0;
            content_changed = 1;
            ran_cmd = 1;
          }
        }
      }

    } break;

    case glwkeyevent_t::up: {
    } break;

    default: UnreachableCrash();
  }
}

void
TxtControlKeyboardTypeNotModal(
  txt_t& txt,
  bool& target_valid,
  bool& content_changed,
  bool& ran_cmd,
  glwkeyevent_t type,
  glwkey_t key,
  glwkeylocks_t& keylocks,
  bool allow_ln_add
  )
{
  ProfFunc();

  switch( type ) {
    case glwkeyevent_t::dn:
    case glwkeyevent_t::repeat: {

      bool caps_lock = keylocks.caps;
      txt_cmdmap_t table[] = {
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_a ), CmdAddAlpha , 'a' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_b ), CmdAddAlpha , 'b' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_c ), CmdAddAlpha , 'c' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_d ), CmdAddAlpha , 'd' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_e ), CmdAddAlpha , 'e' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_f ), CmdAddAlpha , 'f' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_g ), CmdAddAlpha , 'g' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_h ), CmdAddAlpha , 'h' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_i ), CmdAddAlpha , 'i' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_j ), CmdAddAlpha , 'j' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_k ), CmdAddAlpha , 'k' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_l ), CmdAddAlpha , 'l' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_m ), CmdAddAlpha , 'm' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_n ), CmdAddAlpha , 'n' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_o ), CmdAddAlpha , 'o' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_p ), CmdAddAlpha , 'p' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_q ), CmdAddAlpha , 'q' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_r ), CmdAddAlpha , 'r' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_s ), CmdAddAlpha , 's' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_t ), CmdAddAlpha , 't' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_u ), CmdAddAlpha , 'u' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_v ), CmdAddAlpha , 'v' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_w ), CmdAddAlpha , 'w' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_x ), CmdAddAlpha , 'x' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_y ), CmdAddAlpha , 'y' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_z ), CmdAddAlpha , 'z' ,  caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_A ), CmdAddAlpha , 'A' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_B ), CmdAddAlpha , 'B' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_C ), CmdAddAlpha , 'C' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_D ), CmdAddAlpha , 'D' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_E ), CmdAddAlpha , 'E' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_F ), CmdAddAlpha , 'F' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_G ), CmdAddAlpha , 'G' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_H ), CmdAddAlpha , 'H' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_I ), CmdAddAlpha , 'I' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_J ), CmdAddAlpha , 'J' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_K ), CmdAddAlpha , 'K' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_L ), CmdAddAlpha , 'L' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_M ), CmdAddAlpha , 'M' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_N ), CmdAddAlpha , 'N' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_O ), CmdAddAlpha , 'O' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_P ), CmdAddAlpha , 'P' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_Q ), CmdAddAlpha , 'Q' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_R ), CmdAddAlpha , 'R' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_S ), CmdAddAlpha , 's' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_T ), CmdAddAlpha , 'T' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_U ), CmdAddAlpha , 'U' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_V ), CmdAddAlpha , 'V' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_W ), CmdAddAlpha , 'W' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_X ), CmdAddAlpha , 'X' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_Y ), CmdAddAlpha , 'Y' , !caps_lock ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_Z ), CmdAddAlpha , 'Z' , !caps_lock ),

        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_0 ), CmdAddString, Cast( idx_t, "0" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_1 ), CmdAddString, Cast( idx_t, "1" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_2 ), CmdAddString, Cast( idx_t, "2" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_3 ), CmdAddString, Cast( idx_t, "3" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_4 ), CmdAddString, Cast( idx_t, "4" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_5 ), CmdAddString, Cast( idx_t, "5" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_6 ), CmdAddString, Cast( idx_t, "6" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_7 ), CmdAddString, Cast( idx_t, "7" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_8 ), CmdAddString, Cast( idx_t, "8" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_9 ), CmdAddString, Cast( idx_t, "9" ), 1 ),

        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_space           ), CmdAddString, Cast( idx_t, " "  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_tilde           ), CmdAddString, Cast( idx_t, "~"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_graveaccent     ), CmdAddString, Cast( idx_t, "`"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_exclamation     ), CmdAddString, Cast( idx_t, "!"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_atsign          ), CmdAddString, Cast( idx_t, "@"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_pound           ), CmdAddString, Cast( idx_t, "#"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_dollar          ), CmdAddString, Cast( idx_t, "$"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_percent         ), CmdAddString, Cast( idx_t, "%"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_caret           ), CmdAddString, Cast( idx_t, "^"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_ampersand       ), CmdAddString, Cast( idx_t, "&"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_star            ), CmdAddString, Cast( idx_t, "*"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_paren_l         ), CmdAddString, Cast( idx_t, "("  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_paren_r         ), CmdAddString, Cast( idx_t, ")"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_minus           ), CmdAddString, Cast( idx_t, "-"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_underscore      ), CmdAddString, Cast( idx_t, "_"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_plus            ), CmdAddString, Cast( idx_t, "+"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_equals          ), CmdAddString, Cast( idx_t, "="  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketsquare_l ), CmdAddString, Cast( idx_t, "["  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketsquare_r ), CmdAddString, Cast( idx_t, "]"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketcurly_l  ), CmdAddString, Cast( idx_t, "{"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketcurly_r  ), CmdAddString, Cast( idx_t, "}"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketangle_l  ), CmdAddString, Cast( idx_t, "<"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_bracketangle_r  ), CmdAddString, Cast( idx_t, ">"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_slashback       ), CmdAddString, Cast( idx_t, "\\" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_slashforw       ), CmdAddString, Cast( idx_t, "/"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_verticalbar     ), CmdAddString, Cast( idx_t, "|"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_semicolon       ), CmdAddString, Cast( idx_t, ";"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_colon           ), CmdAddString, Cast( idx_t, ":"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_quotesingle     ), CmdAddString, Cast( idx_t, "'"  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_quotedouble     ), CmdAddString, Cast( idx_t, "\"" ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_comma           ), CmdAddString, Cast( idx_t, ","  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_period          ), CmdAddString, Cast( idx_t, "."  ), 1 ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_question        ), CmdAddString, Cast( idx_t, "?"  ), 1 ),

        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_tab_r      ), CmdTabR     ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_rem_ch_l   ), CmdRemChL   ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_rem_word_l ), CmdRemWordL ),
      };
      ForEach( entry, table ) {
        if( GlwKeybind( key, entry.keybind ) ) {
          entry.fn( txt, entry.misc, entry.misc2 );
          target_valid = 0;
          content_changed = 1;
          ran_cmd = 1;
        }
      }

      if( allow_ln_add ) {
        if( GlwKeybind( key, GetPropFromDb( glwkeybind_t, keybind_txt_ln_add ) ) ) {
          CmdAddLn( txt, 0, 0 );
          target_valid = 0;
          content_changed = 1;
          ran_cmd = 1;
        }
      }

      bool num_lock = keylocks.num;
      if( num_lock ) {
        txt_cmdmap_t numpadtable[] = {
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_div     ), CmdAddString, Cast( idx_t, "/" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_mul     ), CmdAddString, Cast( idx_t, "*" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_sub     ), CmdAddString, Cast( idx_t, "-" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_add     ), CmdAddString, Cast( idx_t, "+" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_decimal ), CmdAddString, Cast( idx_t, "." ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_0       ), CmdAddString, Cast( idx_t, "0" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_1       ), CmdAddString, Cast( idx_t, "1" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_2       ), CmdAddString, Cast( idx_t, "2" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_3       ), CmdAddString, Cast( idx_t, "3" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_4       ), CmdAddString, Cast( idx_t, "4" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_5       ), CmdAddString, Cast( idx_t, "5" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_6       ), CmdAddString, Cast( idx_t, "6" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_7       ), CmdAddString, Cast( idx_t, "7" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_8       ), CmdAddString, Cast( idx_t, "8" ), 1 ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_type_numpad_9       ), CmdAddString, Cast( idx_t, "9" ), 1 ),
        };
        ForEach( entry, numpadtable ) {
          if( GlwKeybind( key, entry.keybind ) ) {
            entry.fn( txt, entry.misc, entry.misc2 );
            target_valid = 0;
            content_changed = 1;
            ran_cmd = 1;
          }
        }
      }

    } break;

    case glwkeyevent_t::up: {
    } break;

    default: UnreachableCrash();
  }
}


void
TxtControlKeyboardNoContentChange(
  txt_t& txt,
  bool kb_command,
  bool& target_valid,
  bool& ran_cmd,
  glwkeyevent_t type,
  glwkey_t key,
  glwkeylocks_t& keylocks
  )
{
  ProfFunc();

  if( kb_command ) {
    switch( type ) {
      case glwkeyevent_t::dn:
      case glwkeyevent_t::repeat: {
        txt_cmdmap_t table[] = {
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_copy                ), CmdCopy              ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cs_undo             ), CmdCsUndo            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cs_redo             ), CmdCsRedo            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_toggle_insertmode   ), CmdToggleInsertMode  ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_l            ), CmdCursorL           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_r            ), CmdCursorR           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_u            ), CmdCursorU           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_d            ), CmdCursorD           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_home         ), CmdCursorHome        ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_end          ), CmdCursorEnd         ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_page_d       ), CmdCursorJumpD       , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_page_u       ), CmdCursorJumpU       , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_skip_l       ), CmdCursorSkipL       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_skip_r       ), CmdCursorSkipR       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_l            ), CmdSelectL           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_r            ), CmdSelectR           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_u            ), CmdSelectU           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_d            ), CmdSelectD           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_home         ), CmdSelectHome        ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_end          ), CmdSelectEnd         ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_page_d       ), CmdSelectJumpD       , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_page_u       ), CmdSelectJumpU       , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_skip_l       ), CmdSelectSkipL       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_skip_r       ), CmdSelectSkipR       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_all          ), CmdSelectAll         ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_scroll_u            ), CmdScrollU           , Cast( idx_t, GetPropFromDb( f32, f32_lines_per_jump ) ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_scroll_d            ), CmdScrollD           , Cast( idx_t, GetPropFromDb( f32, f32_lines_per_jump ) ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_scroll_page_u       ), CmdScrollU           , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_scroll_page_d       ), CmdScrollD           , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_make_present ), CmdCursorMakePresent ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_multicursor_u       ), CmdMultiCursorU      ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_multicursor_d       ), CmdMultiCursorD      ),
        };
        ForEach( entry, table ) {
          if( GlwKeybind( key, entry.keybind ) ) {
            entry.fn( txt, entry.misc, entry.misc2 );
            target_valid = 0;
            ran_cmd = 1;
          }
        }
      } break;

      case glwkeyevent_t::up: {
      } break;

      default: UnreachableCrash();
    }
  }
}

void
TxtControlKeyboard(
  txt_t& txt,
  bool kb_command,
  bool& target_valid,
  bool& content_changed,
  bool& ran_cmd,
  glwkeyevent_t type,
  glwkey_t key,
  glwkeylocks_t& keylocks
  )
{
  ProfFunc();

  if( kb_command ) {
    switch( type ) {
      case glwkeyevent_t::dn:
      case glwkeyevent_t::repeat: {
        txt_cmdmap_t table_contentchange[] = {
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cut                 ), CmdCut                ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_paste               ), CmdPaste              ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_txt_undo            ), CmdTxtUndo            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_txt_redo            ), CmdTxtRedo            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_tab_r               ), CmdTabR               ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_tab_l               ), CmdTabL               ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_ch_l            ), CmdRemChL             ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_ch_r            ), CmdRemChR             ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_word_l          ), CmdRemWordL           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_word_r          ), CmdRemWordR           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_line_r          ), CmdRemLineR           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_comment_selection   ), CmdCommentSelection   ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_uncomment_selection ), CmdUncommentSelection ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_ln_add              ), CmdAddLn              ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_ln_rem              ), CmdRemLn              ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_ln_comment          ), CmdComment            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_ln_uncomment        ), CmdUncomment          ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_ln_comment_toggle   ), CmdToggleComment      ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_ln_permute_u        ), CmdPermuteU           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_ln_permute_d        ), CmdPermuteD           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_trailspace      ), CmdRemTrailspace      ),
        };
        ForEach( entry, table_contentchange ) {
          if( GlwKeybind( key, entry.keybind ) ) {
            entry.fn( txt, entry.misc, entry.misc2 );
            target_valid = 0;
            content_changed = 1;
            ran_cmd = 1;
          }
        }

        txt_cmdmap_t table[] = {
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_copy                ), CmdCopy              ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cs_undo             ), CmdCsUndo            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cs_redo             ), CmdCsRedo            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_toggle_insertmode   ), CmdToggleInsertMode  ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_l            ), CmdCursorL           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_r            ), CmdCursorR           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_u            ), CmdCursorU           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_d            ), CmdCursorD           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_home         ), CmdCursorHome        ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_end          ), CmdCursorEnd         ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_page_d       ), CmdCursorJumpD       , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_page_u       ), CmdCursorJumpU       , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_skip_l       ), CmdCursorSkipL       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_skip_r       ), CmdCursorSkipR       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_l            ), CmdSelectL           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_r            ), CmdSelectR           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_u            ), CmdSelectU           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_d            ), CmdSelectD           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_home         ), CmdSelectHome        ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_end          ), CmdSelectEnd         ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_page_d       ), CmdSelectJumpD       , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_page_u       ), CmdSelectJumpU       , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_skip_l       ), CmdSelectSkipL       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_skip_r       ), CmdSelectSkipR       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_all          ), CmdSelectAll         ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_scroll_u            ), CmdScrollU           , Cast( idx_t, GetPropFromDb( f32, f32_lines_per_jump ) ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_scroll_d            ), CmdScrollD           , Cast( idx_t, GetPropFromDb( f32, f32_lines_per_jump ) ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_scroll_page_u       ), CmdScrollU           , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_scroll_page_d       ), CmdScrollD           , Cast( idx_t, txt.window_n_lines / 2 ) ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_make_present ), CmdCursorMakePresent ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_multicursor_u       ), CmdMultiCursorU      ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_multicursor_d       ), CmdMultiCursorD      ),
        };
        ForEach( entry, table ) {
          if( GlwKeybind( key, entry.keybind ) ) {
            entry.fn( txt, entry.misc, entry.misc2 );
            target_valid = 0;
            ran_cmd = 1;
          }
        }
      } break;

      case glwkeyevent_t::up: {
      } break;

      default: UnreachableCrash();
    }
  }

  if( !ran_cmd ) {
    if( !kb_command ) {
      TxtControlKeyboardType(
        txt,
        target_valid,
        content_changed,
        ran_cmd,
        type,
        key,
        keylocks,
        1
        );
    }
  }
}


void
TxtControlKeyboardSingleLine(
  txt_t& txt,
  bool kb_command,
  bool& target_valid,
  bool& content_changed,
  bool& ran_cmd,
  glwkeyevent_t type,
  glwkey_t key,
  glwkeylocks_t& keylocks
  )
{
  ProfFunc();

  if( kb_command ) {
    switch( type ) {
      case glwkeyevent_t::dn:
      case glwkeyevent_t::repeat: {
        txt_cmdmap_t table_contentchange[] = {
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cut        ), CmdCut               ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_paste      ), CmdPaste             ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_txt_undo   ), CmdTxtUndo           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_txt_redo   ), CmdTxtRedo           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_tab_r      ), CmdTabR              ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_tab_l      ), CmdTabL              ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_ch_l   ), CmdRemChL            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_ch_r   ), CmdRemChR            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_word_l ), CmdRemWordL          ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_word_r ), CmdRemWordR          ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_rem_line_r ), CmdRemLineR          ),
        };
        ForEach( entry, table_contentchange ) {
          if( GlwKeybind( key, entry.keybind ) ) {
            entry.fn( txt, entry.misc, entry.misc2 );
            target_valid = 0;
            content_changed = 1;
            ran_cmd = 1;
          }
        }

        txt_cmdmap_t table[] = {
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_copy                ), CmdCopy              ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cs_undo             ), CmdCsUndo            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cs_redo             ), CmdCsRedo            ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_toggle_insertmode   ), CmdToggleInsertMode  ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_l            ), CmdCursorL           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_r            ), CmdCursorR           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_home         ), CmdCursorHome        ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_end          ), CmdCursorEnd         ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_skip_l       ), CmdCursorSkipL       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_cursor_skip_r       ), CmdCursorSkipR       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_l            ), CmdSelectL           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_r            ), CmdSelectR           ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_home         ), CmdSelectHome        ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_end          ), CmdSelectEnd         ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_skip_l       ), CmdSelectSkipL       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_skip_r       ), CmdSelectSkipR       ),
          _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_modal_select_all          ), CmdSelectAll         ),
        };
        ForEach( entry, table ) {
          if( GlwKeybind( key, entry.keybind ) ) {
            entry.fn( txt, entry.misc, entry.misc2 );
            target_valid = 0;
            ran_cmd = 1;
          }
        }
      } break;

      case glwkeyevent_t::up: {
      } break;

      default: UnreachableCrash();
    }
  }

  if( !ran_cmd ) {
    if( !kb_command ) {
      TxtControlKeyboardType(
        txt,
        target_valid,
        content_changed,
        ran_cmd,
        type,
        key,
        keylocks,
        0
        );
    }
  }
}

void
TxtControlKeyboardSingleLineNotModal(
  txt_t& txt,
  bool& target_valid,
  bool& content_changed,
  bool& ran_cmd,
  glwkeyevent_t type,
  glwkey_t key,
  glwkeylocks_t& keylocks
  )
{
  ProfFunc();

  switch( type ) {
    case glwkeyevent_t::dn:
    case glwkeyevent_t::repeat: {
      txt_cmdmap_t table_contentchange[] = {
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cut        ), CmdCut               ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_paste      ), CmdPaste             ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_txt_undo   ), CmdTxtUndo           ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_txt_redo   ), CmdTxtRedo           ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_tab_r      ), CmdTabR              ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_tab_l      ), CmdTabL              ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_rem_ch_l   ), CmdRemChL            ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_rem_ch_r   ), CmdRemChR            ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_rem_word_l ), CmdRemWordL          ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_rem_word_r ), CmdRemWordR          ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_rem_line_r ), CmdRemLineR          ),
      };
      ForEach( entry, table_contentchange ) {
        if( GlwKeybind( key, entry.keybind ) ) {
          entry.fn( txt, entry.misc, entry.misc2 );
          target_valid = 0;
          content_changed = 1;
          ran_cmd = 1;
        }
      }

      txt_cmdmap_t table[] = {
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_copy                ), CmdCopy              ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cs_undo             ), CmdCsUndo            ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cs_redo             ), CmdCsRedo            ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_toggle_insertmode   ), CmdToggleInsertMode  ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cursor_l            ), CmdCursorL           ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cursor_r            ), CmdCursorR           ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cursor_home         ), CmdCursorHome        ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cursor_end          ), CmdCursorEnd         ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cursor_skip_l       ), CmdCursorSkipL       ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_cursor_skip_r       ), CmdCursorSkipR       ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_select_l            ), CmdSelectL           ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_select_r            ), CmdSelectR           ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_select_home         ), CmdSelectHome        ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_select_end          ), CmdSelectEnd         ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_select_skip_l       ), CmdSelectSkipL       ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_select_skip_r       ), CmdSelectSkipR       ),
        _txtcmdmap( GetPropFromDb( glwkeybind_t, keybind_txt_select_all          ), CmdSelectAll         ),
      };
      ForEach( entry, table ) {
        if( GlwKeybind( key, entry.keybind ) ) {
          entry.fn( txt, entry.misc, entry.misc2 );
          target_valid = 0;
          ran_cmd = 1;
        }
      }
    } break;

    case glwkeyevent_t::up: {
    } break;

    default: UnreachableCrash();
  }

  if( !ran_cmd ) {
    TxtControlKeyboardTypeNotModal(
      txt,
      target_valid,
      content_changed,
      ran_cmd,
      type,
      key,
      keylocks,
      0
      );
  }
}




Inl void
AssertCrashTxt( txt_t& txt, u8* str, eoltype_t eoltype )
{
  AssertCrashBuf( txt.buf, str, eoltype );
}
Inl void
AssertCrashTxt( txt_t& txt, u8* str )
{
  AssertCrashBuf( txt.buf, str, eoltype_t::crlf );
}

struct
test_txtcmd_t
{
  pfn_txtcmd_t fn;
  idx_t misc;
  idx_t misc2;
};

static void
TestTxt()
{
  txt_t txt;

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file = "0123456789";
    constexpr auto expect = "012389";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    For( i, 0, 4 ) { CmdCursorR( txt ); }
    For( i, 0, 4 ) { CmdSelectR( txt ); }
    CmdRemChL( txt );
    AssertCrashTxt( txt, Str( expect ) );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, Str( file ) );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );

    constexpr auto file = R"STRING(
; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25547.0
include listing.inc
INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_06FJKEMHGD@global?$AA@			; `string'
PUBLIC	??_C@_05NKHOCLEE@alias?$AA@			; `string'
PUBLIC	??_C@_07FHOHOHLG@include?$AA@			; `string'
PUBLIC	??_C@_02HEBPBKGD@if?$AA@			; `string'
PUBLIC	??_C@_04GNFOIEOK@elif?$AA@			; `string'
PUBLIC	??_C@_04FHMCPBIP@else?$AA@			; `string'
PUBLIC	??_C@_05OODBEKIG@while?$AA@			; `string'
PUBLIC	??_C@_08DLICDMBN@continue?$AA@			; `string'
)STRING";

    constexpr auto expect = R"STRING(
; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25547.0
include listing.inc
INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
  PUBLIC	??_C@_06FJKEMHGD@global?$AA@			; `string'
  PUBLIC	??_C@_05NKHOCLEE@alias?$AA@			; `string'
  PUBLIC	??_C@_07FHOHOHLG@include?$AA@			; `string'
  PUBLIC	??_C@_02HEBPBKGD@if?$AA@			; `string'
  PUBLIC	??_C@_04GNFOIEOK@elif?$AA@			; `string'
PUBLIC	??_C@_04FHMCPBIP@else?$AA@			; `string'
PUBLIC	??_C@_05OODBEKIG@while?$AA@			; `string'
PUBLIC	??_C@_08DLICDMBN@continue?$AA@			; `string'
)STRING";

    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    CmdCursorJumpD( txt, 6 );
    CmdSelectJumpD( txt, 4 );
    CmdTabR( txt );
    AssertCrashTxt( txt, Str( expect ), eoltype_t::lf );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, Str( file ), eoltype_t::lf );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file   = "  lead2spaces\r\n  \r\nend";
    constexpr auto expect = "  lead2spaces\r\n  \r\n  \r\nend";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    CmdCursorJumpD( txt, 1 );
    CmdCursorEnd( txt );
    CmdAddLn( txt );
    AssertCrashTxt( txt, Str( expect ) );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, Str( file ) );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file   = "linespan_x_t\n{\n};\n";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    CmdCursorJumpD( txt, 1 );
    CmdCursorEnd( txt );
    CmdAddLn( txt );
    AssertCrashTxt( txt, Str( "linespan_x_t\n{\n\n};\n" ), eoltype_t::lf );
    CmdTabR( txt );
    AssertCrashTxt( txt, Str( "linespan_x_t\n{\n  \n};\n" ), eoltype_t::lf );
    CmdTxtUndo( txt );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, Str( file ), eoltype_t::lf );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file   = "ln0\r\nln1\r\nln2\r\nln3";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 0 );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln1\r\nln0\r\nln2\r\nln3" ) );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 1 );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln1\r\nln2\r\nln0\r\nln3" ) );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 2 );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln1\r\nln2\r\nln3\r\nln0" ) );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 3 );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( "ln1\r\nln2\r\nln0\r\nln3" ) );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 2 );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( "ln1\r\nln0\r\nln2\r\nln3" ) );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 1 );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( file ) );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 0 );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file   = "ln0\r\nln1\r\nln2\r\nln3";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    CmdSelectAll( txt );
    AssertCrash( txt.c_x == 3 );
    AssertCrash( txt.c_y == 3 );
    AssertCrash( txt.s_x == 0 );
    AssertCrash( txt.s_y == 0 );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file   = "ln0\r\nln1\r\nln2\r\nln3";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 0 );
    CmdCursorEnd( txt );
    AssertCrash( txt.c_x == 3 );
    AssertCrash( txt.c_y == 0 );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln1\r\nln0\r\nln2\r\nln3" ) );
    AssertCrash( txt.c_x == 3 );
    AssertCrash( txt.c_y == 1 );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln1\r\nln2\r\nln0\r\nln3" ) );
    AssertCrash( txt.c_x == 3 );
    AssertCrash( txt.c_y == 2 );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln1\r\nln2\r\nln3\r\nln0" ) );
    AssertCrash( txt.c_x == 3 );
    AssertCrash( txt.c_y == 3 );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( "ln1\r\nln2\r\nln0\r\nln3" ) );
    AssertCrash( txt.c_x == 3 );
    AssertCrash( txt.c_y == 2 );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( "ln1\r\nln0\r\nln2\r\nln3" ) );
    AssertCrash( txt.c_x == 3 );
    AssertCrash( txt.c_y == 1 );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( file ) );
    AssertCrash( txt.c_x == 3 );
    AssertCrash( txt.c_y == 0 );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file   = "ln0\r\n\r\n\r\nln3";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    CmdCursorEnd( txt );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "\r\nln0\r\n\r\nln3" ) );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "\r\n\r\nln0\r\nln3" ) );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "\r\n\r\nln3\r\nln0" ) );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( "\r\n\r\nln0\r\nln3" ) );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( "\r\nln0\r\n\r\nln3" ) );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( file ) );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file   = "\r\nln1\r\nln2\r\nln3";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    CmdCursorEnd( txt );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln1\r\n\r\nln2\r\nln3" ) );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln1\r\nln2\r\n\r\nln3" ) );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln1\r\nln2\r\nln3\r\n" ) );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( "ln1\r\nln2\r\n\r\nln3" ) );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( "ln1\r\n\r\nln2\r\nln3" ) );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( file ) );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file   = "ln0\r\nln1\r\nln2\r\n\r\n";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    CmdCursorEnd( txt );
    CmdSelectD( txt );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln2\r\nln0\r\nln1\r\n\r\n" ) );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln2\r\n\r\nln0\r\nln1\r\n" ) );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( "ln2\r\nln0\r\nln1\r\n\r\n" ) );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( file ) );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file   = "\r\nln1\r\nln2\r\nln3\r\n";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    CmdSelectD( txt );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 1 );
    AssertCrash( txt.s_x == 0 );
    AssertCrash( txt.s_y == 0 );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln2\r\n\r\nln1\r\nln3\r\n" ) );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 2 );
    AssertCrash( txt.s_x == 0 );
    AssertCrash( txt.s_y == 1 );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln2\r\nln3\r\n\r\nln1\r\n" ) );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 3 );
    AssertCrash( txt.s_x == 0 );
    AssertCrash( txt.s_y == 2 );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( "ln2\r\n\r\nln1\r\nln3\r\n" ) );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 2 );
    AssertCrash( txt.s_x == 0 );
    AssertCrash( txt.s_y == 1 );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( file ) );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 1 );
    AssertCrash( txt.s_x == 0 );
    AssertCrash( txt.s_y == 0 );
    Kill( txt );
  }

  { // same as above, but with txt.c/s flipped.
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file   = "\r\nln1\r\nln2\r\nln3\r\n";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    CmdCursorD( txt );
    CmdSelectU( txt );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 0 );
    AssertCrash( txt.s_x == 0 );
    AssertCrash( txt.s_y == 1 );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln2\r\n\r\nln1\r\nln3\r\n" ) );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 1 );
    AssertCrash( txt.s_x == 0 );
    AssertCrash( txt.s_y == 2 );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln2\r\nln3\r\n\r\nln1\r\n" ) );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 2 );
    AssertCrash( txt.s_x == 0 );
    AssertCrash( txt.s_y == 3 );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( "ln2\r\n\r\nln1\r\nln3\r\n" ) );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 1 );
    AssertCrash( txt.s_x == 0 );
    AssertCrash( txt.s_y == 2 );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( file ) );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 0 );
    AssertCrash( txt.s_x == 0 );
    AssertCrash( txt.s_y == 1 );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file   = "\r\n\r\nln2\r\nln3\r\n";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    CmdSelectD( txt );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln2\r\n\r\n\r\nln3\r\n" ) );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln2\r\nln3\r\n\r\n\r\n" ) );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( "ln2\r\n\r\n\r\nln3\r\n" ) );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( file ) );
    Kill( txt );
  }

  { // same as above, but with txt.c/s flipped.
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file   = "\r\n\r\nln2\r\nln3\r\n";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    CmdCursorD( txt );
    CmdSelectU( txt );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln2\r\n\r\n\r\nln3\r\n" ) );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "ln2\r\nln3\r\n\r\n\r\n" ) );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( "ln2\r\n\r\n\r\nln3\r\n" ) );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( file ) );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file = "  ln0\r\n\r\n  ln2\r\n";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    CmdSelectJumpD( txt, 2 );
    CmdTabL( txt );
    AssertCrashTxt( txt, Str( "ln0\r\n\r\nln2\r\n" ) );
    CmdTabR( txt );
    AssertCrashTxt( txt, Str( "  ln0\r\n  \r\n  ln2\r\n" ) );
    CmdRemTrailspace( txt );
    AssertCrashTxt( txt, Str( file ) );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file = "ln0\r\n\r\nln1\r\n";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    CmdCursorEnd( txt );
    CmdMultiCursorD( txt );
    CmdMultiCursorD( txt );
    CmdMultiCursorD( txt );
    CmdRemWordL( txt );
    AssertCrashTxt( txt, Str( "\r\n\r\n\r\n" ) );
    CmdRemWordL( txt );
    AssertCrashTxt( txt, Str( "\r\n\r\n\r\n" ) );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file = "ln0\r\n\r\nln1\r\n";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    CmdMultiCursorD( txt );
    CmdMultiCursorD( txt );
    CmdMultiCursorD( txt );
    CmdRemWordR( txt );
    AssertCrashTxt( txt, Str( "\r\n\r\n\r\n" ) );
    CmdRemWordR( txt );
    AssertCrashTxt( txt, Str( "\r\n\r\n\r\n" ) );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file = "ln0\r\n\r\nln1\r\n";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    CmdCursorR( txt );
    CmdCursorR( txt );
    CmdMultiCursorD( txt );
    CmdMultiCursorD( txt );
    CmdMultiCursorD( txt );
    CmdRemLineR( txt );
    AssertCrashTxt( txt, Str( "ln\r\n\r\nln\r\n" ) );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, Str( file ) );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    CmdAddString( txt, 0, 0 );
    AssertCrashTxt( txt, Str( "" ) );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    AssertCrashTxt( txt, Str( "" ) );
    CmdAddAlpha( txt, 'a', 0 );
    CmdAddAlpha( txt, 'b', 0 );
    CmdAddAlpha( txt, 'c', 0 );
    CmdAddAlpha( txt, 'd', 0 );
    CmdAddAlpha( txt, 'e', 0 );
    CmdAddAlpha( txt, 'f', 0 );
    AssertCrashTxt( txt, Str( "abcdef" ) );
    AssertCrash( txt.c_x == 6 );
    AssertCrash( txt.c_y == 0 );
    AssertCrash( txt.c_inline == 6 );
    CmdAddLn( txt );
    AssertCrashTxt( txt, Str( "abcdef\r\n" ) );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 1 );
    AssertCrash( txt.c_inline == 0 );
    CmdAddAlpha( txt, 'g', 0 );
    CmdAddAlpha( txt, 'h', 0 );
    CmdAddAlpha( txt, 'i', 0 );
    AssertCrashTxt( txt, Str( "abcdef\r\nghi" ) );
    CmdAddLn( txt );
    AssertCrashTxt( txt, Str( "abcdef\r\nghi\r\n" ) );
    CmdAddAlpha( txt, 'j', 0 );
    CmdAddAlpha( txt, 'k', 0 );
    CmdAddAlpha( txt, 'l', 0 );
    CmdAddAlpha( txt, 'm', 0 );
    CmdAddAlpha( txt, 'n', 0 );
    CmdAddAlpha( txt, 'o', 0 );
    AssertCrashTxt( txt, Str( "abcdef\r\nghi\r\njklmno" ) );
    AssertCrash( txt.c_x == 6 );
    AssertCrash( txt.c_y == 2 );
    CmdRemWordL( txt );
    AssertCrashTxt( txt, Str( "abcdef\r\nghi\r\n" ) );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 2 );
    CmdRemWordL( txt );
    AssertCrashTxt( txt, Str( "abcdef\r\nghi" ) );
    AssertCrash( txt.c_x == 3 );
    AssertCrash( txt.c_y == 1 );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, Str( "abcdef\r\nghi\r\n" ) );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 2 );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, Str( "abcdef\r\nghi\r\njklmno" ) );
    AssertCrash( txt.c_x == 6 );
    AssertCrash( txt.c_y == 2 );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "abcdef\r\nghi\r\njklmno" ) );
    AssertCrash( txt.c_x == 6 );
    AssertCrash( txt.c_y == 2 );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( "abcdef\r\njklmno\r\nghi" ) );
    AssertCrash( txt.c_x == 6 );
    AssertCrash( txt.c_y == 1 );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "abcdef\r\nghi\r\njklmno" ) );
    AssertCrash( txt.c_x == 6 );
    AssertCrash( txt.c_y == 2 );
    CmdCursorHome( txt );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 2 );
    CmdMultiCursorU( txt );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 1 );
    CmdPermuteU( txt );
    AssertCrashTxt( txt, Str( "ghi\r\njklmno\r\nabcdef" ) );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "abcdef\r\nghi\r\njklmno" ) );
    CmdRemChR( txt );
    AssertCrashTxt( txt, Str( "abcdef\r\nhi\r\nklmno" ) );
    CmdAddAlpha( txt, 'a', 0 );
    AssertCrashTxt( txt, Str( "abcdef\r\nahi\r\naklmno" ) );
    AssertCrash( txt.c_x == 1 );
    AssertCrash( txt.c_y == 1 );
    CmdCursorJumpD( txt, 10 );
    CmdCursorJumpD( txt, 10 );
    AssertCrash( txt.c_x == 1 );
    AssertCrash( txt.c_y == 2 );
    CmdCursorEnd( txt );
    AssertCrash( txt.c_x == 6 );
    AssertCrash( txt.c_y == 2 );
    CmdMultiCursorU( txt );
    CmdMultiCursorU( txt );
    AssertCrash( txt.c_x == 6 );
    AssertCrash( txt.c_y == 0 );
    CmdRemChL( txt );
    AssertCrashTxt( txt, Str( "abcde\r\nahi\r\naklmn" ) );
    AssertCrash( txt.c_x == 5 );
    AssertCrash( txt.c_y == 0 );
    CmdRemChL( txt );
    AssertCrashTxt( txt, Str( "abcd\r\nahi\r\naklm" ) );
    AssertCrash( txt.c_x == 4 );
    AssertCrash( txt.c_y == 0 );
    CmdRemChL( txt );
    AssertCrashTxt( txt, Str( "abc\r\nahi\r\nakl" ) );
    AssertCrash( txt.c_x == 3 );
    AssertCrash( txt.c_y == 0 );
    CmdRemChL( txt );
    AssertCrashTxt( txt, Str( "ab\r\nah\r\nak" ) );
    AssertCrash( txt.c_x == 2 );
    AssertCrash( txt.c_y == 0 );
    CmdTxtUndo( txt );
    CmdTxtUndo( txt );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, Str( "abcde\r\nahi\r\naklmn" ) );
    AssertCrash( txt.c_x == 5 );
    AssertCrash( txt.c_y == 0 );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constantold auto file = Str( "ln0\r\nln1" );
    constantold auto expect = Str( "ln/*0\r\nln*/1" );
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( file ) );
    CmdCursorFileL( txt );
    CmdCursorR( txt );
    CmdCursorR( txt );
    CmdSelectR( txt ); // select 0
    CmdSelectR( txt ); // select newline
    CmdSelectR( txt ); // select l
    CmdSelectR( txt ); // select n
    AssertCrash( txt.c_x == 2 );
    AssertCrash( txt.c_y == 1 );
    AssertCrash( txt.s_x == 2 );
    AssertCrash( txt.s_y == 0 );
    CmdCommentSelection( txt );
    AssertCrashTxt( txt, expect );
    AssertCrash( txt.c_x == 4 );
    AssertCrash( txt.c_y == 1 );
    AssertCrash( txt.s_x == 2 );
    AssertCrash( txt.s_y == 0 );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, file );
    AssertCrash( txt.c_x == 2 );
    AssertCrash( txt.c_y == 1 );
    AssertCrash( txt.s_x == 2 );
    AssertCrash( txt.s_y == 0 );
    CmdTxtRedo( txt );
    AssertCrashTxt( txt, expect );
    AssertCrash( txt.c_x == 4 );
    AssertCrash( txt.c_y == 1 );
    AssertCrash( txt.s_x == 2 );
    AssertCrash( txt.s_y == 0 );
    CmdUncommentSelection( txt );
    AssertCrashTxt( txt, file );
    AssertCrash( txt.c_x == 2 );
    AssertCrash( txt.c_y == 1 );
    AssertCrash( txt.s_x == 2 );
    AssertCrash( txt.s_y == 0 );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, expect );
    AssertCrash( txt.c_x == 4 );
    AssertCrash( txt.c_y == 1 );
    AssertCrash( txt.s_x == 2 );
    AssertCrash( txt.s_y == 0 );
    CmdTxtRedo( txt );
    AssertCrashTxt( txt, file );
    AssertCrash( txt.c_x == 2 );
    AssertCrash( txt.c_y == 1 );
    AssertCrash( txt.s_x == 2 );
    AssertCrash( txt.s_y == 0 );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file = "0123456789";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 0 );
    CmdCursorR( txt );
    AssertCrash( txt.c_x == 1 );
    AssertCrash( txt.c_y == 0 );
    CmdCursorR( txt );
    AssertCrash( txt.c_x == 2 );
    AssertCrash( txt.c_y == 0 );
    CmdAddLn( txt );
    AssertCrashTxt( txt, Str( "01\n23456789" ), eoltype_t::lf );
    AssertCrash( txt.c_x == 0 );
    AssertCrash( txt.c_y == 1 );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, Str( file ), eoltype_t::lf );
    AssertCrash( txt.c_x == 2 );
    AssertCrash( txt.c_y == 0 );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file = "234567\n\n01\n";
    CmdAddString( txt, Cast( idx_t, file ), CstrLength( Str( file ) ) );
    CmdCursorFileL( txt );
    CmdPermuteD( txt );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( "\n01\n234567\n" ), eoltype_t::lf );
    //                             ----
    CmdCursorL( txt );
    CmdSelectR( txt );
    CmdSelectR( txt );
    CmdSelectR( txt );
    CmdRemChR( txt );
    AssertCrashTxt( txt, Str( "\n014567\n" ), eoltype_t::lf );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, Str( "\n01\n234567\n" ), eoltype_t::lf );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file0 = "0123456789\n";
    constexpr auto file1 = "\n0123456789";
    CmdAddString( txt, Cast( idx_t, file0 ), CstrLength( Str( file0 ) ) );
    CmdCursorFileL( txt );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( file1 ), eoltype_t::lf );
    CmdPermuteD( txt );
    AssertCrashTxt( txt, Str( file1 ), eoltype_t::lf );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, Str( file1 ), eoltype_t::lf );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, Str( file0 ), eoltype_t::lf );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file0 = "0123456789\nabcdefghij\n";
    CmdAddString( txt, Cast( idx_t, file0 ), CstrLength( Str( file0 ) ) );
    CmdCursorFileL( txt );
    CmdCursorR( txt );
    CmdCursorR( txt );
    CmdCursorR( txt );
    CmdCursorR( txt );
    CmdCursorR( txt );
    CmdSelectD( txt );
    CmdCopy( txt );
    CmdPaste( txt );
    AssertCrashTxt( txt, Str( file0 ), eoltype_t::lf );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, Str( file0 ), eoltype_t::lf );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    //                      0         1
    //                      01234567890123456789
    constexpr auto file0 = "0123456789          ";
    CmdAddString( txt, Cast( idx_t, file0 ), CstrLength( Str( file0 ) ) );
    CmdCursorFileL( txt );
    CmdCursorEnd( txt );
    AssertCrash( txt.c_x == 20 );
    AssertCrash( txt.c_y == 0 );
    CmdCursorEnd( txt );
    AssertCrash( txt.c_x == 10 );
    AssertCrash( txt.c_y == 0 );
    CmdCursorEnd( txt );
    AssertCrash( txt.c_x == 20 );
    AssertCrash( txt.c_y == 0 );
    CmdCsUndo( txt );
    AssertCrash( txt.c_x == 10 );
    AssertCrash( txt.c_y == 0 );
    CmdCsRedo( txt );
    AssertCrash( txt.c_x == 20 );
    AssertCrash( txt.c_y == 0 );
    Kill( txt );
  }

  {
    Init( txt );
    TxtLoadEmpty( txt );
    constexpr auto file0 = "  Free( txt.linespan_ys );\n  Free( txt.linespan_xs );\n";
    constexpr auto file1 = "  ( txt.linespan_ys );\n  ( txt.linespan_xs );\n";
    constexpr auto file2 = "   txt.linespan_ys );\n   txt.linespan_xs );\n";
    constexpr auto file3 = "  txt.linespan_ys );\n  txt.linespan_xs );\n";
    CmdAddString( txt, Cast( idx_t, file0 ), CstrLength( Str( file0 ) ) );
    CmdCursorFileL( txt );
    CmdCursorSkipR( txt );
    CmdMultiCursorD( txt );
    CmdRemWordR( txt );
    AssertCrashTxt( txt, Str( file1 ), eoltype_t::lf );
    CmdRemWordR( txt );
    AssertCrashTxt( txt, Str( file2 ), eoltype_t::lf );
    CmdRemWordR( txt );
    AssertCrashTxt( txt, Str( file3 ), eoltype_t::lf );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, Str( file2 ), eoltype_t::lf );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, Str( file1 ), eoltype_t::lf );
    CmdTxtUndo( txt );
    AssertCrashTxt( txt, Str( file0 ), eoltype_t::lf );
    Kill( txt );
  }

  // big command fuzzer that just executes commands, w/o verifying the actual results.
  // we have all sorts of internal asserts, so just exercising more state space is great.
  // this found a dozen or so simple, small bugs immediately.
  // very much worth it.
  {
    Init( txt );

    auto filename = SliceFromCStr( "../big.config" );
    file_t file = FileOpen( ML( filename ), fileopen_t::only_existing, fileop_t::R, fileop_t::R );
    TxtLoad( txt, file );
    FileFree( file );

    test_txtcmd_t cmds[] = {
      { CmdScrollD,            0, 0 },
      { CmdScrollU,            0, 0 },
      { CmdCsUndo,             0, 0 },
      { CmdCsRedo,             0, 0 },
      { CmdToggleInsertMode,   0, 0 },
      { CmdCursorL,            0, 0 },
      { CmdCursorR,            0, 0 },
      { CmdCursorU,            0, 0 },
      { CmdCursorD,            0, 0 },
      { CmdSelectL,            0, 0 },
      { CmdSelectR,            0, 0 },
      { CmdSelectU,            0, 0 },
      { CmdSelectD,            0, 0 },
      { CmdSelectWordAtCursor, 0, 0 },
      { CmdCursorHome,         0, 0 },
      { CmdCursorEnd,          0, 0 },
      { CmdSelectHome,         0, 0 },
      { CmdSelectEnd,          0, 0 },
      { CmdCursorFileL,        0, 0 },
      { CmdCursorFileR,        0, 0 },
      { CmdCursorGotoline,     10, 0 },
      { CmdCursorJumpD,        1, 0 },
      { CmdCursorJumpU,        1, 0 },
      { CmdSelectJumpD,        1, 0 },
      { CmdSelectJumpU,        1, 0 },
      { CmdCursorSkipL,        0, 0 },
      { CmdCursorSkipR,        0, 0 },
      { CmdSelectSkipL,        0, 0 },
      { CmdSelectSkipR,        0, 0 },
      { CmdSelectAll,          0, 0 },
      { CmdMultiCursorU,       0, 0 },
      { CmdMultiCursorD,       0, 0 },
      { CmdAddString,          Cast( idx_t, "0123456789\nabcdefghij\nABCDEFGHIJ" ), 10 },
      { CmdTabR,               0, 0 },
      { CmdTabL,               0, 0 },
      { CmdRemChL,             0, 0 },
      { CmdRemChR,             0, 0 },
      { CmdRemWordL,           0, 0 },
      { CmdRemWordR,           0, 0 },
      { CmdRemLineR,           0, 0 },
      { CmdAddLn,              0, 0 },
      { CmdRemLn,              0, 0 },
      { CmdComment,            0, 0 },
      { CmdUncomment,          0, 0 },
      { CmdToggleComment,      0, 0 },
      { CmdCommentSelection,   0, 0 },
      { CmdUncommentSelection, 0, 0 },
      { CmdPermuteU,           0, 0 },
      { CmdPermuteD,           0, 0 },
      { CmdTxtUndo,            0, 0 },
      { CmdTxtRedo,            0, 0 },
      { CmdCopy,               0, 0 },
      { CmdCut,                0, 0 },
      { CmdPaste,              0, 0 },
      { CmdRemTrailspace,      0, 0 },
    };

    constant idx_t ncmds = 1000000;
//    stack_resizeable_cont_t<pfn_txtcmd_t> history;
//    Alloc( history, ncmds );
    auto t0 = TimeTSC();
    rng_xorshift32_t rng;
    Init( rng, 12345 );
    For( i, 0, ncmds ) {
//      if( i % ( ncmds / 100 ) == 0 ) {
//        printf( "%llu / %llu\n", i, ncmds );
//      }
//      if( i == 2952634 ) { __debugbreak(); }
      auto cmd_idx = Rand32( rng ) % _countof( cmds );
      auto cmd = cmds[cmd_idx];
//      auto pre = AllocContents( &txt.buf, eoltype_t::lf );
      cmd.fn( txt, cmd.misc, cmd.misc2 );
//      auto post = AllocContents( &txt.buf, eoltype_t::lf );
//      *AddBack( history ) = cmd.fn;
//      Free( post );
//      Free( pre );
    }
    auto dt = TimeSecFromTSC64( TimeTSC() - t0 );
    printf( "%F\n", dt );
//    Free( history );

    Kill( txt );
  }
}
